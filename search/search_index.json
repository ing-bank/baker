{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Baker is a library that reduces the effort to orchestrate (micro)service-based process flows. Developers declare the orchestration logic in a Recipe (process blueprint). A Recipe is made out of: Interactions (functions) Ingredients (containers for data) Events The Baker runtime on the other hand runs instances of the Recipe across a cluster of nodes in an asynchronous fashion. Baker allows you to Declaratively design your business processes using a recipe Domain Specific Language (DSL) . Visualize your recipe allowing product owners, architects and developers to talk the same language. Manage your recipes using the Baker runtime . Create process instances of your recipes. Fire sensory events . Inquire the state of your recipe instances. Why Baker Upgrading your business to an agile, adaptive and scalable microservice-based architecture does bring significant advantages, but also critical challenges that must be resolved: the coupling of business logic to service technologies and the inherent complexities of distributed systems Baker solves these challenges by providing an expressive language to encode your business logic (recipe) , and a distributed runtime to scale recipe instances with little configuration and no extra development. Decouple your business logic from your microservices : When developing microservices it is easy to fall into bad practices where developers encode essential business logic into code which might get polluted with implementation details, and even worse, distributed over many independent projects/repositories. Baker, in contrast, requires the developer to express the business logic as a Recipe by using the provided language DSL, and separately code implementations of the data (events) and the process steps (interactions) , enforcing decoupling of business from technology. Ease the friction of distributed systems : When developing microservices you are confronted with all the inherent challenges of distributed systems, topics like communication models, consistency decisions, handling failure, scaling models, etc. Baker eases the development by providing out-of-the-box solutions from its clusterized runtime. Baker nodes are able to create and distribute recipe instances between them, handle failed interactions with several strategies, restore the state of long-lived process and more, allowing the developer to focus on what it matters for the business. Reason about your business process without the burdens of technology : Baker can visualize your recipes , enabling developers and business stakeholders to better communicate and reason about the business processes. Example of a simple web shop recipe: How to read these docs There are two big sections: The Development Life Cycle : works like a big tutorial of Baker, it is a \"learning by making\" type of documentation, it is for those who like a top-down approach to learning. The Reference : has descriptions of every part of Baker, it is a \"dictionary/reference\" type of documentation, it is for those who like a bottom-up approach to learning, and also works as a reference for quickly reviewing concepts in the future.","title":"Home"},{"location":"#introduction","text":"Baker is a library that reduces the effort to orchestrate (micro)service-based process flows. Developers declare the orchestration logic in a Recipe (process blueprint). A Recipe is made out of: Interactions (functions) Ingredients (containers for data) Events The Baker runtime on the other hand runs instances of the Recipe across a cluster of nodes in an asynchronous fashion.","title":"Introduction"},{"location":"#baker-allows-you-to","text":"Declaratively design your business processes using a recipe Domain Specific Language (DSL) . Visualize your recipe allowing product owners, architects and developers to talk the same language. Manage your recipes using the Baker runtime . Create process instances of your recipes. Fire sensory events . Inquire the state of your recipe instances.","title":"Baker allows you to"},{"location":"#why-baker","text":"Upgrading your business to an agile, adaptive and scalable microservice-based architecture does bring significant advantages, but also critical challenges that must be resolved: the coupling of business logic to service technologies and the inherent complexities of distributed systems Baker solves these challenges by providing an expressive language to encode your business logic (recipe) , and a distributed runtime to scale recipe instances with little configuration and no extra development. Decouple your business logic from your microservices : When developing microservices it is easy to fall into bad practices where developers encode essential business logic into code which might get polluted with implementation details, and even worse, distributed over many independent projects/repositories. Baker, in contrast, requires the developer to express the business logic as a Recipe by using the provided language DSL, and separately code implementations of the data (events) and the process steps (interactions) , enforcing decoupling of business from technology. Ease the friction of distributed systems : When developing microservices you are confronted with all the inherent challenges of distributed systems, topics like communication models, consistency decisions, handling failure, scaling models, etc. Baker eases the development by providing out-of-the-box solutions from its clusterized runtime. Baker nodes are able to create and distribute recipe instances between them, handle failed interactions with several strategies, restore the state of long-lived process and more, allowing the developer to focus on what it matters for the business. Reason about your business process without the burdens of technology : Baker can visualize your recipes , enabling developers and business stakeholders to better communicate and reason about the business processes.","title":"Why Baker"},{"location":"#example-of-a-simple-web-shop-recipe","text":"","title":"Example of a simple web shop recipe:"},{"location":"#how-to-read-these-docs","text":"There are two big sections: The Development Life Cycle : works like a big tutorial of Baker, it is a \"learning by making\" type of documentation, it is for those who like a top-down approach to learning. The Reference : has descriptions of every part of Baker, it is a \"dictionary/reference\" type of documentation, it is for those who like a bottom-up approach to learning, and also works as a reference for quickly reviewing concepts in the future.","title":"How to read these docs"},{"location":"archive/","text":"Introduction Baker is a library that reduces the effort to orchestrate (micro)service-based process flows. Developers declare the orchestration logic in a Recipe (process blueprint). A Recipe is made out of: Interactions (functions) Ingredients (data) Events More about these concepts here . Overview Baker allows you to: Declaritavely design your processes using a recipe DSL . Visualize your recipe allowing product owners, architects and developers to talk the same language. Manage your recipes using the baker runtime . Create process instances of your recipes. Fire sensory events . Inquire the state of your process instances. Visual representation Below an example of a simple web shop recipe:","title":"Index"},{"location":"archive/#introduction","text":"Baker is a library that reduces the effort to orchestrate (micro)service-based process flows. Developers declare the orchestration logic in a Recipe (process blueprint). A Recipe is made out of: Interactions (functions) Ingredients (data) Events More about these concepts here .","title":"Introduction"},{"location":"archive/#overview","text":"Baker allows you to: Declaritavely design your processes using a recipe DSL . Visualize your recipe allowing product owners, architects and developers to talk the same language. Manage your recipes using the baker runtime . Create process instances of your recipes. Fire sensory events . Inquire the state of your process instances.","title":"Overview"},{"location":"archive/#visual-representation","text":"Below an example of a simple web shop recipe:","title":"Visual representation"},{"location":"archive/baker-runtime/","text":"Baker Runtime With the Recipe DSL you can create a description of your recipe. This does not yet constitute a runnable process. It is just a description. To execute & manage your recipes you require the Baker Runtime . Starting the baker runtime Creating a baker runtime is as easy as calling the empty constructor. Scala // Create a Baker Runtime val baker = new Baker (); Java // Create a Baker Runtime JBaker baker = new JBaker (); Baker is build on top of akka . It requires an ActorSystem to start. In the previous example the actor system is not provided. In that case baker will create an actor system for you. If you already have an actor system then you can give it to Baker. Scala val actorSystem = ActorSystem (); Baker baker = new Baker ( actorSystem ); Java ActorSystem actorSystem = ActorSystem . create (); JBaker baker = new JBaker ( actorSystem ); Adding interaction implementations Before you can add a recipe all the interactions for that recipe MUST have an implemention in Baker. You can add them like this: Scala val validateOrderImpl = new ValidateOrderImpl () baker . addInteractionInstance ( validateOrderImpl ) Java ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); baker . addInteractionInstance ( validateOrderImpl ); Compiling your Recipe A recipe is writen in a DSL . This is just a declarative description of your process. In order to execute it we need to compile it. This connects all the pieces into a graph (more precisly a petri net ). For this purpose there is the RecipeCompiler . Scala val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( recipe ) Java CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); Did you know?! You can use a compiled recipe to create a visual representation. See the visualization page how to create a visual graph. Adding your Compiled Recipe Once you have compiled your recipe you can add it to Baker. Scala baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) Java baker . addRecipe ( RecipeRecord . of ( compiledRecipe )); Putting it all together Combining all these steps gives us the following: // Implementations, probably defined in other files ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); ManufactureGoodsImpl manufactureGoodsImpl = new ManufactureGoodsImpl (); // Compiling the Recipe CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); // Creating a Baker Runtime JBaker baker = new JBaker (); // Add the Implementations baker . addInteractionInstances ( validateOrderImpl , manufactureGoodsImpl ); // Add the Compiled Recipe String recipeId = baker . addRecipe ( RecipeRecord . of ( compiledRecipe )); Baker is now ready to create an instance for the recipe and execute it.","title":"Baker Runtime"},{"location":"archive/baker-runtime/#baker-runtime","text":"With the Recipe DSL you can create a description of your recipe. This does not yet constitute a runnable process. It is just a description. To execute & manage your recipes you require the Baker Runtime .","title":"Baker Runtime"},{"location":"archive/baker-runtime/#starting-the-baker-runtime","text":"Creating a baker runtime is as easy as calling the empty constructor. Scala // Create a Baker Runtime val baker = new Baker (); Java // Create a Baker Runtime JBaker baker = new JBaker (); Baker is build on top of akka . It requires an ActorSystem to start. In the previous example the actor system is not provided. In that case baker will create an actor system for you. If you already have an actor system then you can give it to Baker. Scala val actorSystem = ActorSystem (); Baker baker = new Baker ( actorSystem ); Java ActorSystem actorSystem = ActorSystem . create (); JBaker baker = new JBaker ( actorSystem );","title":"Starting the baker runtime"},{"location":"archive/baker-runtime/#adding-interaction-implementations","text":"Before you can add a recipe all the interactions for that recipe MUST have an implemention in Baker. You can add them like this: Scala val validateOrderImpl = new ValidateOrderImpl () baker . addInteractionInstance ( validateOrderImpl ) Java ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); baker . addInteractionInstance ( validateOrderImpl );","title":"Adding interaction implementations"},{"location":"archive/baker-runtime/#compiling-your-recipe","text":"A recipe is writen in a DSL . This is just a declarative description of your process. In order to execute it we need to compile it. This connects all the pieces into a graph (more precisly a petri net ). For this purpose there is the RecipeCompiler . Scala val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( recipe ) Java CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); Did you know?! You can use a compiled recipe to create a visual representation. See the visualization page how to create a visual graph.","title":"Compiling your Recipe"},{"location":"archive/baker-runtime/#adding-your-compiled-recipe","text":"Once you have compiled your recipe you can add it to Baker. Scala baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) Java baker . addRecipe ( RecipeRecord . of ( compiledRecipe ));","title":"Adding your Compiled Recipe"},{"location":"archive/baker-runtime/#putting-it-all-together","text":"Combining all these steps gives us the following: // Implementations, probably defined in other files ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl (); ManufactureGoodsImpl manufactureGoodsImpl = new ManufactureGoodsImpl (); // Compiling the Recipe CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); // Creating a Baker Runtime JBaker baker = new JBaker (); // Add the Implementations baker . addInteractionInstances ( validateOrderImpl , manufactureGoodsImpl ); // Add the Compiled Recipe String recipeId = baker . addRecipe ( RecipeRecord . of ( compiledRecipe )); Baker is now ready to create an instance for the recipe and execute it.","title":"Putting it all together"},{"location":"archive/concepts/","text":"Concepts Baker introduces interactions , ingredients , and events as a model of abstracting. With these three components we can create recipes (process blue prints) Ingredient Ingredients are pure data . This data is immutable , can not be changed after entering the process. There is no hi\u00ebrarchy in this data. ( Animal -> Dog -> Labrador is not possible to express) Examples: an IBAN a track and trace code a list of phone numbers a customer information object with name, email, etc ... An ingredient is defined by a name and type . The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...) The type sets limits on the form of data that is accepted. (a number, a list of strings, ...) This type is expressed by the baker type system . Interaction An interaction is analagous to a function. It requires input ( ingredients ) and provides output ( events ). Within this contract it may do anything. For example: query an external system put a message on a bus generate a document or image extract or compose ingredients into others When finished, an interaction provides an event as its output. Interaction failure An interaction may fail to fulfill its intended purpose. We distinquish 2 types of failures. A technical failure is one that could be retried and succeed. For example: Time outs because of unreliable network, packet loss External system is temporarily down or unresponsive External system returned a malformed/unexpected response These failures are unexpected and are are modeled by throwing an exception from the interaction. A functional failure is one that cannot be retried. For example: The customer is too young for the request. Not enough credit to perform the transfer. These failures are expected possible outcomes of the interaction. They are modelled by returning an event from the interaction. Failure mitigation In case of technical failures, baker offers 2 mitigation strategies: Retry with incremental backoff This retries the interaction with some configurable parameters: initialTimeout : The initial delay for the first retry. backoffFactor : The backoff factor. maximumInterval : The maximum interval between retries. Continue with an event. This is analagous to a try/catch in java code. The exception is logged but the process continues with a specified event. When no failure strategy is defined for an interaction by default the interaction is blocked . Event An event has a name and can (optionally) provide ingredients. The purpose of events is therefor twofold. It signifies something of interest happened for a process instance . Example, \"the customer placed the order\" , \"terms and conditions were accepted\" The event may provide ingredients required to continue the process. Example, \"OrderPlaced\" -> <list of products> We distinquish 2 types of events. Sensory events ( external ) These events are provided from outside of the process. Interaction output ( internal ) These events are a result of an interaction being executed. Recipe Events , Interactions and Ingredients can be composed into recipes. Recipes are analagous to process blueprints. Baker provides a Recipe DSL in which you can declaritively describe your recipe. A small example: new Recipe ( \"webshop\" ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class )); The main take away is that when declaring your recipe you do not have to think about order. Everything is automatically linked by the data requirements of the interactions.","title":"Concepts"},{"location":"archive/concepts/#concepts","text":"Baker introduces interactions , ingredients , and events as a model of abstracting. With these three components we can create recipes (process blue prints)","title":"Concepts"},{"location":"archive/concepts/#ingredient","text":"Ingredients are pure data . This data is immutable , can not be changed after entering the process. There is no hi\u00ebrarchy in this data. ( Animal -> Dog -> Labrador is not possible to express) Examples: an IBAN a track and trace code a list of phone numbers a customer information object with name, email, etc ... An ingredient is defined by a name and type . The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...) The type sets limits on the form of data that is accepted. (a number, a list of strings, ...) This type is expressed by the baker type system .","title":"Ingredient"},{"location":"archive/concepts/#interaction","text":"An interaction is analagous to a function. It requires input ( ingredients ) and provides output ( events ). Within this contract it may do anything. For example: query an external system put a message on a bus generate a document or image extract or compose ingredients into others When finished, an interaction provides an event as its output.","title":"Interaction"},{"location":"archive/concepts/#interaction-failure","text":"An interaction may fail to fulfill its intended purpose. We distinquish 2 types of failures. A technical failure is one that could be retried and succeed. For example: Time outs because of unreliable network, packet loss External system is temporarily down or unresponsive External system returned a malformed/unexpected response These failures are unexpected and are are modeled by throwing an exception from the interaction. A functional failure is one that cannot be retried. For example: The customer is too young for the request. Not enough credit to perform the transfer. These failures are expected possible outcomes of the interaction. They are modelled by returning an event from the interaction.","title":"Interaction failure"},{"location":"archive/concepts/#failure-mitigation","text":"In case of technical failures, baker offers 2 mitigation strategies: Retry with incremental backoff This retries the interaction with some configurable parameters: initialTimeout : The initial delay for the first retry. backoffFactor : The backoff factor. maximumInterval : The maximum interval between retries. Continue with an event. This is analagous to a try/catch in java code. The exception is logged but the process continues with a specified event. When no failure strategy is defined for an interaction by default the interaction is blocked .","title":"Failure mitigation"},{"location":"archive/concepts/#event","text":"An event has a name and can (optionally) provide ingredients. The purpose of events is therefor twofold. It signifies something of interest happened for a process instance . Example, \"the customer placed the order\" , \"terms and conditions were accepted\" The event may provide ingredients required to continue the process. Example, \"OrderPlaced\" -> <list of products> We distinquish 2 types of events. Sensory events ( external ) These events are provided from outside of the process. Interaction output ( internal ) These events are a result of an interaction being executed.","title":"Event"},{"location":"archive/concepts/#recipe","text":"Events , Interactions and Ingredients can be composed into recipes. Recipes are analagous to process blueprints. Baker provides a Recipe DSL in which you can declaritively describe your recipe. A small example: new Recipe ( \"webshop\" ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class )); The main take away is that when declaring your recipe you do not have to think about order. Everything is automatically linked by the data requirements of the interactions.","title":"Recipe"},{"location":"archive/dictionary/","text":"Dictionary Here we define some common used lanuage that is used in this documentation. Name Description Recipe A process blue print Recipe id A unique identifier for a Recipe which is computed (a hash). Process instance A running instance of a Recipe Process id A unique identifier for a process instance which is chosen by the user. Sensory event An event given to baker for a process instance","title":"Dictionary"},{"location":"archive/dictionary/#dictionary","text":"Here we define some common used lanuage that is used in this documentation. Name Description Recipe A process blue print Recipe id A unique identifier for a Recipe which is computed (a hash). Process instance A running instance of a Recipe Process id A unique identifier for a process instance which is chosen by the user. Sensory event An event given to baker for a process instance","title":"Dictionary"},{"location":"archive/event-listener/","text":"Event Listener Often it may be of interest to be notified of events that occur while operating Baker. There are 2 types of events that can be subscribed to. Events defined in your recipe that occur in the context of a process instance. Technical / internal events that occur within the baker runtime. Important limitations Event delivery is asynchronous , NO order guarantee is given All events do come with time stamps. Event delivery is AT MOST ONCE In case of ungraceful shutdown, you may miss events. Because of these limitations it is not recommended to use these listeners for primary business logic. Process instance events You might be interested which Events are raised for process instances of a recipe. For this purpose there is an EventListener interface. You may implement this interface and register it to Baker. Scala val listener : EventListener = new EventListener { override def processEvent ( recipeInstanceId : String , event : RuntimeEvent ) = ??? } val baker : Baker = ??? // initialize baker baker . registerEventListener ( listener ); Java EventListener listener = new EventListener () { @Override public void processEvent ( String recipeInstanceId , RuntimeEvent event ) { // } } JBaker baker = null ; // initialize baker baker . registerEventListener ( listener ); Internal events For the purpose of logging, tracing, etc.. is is possible to register to internal events that happen inside Baker. List of events Class Description ProcessCreated A process instance was created EventReceived A sensory event for a process instance was received EventRejected A sensory event for a process instance was rejected InteractionStarted An interaction started executing InteractionCompleted An interaction completed executing InteractionFailed An interaction failed during execution RecipeAdded A Recipe was added Subscription mechanism You can subscribe to these events by registering a listener to baker. In scala partial functions are used. In java you can register objects that have methods annotated with @Subscribe . In case you are interested in ALL events you can register to the general BakerEvent . In the example below a listener is registered that is only interested in EventReceived : Scala import com.ing.baker.runtime.core.events._ val baker : com.ing.baker.runtime.scaladsl.Baker = ??? // initialize baker baker . registerListenerPF { case e : EventReceived => // ... } Java import com.ing.baker.runtime.core.events.* ; class Subscriber { @Subscribe public void receiveEventReceived ( EventReceived event ) { // ... } } com . ing . baker . runtime . javadsl . JBaker baker = null ; // initialize baker baker . registerEventListener ( new Subscriber ());","title":"Event Listener"},{"location":"archive/event-listener/#event-listener","text":"Often it may be of interest to be notified of events that occur while operating Baker. There are 2 types of events that can be subscribed to. Events defined in your recipe that occur in the context of a process instance. Technical / internal events that occur within the baker runtime.","title":"Event Listener"},{"location":"archive/event-listener/#important-limitations","text":"Event delivery is asynchronous , NO order guarantee is given All events do come with time stamps. Event delivery is AT MOST ONCE In case of ungraceful shutdown, you may miss events. Because of these limitations it is not recommended to use these listeners for primary business logic.","title":"Important limitations"},{"location":"archive/event-listener/#process-instance-events","text":"You might be interested which Events are raised for process instances of a recipe. For this purpose there is an EventListener interface. You may implement this interface and register it to Baker. Scala val listener : EventListener = new EventListener { override def processEvent ( recipeInstanceId : String , event : RuntimeEvent ) = ??? } val baker : Baker = ??? // initialize baker baker . registerEventListener ( listener ); Java EventListener listener = new EventListener () { @Override public void processEvent ( String recipeInstanceId , RuntimeEvent event ) { // } } JBaker baker = null ; // initialize baker baker . registerEventListener ( listener );","title":"Process instance events"},{"location":"archive/event-listener/#internal-events","text":"For the purpose of logging, tracing, etc.. is is possible to register to internal events that happen inside Baker.","title":"Internal events"},{"location":"archive/event-listener/#list-of-events","text":"Class Description ProcessCreated A process instance was created EventReceived A sensory event for a process instance was received EventRejected A sensory event for a process instance was rejected InteractionStarted An interaction started executing InteractionCompleted An interaction completed executing InteractionFailed An interaction failed during execution RecipeAdded A Recipe was added","title":"List of events"},{"location":"archive/event-listener/#subscription-mechanism","text":"You can subscribe to these events by registering a listener to baker. In scala partial functions are used. In java you can register objects that have methods annotated with @Subscribe . In case you are interested in ALL events you can register to the general BakerEvent . In the example below a listener is registered that is only interested in EventReceived : Scala import com.ing.baker.runtime.core.events._ val baker : com.ing.baker.runtime.scaladsl.Baker = ??? // initialize baker baker . registerListenerPF { case e : EventReceived => // ... } Java import com.ing.baker.runtime.core.events.* ; class Subscriber { @Subscribe public void receiveEventReceived ( EventReceived event ) { // ... } } com . ing . baker . runtime . javadsl . JBaker baker = null ; // initialize baker baker . registerEventListener ( new Subscriber ());","title":"Subscription mechanism"},{"location":"archive/execution-semantics/","text":"Execution Semantics Execution loop This is a short description of the execution loop of a process instance A EventInstance is raised and provides IngredientInstances . Either given to baker as a \"SensoryEvent\" (nickname for EventInstances that you fire using Baker APIs) or by an InteractionInstance . A check is done to find the Interactions that have all their input IngredientInstances provided and those are executed. An InteractionInstance completes its execution and outputs an EventInstances which provides more IngredientInstances for the next InteractionInstnaces (repeating step 1). Notes A sensory event may be provided 1 or more times depending on its firing limit . When ingredients are provided multiple times, the latest value overrides the previous. An interaction fires when all it's ingredients and required events are provided. This may happen 1 or more times depending on the maximum interaction count . To know more you will first need to understand the how a petri net works. Below is an explanation of how a recipe relates to a petri net. In depth A recipe can be represented (and visualized ) as a graph. This graph is actually a higher level representation of a petri net (which is also a graph). The execution of a process instance is based around the state of a petri net. The recipe compiler takes a recipe and creates a petri net from it. Generally the petri net graph is more complicated with extra layers of wiring nodes. Translation rules The compiler has some rules about translating recipe parts to transitions and places in the petri net. Ingredient used by multiple interactions Often an ingredient will be used by multiple interactions in a recipe. Because tokens can only be consumed by 1 transition we have to add a layer to duplicate the token for all transitions. Interaction with precondition (AND) By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction. Interaction with precodition (OR) Events that are grouped in an OR combinator for an interaction output a token to the same place, therefor when one of them fires the condition for the transition to fire is met. Sensory event with firing limit When specifying a sensory event with a firing limit of n we generate a in-adjacent place with n tokens in the initial marking.","title":"Execution Semantics"},{"location":"archive/execution-semantics/#execution-semantics","text":"","title":"Execution Semantics"},{"location":"archive/execution-semantics/#execution-loop","text":"This is a short description of the execution loop of a process instance A EventInstance is raised and provides IngredientInstances . Either given to baker as a \"SensoryEvent\" (nickname for EventInstances that you fire using Baker APIs) or by an InteractionInstance . A check is done to find the Interactions that have all their input IngredientInstances provided and those are executed. An InteractionInstance completes its execution and outputs an EventInstances which provides more IngredientInstances for the next InteractionInstnaces (repeating step 1).","title":"Execution loop"},{"location":"archive/execution-semantics/#notes","text":"A sensory event may be provided 1 or more times depending on its firing limit . When ingredients are provided multiple times, the latest value overrides the previous. An interaction fires when all it's ingredients and required events are provided. This may happen 1 or more times depending on the maximum interaction count . To know more you will first need to understand the how a petri net works. Below is an explanation of how a recipe relates to a petri net.","title":"Notes"},{"location":"archive/execution-semantics/#in-depth","text":"A recipe can be represented (and visualized ) as a graph. This graph is actually a higher level representation of a petri net (which is also a graph). The execution of a process instance is based around the state of a petri net. The recipe compiler takes a recipe and creates a petri net from it. Generally the petri net graph is more complicated with extra layers of wiring nodes.","title":"In depth"},{"location":"archive/execution-semantics/#translation-rules","text":"The compiler has some rules about translating recipe parts to transitions and places in the petri net.","title":"Translation rules"},{"location":"archive/execution-semantics/#ingredient-used-by-multiple-interactions","text":"Often an ingredient will be used by multiple interactions in a recipe. Because tokens can only be consumed by 1 transition we have to add a layer to duplicate the token for all transitions.","title":"Ingredient used by multiple interactions"},{"location":"archive/execution-semantics/#interaction-with-precondition-and","text":"By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction.","title":"Interaction with precondition (AND)"},{"location":"archive/execution-semantics/#interaction-with-precodition-or","text":"Events that are grouped in an OR combinator for an interaction output a token to the same place, therefor when one of them fires the condition for the transition to fire is met.","title":"Interaction with precodition (OR)"},{"location":"archive/execution-semantics/#sensory-event-with-firing-limit","text":"When specifying a sensory event with a firing limit of n we generate a in-adjacent place with n tokens in the initial marking.","title":"Sensory event with firing limit"},{"location":"archive/feature-comparison/","text":"This is a comparison of Baker with similar solutions. Feedback and contributions to solutions not listed are most welcome. Feature Baker Camunda Pega Netflix Conductor Uber Cadence Apache Airflow Owned By ING Camunda PEGA Systems Netflix Uber Community Primary Purpose Orchestration of (micro-)services Process Automation Workflow or case management Orchestration of (micro-)services Orchestration of long-running business logic Workflow of big-data pipelines Typical Use Straight Through Processing (STP) Business Processes with Decision Making Business Processes with Decision Making STP STP Big data Skill-set required Java or Scala Java, Business Process Modelling Notation (BPMN) Pega-specific JSON Java Python, Bash Execution Model Petri-net BPMN for workflows, Decision Model and Notation (DMN) for business rules Don\u2019t know Queueing Theory Queueing Theory Graph Theory In-memory processing Yes Yes No Yes No No Data Persistence Event sourcing with Cassandra Relational DB via JDBC Relational Dedicated Storage (Dynomite) Cassandra N/A Process Visualization Graphviz Based on BPMN Based on BPMN Dedicated UI No Dedicated UI License Model Open-source Community Platform is open-source Pay per Case Open-source Open-source Open-source Rich UI No Yes Yes Yes No Yes","title":"Feature comparison"},{"location":"archive/getting-started/","text":"Getting started Project setup Baker is released to maven central . You can add following dependencies to your maven or sbt project to start using it: Sbt dependencies += \"com.ing.baker\" %% \"baker-recipe-dsl\" % \"2.0.3\" dependencies += \"com.ing.baker\" %% \"baker-compiler\" % \"2.0.3\" dependencies += \"com.ing.baker\" %% \"baker-runtime\" % \"2.0.3\" Maven <dependency> <groupId>com.ing.baker</groupId> <artifactId>baker-recipe-dsl_2.12</artifactId> <version>2.0.3</version> </dependency> <dependency> <groupId>com.ing.baker</groupId> <artifactId>baker-compiler_2.12</artifactId> <version>2.0.3</version> </dependency> <dependency> <groupId>com.ing.baker</groupId> <artifactId>baker-runtime_2.12</artifactId> <version>2.0.3</version> </dependency> This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need. Modules An explanation of the baker modules. Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on Akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri-net model that the runtime can execute This is the dependency graph between the modules. Continuing from here After adding the dependencies you can continue to: Familiarize yourself with the concepts . Immediately start writing your recipes .","title":"Getting started"},{"location":"archive/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"archive/getting-started/#project-setup","text":"Baker is released to maven central . You can add following dependencies to your maven or sbt project to start using it: Sbt dependencies += \"com.ing.baker\" %% \"baker-recipe-dsl\" % \"2.0.3\" dependencies += \"com.ing.baker\" %% \"baker-compiler\" % \"2.0.3\" dependencies += \"com.ing.baker\" %% \"baker-runtime\" % \"2.0.3\" Maven <dependency> <groupId>com.ing.baker</groupId> <artifactId>baker-recipe-dsl_2.12</artifactId> <version>2.0.3</version> </dependency> <dependency> <groupId>com.ing.baker</groupId> <artifactId>baker-compiler_2.12</artifactId> <version>2.0.3</version> </dependency> <dependency> <groupId>com.ing.baker</groupId> <artifactId>baker-runtime_2.12</artifactId> <version>2.0.3</version> </dependency> This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need.","title":"Project setup"},{"location":"archive/getting-started/#modules","text":"An explanation of the baker modules. Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on Akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri-net model that the runtime can execute This is the dependency graph between the modules.","title":"Modules"},{"location":"archive/getting-started/#continuing-from-here","text":"After adding the dependencies you can continue to: Familiarize yourself with the concepts . Immediately start writing your recipes .","title":"Continuing from here"},{"location":"archive/interactions/","text":"Interactions Defining You define an interaction with a java interface. An example: package com.example ; import com.ing.baker.recipe.annotations.* ; import javax.inject.Named ; public interface ValidateOrder { interface Outcome { } class Failed extends Outcome { } class Valid extends Outcome { } @FiresEvent ( oneOf = { Failed . class , Valid . class }) Outcome apply ( @recipeInstanceId String recipeInstanceId , @Named ( \"order\" ) String key ); } To be used as an interaction the interface requires an apply method with some restrictions. The method must be annotated with `@FiresEvent ALL arguments must be annotated: @Named or @RequiresIngredient are used for ingredient data that the interaction requires, the name must be specfied. @recipeInstanceId is used for injecting the process id . The output classes have the same restrictions as sensory events. Implementation Implementation is just implementing the interface. Nothing to explain here.","title":"Interactions"},{"location":"archive/interactions/#interactions","text":"","title":"Interactions"},{"location":"archive/interactions/#defining","text":"You define an interaction with a java interface. An example: package com.example ; import com.ing.baker.recipe.annotations.* ; import javax.inject.Named ; public interface ValidateOrder { interface Outcome { } class Failed extends Outcome { } class Valid extends Outcome { } @FiresEvent ( oneOf = { Failed . class , Valid . class }) Outcome apply ( @recipeInstanceId String recipeInstanceId , @Named ( \"order\" ) String key ); } To be used as an interaction the interface requires an apply method with some restrictions. The method must be annotated with `@FiresEvent ALL arguments must be annotated: @Named or @RequiresIngredient are used for ingredient data that the interaction requires, the name must be specfied. @recipeInstanceId is used for injecting the process id . The output classes have the same restrictions as sensory events.","title":"Defining"},{"location":"archive/interactions/#implementation","text":"Implementation is just implementing the interface. Nothing to explain here.","title":"Implementation"},{"location":"archive/migration-guide/","text":"Migration Guide From 1.3.x to 2.0.0 This guide only describes how to migrate your existing application. Summary: ALL persisted data from baker 1.3.x IS COMPATIBLE and can be used with 2.0.x When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Some small code refactors are necessary (see below). For a full list new features see the changelog . Downtime required for clusters with state In 2.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 1.3.x ) and bring it up again ( 2.0.0 ). A rolling deploy IS NOT tested and NOT recommended. Removed Ingredient interface com.ing.baker.recipe.javadsl.Ingredient was removed. This was a tagging interface that was not used in the project. You can remove all references to this interface in your project. One thing to note is that Ingredient extended from scala.Serializable . If you depended on this behaviour just replace Ingredient by scala.Serializable . @ProvidesIngredient removed In 1.3.x you could directly provide an ingredient from an interaction. For example: import com.ing.baker.recipe.annotations.ProvidesIngredient ; interface GetEmail { @ProvidesIngredient ( \"email\" ) String apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } This feature has been removed. Internally this was already translated to an implicitly generated event: $interactionName + Successful . Now it is required that you do this expclitly to avoid confusion. The refactor is very straight forwfard: import com.ing.baker.recipe.annotations.FiresEvent ; interface GetEmail { public class GetEmailSuccessful { public final String email ; public ExampleInteractionSuccessful ( String email ) { this . email = email ; } } @FiresEvent ( oneOf = { GetEmailSuccessful . class } ) GetEmailSuccessful apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } If you use lombok annotations you can get rid of a lot of the boiler plate by using @Value on the event class. In scala it is recommended to use case classes.","title":"Migration Guide"},{"location":"archive/migration-guide/#migration-guide","text":"","title":"Migration Guide"},{"location":"archive/migration-guide/#from-13x-to-200","text":"This guide only describes how to migrate your existing application. Summary: ALL persisted data from baker 1.3.x IS COMPATIBLE and can be used with 2.0.x When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Some small code refactors are necessary (see below). For a full list new features see the changelog .","title":"From 1.3.x to 2.0.0"},{"location":"archive/migration-guide/#downtime-required-for-clusters-with-state","text":"In 2.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 1.3.x ) and bring it up again ( 2.0.0 ). A rolling deploy IS NOT tested and NOT recommended.","title":"Downtime required for clusters with state"},{"location":"archive/migration-guide/#removed-ingredient-interface","text":"com.ing.baker.recipe.javadsl.Ingredient was removed. This was a tagging interface that was not used in the project. You can remove all references to this interface in your project. One thing to note is that Ingredient extended from scala.Serializable . If you depended on this behaviour just replace Ingredient by scala.Serializable .","title":"Removed Ingredient interface"},{"location":"archive/migration-guide/#providesingredient-removed","text":"In 1.3.x you could directly provide an ingredient from an interaction. For example: import com.ing.baker.recipe.annotations.ProvidesIngredient ; interface GetEmail { @ProvidesIngredient ( \"email\" ) String apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } This feature has been removed. Internally this was already translated to an implicitly generated event: $interactionName + Successful . Now it is required that you do this expclitly to avoid confusion. The refactor is very straight forwfard: import com.ing.baker.recipe.annotations.FiresEvent ; interface GetEmail { public class GetEmailSuccessful { public final String email ; public ExampleInteractionSuccessful ( String email ) { this . email = email ; } } @FiresEvent ( oneOf = { GetEmailSuccessful . class } ) GetEmailSuccessful apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } If you use lombok annotations you can get rid of a lot of the boiler plate by using @Value on the event class. In scala it is recommended to use case classes.","title":"@ProvidesIngredient removed"},{"location":"archive/process-execution/","text":"Process Execution Recap On the runtime page we discussed how you could initialize Baker and add your recipe to it. Lets summarize what we have done so far. Scala // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe val baker : Baker = ??? // The recipe id was given to us when we add our Recipe to Baker val recipeId : String = ??? Java // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe JBaker baker = null ; // // The recipe id was given to us when we add our Recipe to Baker String recipeId = \"...\" ; Create a process instance Given a valid recipe id we can now execute a Recipe. Or in other words we can create a process instance . Scala // Assuming you have a compiled recipe val recipe : CompiledRecipe = ??? // A unique identifier ment to distinguish this process from other process instances val recipeInstanceId = \"a-unique-process-id\" // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId , recipeInstanceId ) Java // Assuming you have a compiled recipe CompiledRecipe recipe = null ; // // A unique identifier ment to distinguish this process from other process instances String recipeInstanceId = \"a-unique-process-id\" ; // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId (), recipeInstanceId ); Providing a sensory event In our webshop example the first events that can happen are OrderPlaced , PaymentMade and CustomerInfoReceived . These are so called sensory events since they are not the result of an interaction but must be provided by the user of Baker. Scala // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) val customerInfo = CustomerInfo ( \"John\" , \"Elm. Street\" , \"johndoe@example.com\" ) val order = \"123\" ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( recipeInstanceId , CustomerInfoRecived ( customerInfo )) baker . processEvent ( recipeInstanceId , OrderPlaced ( order )) Java // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) CustomerInfo customerInfo = new CustomerInfo ( \"John\" , \"Elm. Street\" , \"johndoe@example.com\" ); String order = \"123\" ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( recipeInstanceId , new CustomerInfoReceived ( customerInfo )); baker . processEvent ( recipeInstanceId , new OrderPlaced ( order )); When receiving events Baker will check which Interactions have all the required Ingredients and Events met. It will execute those interactions. Those interactions will raise more events. For more information about the exact execution sementics see here . Correlation id Optionally you may provide a correlation id with an event. The purpose of this identifier is idempotent event delivery. When sending the same event correlation id multiple times, only the first will be processed. This can be applied to the OrderPlaced event for example. Scala val orderId = \"a unique order id\" val statusA : SensoryEventStatus = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ) val statusB : SensoryEventStatus = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ) // statusA == Received // statusB == AlreadyReceived Java String orderId = \"a unique order id\" ; SensoryEventStatus statusA = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ); SensoryEventStatus statusB = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ); // statusA == Received // statusB == AlreadyReceived Sensory event status In response to receiving a sensory event Baker returns a status code indicating how it processed it. Status Description Received The event was received normally AlreadyReceived An event with the same correlation id was already received ProcessDeleted The process instance was deleted ReceivePeriodExpired The receive period for the process instance has passed FiringLimitMet The firing limit for the event was met Incident resolving It is possible that during execution a process instance becomes blocked . This can happen either because it is directly blocked by a exception or that the retry strategy was exhuasted. At this point it is possible to resolve the blocked interaction in 2 ways. 1. Force retry For example, the retry strategy for \"SendInvoice\" was exhausted after a few hours or retrying. However, we checked and know the \"invoice\" service is up again and want to continue to process for our customer. Scala baker . retryInteraction ( recipeInstanceId , \"SendInvoice\" ) Java baker . retryInteraction ( recipeInstanceId , \"SendInvoice\" ); 2. Specify the interaction output For example, the \"ShipGoods\" backend service is not idempotent and failed with an exception. It is not retried but blocked . However, we checked and know the goods were actually shipped and want to continue the process for our customer. Scala baker . resolveInteraction ( recipeInstanceId , \"ShipGoods\" , GoodsShipped ( \"some goods\" )) Java baker . resolveInteraction ( recipeInstanceId , \"ShipGoods\" , new GoodsShipped ( \"some goods\" )); Note that the event provided SHOULD NOT include any event or ingredient renames specified for the interaction. State inquiry During runtime it is often useful to inquire on the state of a process instance. Visualize process instance state We can use the visualizer to see what Baker has done with the given events. Scala val dotRepresentation : String = baker . getVisualState ( recipeInstanceId ) Java String dotRepresentation = baker . getVisualState ( recipeInstanceId ); Did you know?! You can ask baker for a visual representation of a certain process. That way you can see which Events were provided and which Interaction were run. See the visualization page how to create a visual graph. The image shows us that the ValidateOrder Interaction is colored green which means that the Interaction has been exucuted. Baker was able to exeucte the Interaction because all required Events and Ingredients where provided. The ValidateOrder Interaction in turn produced the Valid event. We can also see that the ManufactureGoods Interaction is still purple, meaning that it has not been executed. This is correct because ManufactureGoods requires an additional event called PaymentMade . Events We can ask Baker for a list of all the events for our process. Using this list we can check if the InvoiceWasSend event was produced. Scala // Get all events that have happend for this process instance val events : Seq [ RuntimeEvent ] = baker . getEvents ( recipeInstanceId ) if ( events . exists ( _ . name == \"InvoiceWasSend\" )) // Yes the invoice was send! Java // Get all events that have happend for this process instance EventList events = baker . getEvents ( recipeInstanceId ); if ( events . hasEventOccurred ( InvoiceWasSend . class )) // Yes the invoice was send! Ingredients Sometimes it is useful to know what the ingredient values are accumulated for a process instance. For example, you might want to know the value of the trackingId . Scala // Get all ingredients that are accumulated for a process instance val ingredients : Map [ String , Value ] = baker . getIngredients ( recipeInstanceId ) val trackingId : String = ingredients ( \"trackingId\" ). as [ String ] Java // Get all ingredients that are accumulated for a process instance Map < String , Value > ingredients = baker . getIngredients ( recipeInstanceId ); String trackingId = ingredients . get ( \"trackingId\" ). as ( String . class );","title":"Process Execution"},{"location":"archive/process-execution/#process-execution","text":"","title":"Process Execution"},{"location":"archive/process-execution/#recap","text":"On the runtime page we discussed how you could initialize Baker and add your recipe to it. Lets summarize what we have done so far. Scala // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe val baker : Baker = ??? // The recipe id was given to us when we add our Recipe to Baker val recipeId : String = ??? Java // To execute a recipe you will need a Baker instance // This should be the same instance as you used to register your Recipe JBaker baker = null ; // // The recipe id was given to us when we add our Recipe to Baker String recipeId = \"...\" ;","title":"Recap"},{"location":"archive/process-execution/#create-a-process-instance","text":"Given a valid recipe id we can now execute a Recipe. Or in other words we can create a process instance . Scala // Assuming you have a compiled recipe val recipe : CompiledRecipe = ??? // A unique identifier ment to distinguish this process from other process instances val recipeInstanceId = \"a-unique-process-id\" // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId , recipeInstanceId ) Java // Assuming you have a compiled recipe CompiledRecipe recipe = null ; // // A unique identifier ment to distinguish this process from other process instances String recipeInstanceId = \"a-unique-process-id\" ; // Tell Baker that we want to create a new process for a certain recipe. baker . bake ( recipe . recipeId (), recipeInstanceId );","title":"Create a process instance"},{"location":"archive/process-execution/#providing-a-sensory-event","text":"In our webshop example the first events that can happen are OrderPlaced , PaymentMade and CustomerInfoReceived . These are so called sensory events since they are not the result of an interaction but must be provided by the user of Baker. Scala // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) val customerInfo = CustomerInfo ( \"John\" , \"Elm. Street\" , \"johndoe@example.com\" ) val order = \"123\" ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( recipeInstanceId , CustomerInfoRecived ( customerInfo )) baker . processEvent ( recipeInstanceId , OrderPlaced ( order )) Java // The CustomerInfoReceived and OrderPlaced events require some data (Ingredients) CustomerInfo customerInfo = new CustomerInfo ( \"John\" , \"Elm. Street\" , \"johndoe@example.com\" ); String order = \"123\" ; // Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events. baker . processEvent ( recipeInstanceId , new CustomerInfoReceived ( customerInfo )); baker . processEvent ( recipeInstanceId , new OrderPlaced ( order )); When receiving events Baker will check which Interactions have all the required Ingredients and Events met. It will execute those interactions. Those interactions will raise more events. For more information about the exact execution sementics see here .","title":"Providing a sensory event"},{"location":"archive/process-execution/#correlation-id","text":"Optionally you may provide a correlation id with an event. The purpose of this identifier is idempotent event delivery. When sending the same event correlation id multiple times, only the first will be processed. This can be applied to the OrderPlaced event for example. Scala val orderId = \"a unique order id\" val statusA : SensoryEventStatus = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ) val statusB : SensoryEventStatus = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ) // statusA == Received // statusB == AlreadyReceived Java String orderId = \"a unique order id\" ; SensoryEventStatus statusA = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ); SensoryEventStatus statusB = baker . processEvent ( recipeInstanceId , new OrderPlaced ( order ), orderId ); // statusA == Received // statusB == AlreadyReceived","title":"Correlation id"},{"location":"archive/process-execution/#sensory-event-status","text":"In response to receiving a sensory event Baker returns a status code indicating how it processed it. Status Description Received The event was received normally AlreadyReceived An event with the same correlation id was already received ProcessDeleted The process instance was deleted ReceivePeriodExpired The receive period for the process instance has passed FiringLimitMet The firing limit for the event was met","title":"Sensory event status"},{"location":"archive/process-execution/#incident-resolving","text":"It is possible that during execution a process instance becomes blocked . This can happen either because it is directly blocked by a exception or that the retry strategy was exhuasted. At this point it is possible to resolve the blocked interaction in 2 ways.","title":"Incident resolving"},{"location":"archive/process-execution/#1-force-retry","text":"For example, the retry strategy for \"SendInvoice\" was exhausted after a few hours or retrying. However, we checked and know the \"invoice\" service is up again and want to continue to process for our customer. Scala baker . retryInteraction ( recipeInstanceId , \"SendInvoice\" ) Java baker . retryInteraction ( recipeInstanceId , \"SendInvoice\" );","title":"1. Force retry"},{"location":"archive/process-execution/#2-specify-the-interaction-output","text":"For example, the \"ShipGoods\" backend service is not idempotent and failed with an exception. It is not retried but blocked . However, we checked and know the goods were actually shipped and want to continue the process for our customer. Scala baker . resolveInteraction ( recipeInstanceId , \"ShipGoods\" , GoodsShipped ( \"some goods\" )) Java baker . resolveInteraction ( recipeInstanceId , \"ShipGoods\" , new GoodsShipped ( \"some goods\" )); Note that the event provided SHOULD NOT include any event or ingredient renames specified for the interaction.","title":"2. Specify the interaction output"},{"location":"archive/process-execution/#state-inquiry","text":"During runtime it is often useful to inquire on the state of a process instance.","title":"State inquiry"},{"location":"archive/process-execution/#visualize-process-instance-state","text":"We can use the visualizer to see what Baker has done with the given events. Scala val dotRepresentation : String = baker . getVisualState ( recipeInstanceId ) Java String dotRepresentation = baker . getVisualState ( recipeInstanceId ); Did you know?! You can ask baker for a visual representation of a certain process. That way you can see which Events were provided and which Interaction were run. See the visualization page how to create a visual graph. The image shows us that the ValidateOrder Interaction is colored green which means that the Interaction has been exucuted. Baker was able to exeucte the Interaction because all required Events and Ingredients where provided. The ValidateOrder Interaction in turn produced the Valid event. We can also see that the ManufactureGoods Interaction is still purple, meaning that it has not been executed. This is correct because ManufactureGoods requires an additional event called PaymentMade .","title":"Visualize process instance state"},{"location":"archive/process-execution/#events","text":"We can ask Baker for a list of all the events for our process. Using this list we can check if the InvoiceWasSend event was produced. Scala // Get all events that have happend for this process instance val events : Seq [ RuntimeEvent ] = baker . getEvents ( recipeInstanceId ) if ( events . exists ( _ . name == \"InvoiceWasSend\" )) // Yes the invoice was send! Java // Get all events that have happend for this process instance EventList events = baker . getEvents ( recipeInstanceId ); if ( events . hasEventOccurred ( InvoiceWasSend . class )) // Yes the invoice was send!","title":"Events"},{"location":"archive/process-execution/#ingredients","text":"Sometimes it is useful to know what the ingredient values are accumulated for a process instance. For example, you might want to know the value of the trackingId . Scala // Get all ingredients that are accumulated for a process instance val ingredients : Map [ String , Value ] = baker . getIngredients ( recipeInstanceId ) val trackingId : String = ingredients ( \"trackingId\" ). as [ String ] Java // Get all ingredients that are accumulated for a process instance Map < String , Value > ingredients = baker . getIngredients ( recipeInstanceId ); String trackingId = ingredients . get ( \"trackingId\" ). as ( String . class );","title":"Ingredients"},{"location":"archive/recipe-dsl/","text":"Recipe DSL The recipe DSL allows you to declaritively describe your process. Let's start with the web shop recipe as an example. The complete code example can be found here . final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class , PaymentMade . class ) . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class ) . withRequiredEvents ( PaymentMade . class , ValidateOrder . Valid . class ), of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ), of ( ShipGoods . class )) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ()); Sensory events Events are simple POJO classes. For example: Scala case class CustomerInfoReceived ( customerInfo : CustomerInfo ) Java public class CustomerInfoReceived { public final CustomerInfo customerInfo ; public CustomerInfoReceived ( CustomerInfo customerInfo ) { this . customerInfo = customerInfo ; } } The field types of the POJO class must be compatible with the Baker type system. See the supported types for more information. The names of the fields are obtained using java reflection. They can be added using the .withSensoryEvents(..) method. Firing limit A firing limit is a limit on the number of times a sensory event may be received by a process instance . By default sensory events have a firing limit of 1 per process instance. This means the event will be rejected with status FiringLimitMet after the first time it is received. If you want to send an event more then once you may add it like this: . withSensoryEventsNoFiringLimit ( CustomerInfoReceived . class ) In this example the CustomerInfoReceived can now be received multiple times by a process instance. Interactions Interactions are interfaces with some requirements. See here how to define them. You can include interactions in your recipe using the static of(..) method. import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withInteractions ( of ( ValidateOrder . class ) ) There are a number of options to tailor an interaction for your recipe. Maximum interaction count By default there is no limit on the number of times an Interaction may fire. Sometimes you may want to set a limit. For example, to ensure the goods are shipped only once. . withInteractions ( of ( ShipGoods . class ). withMaximumInteractionCount ( 1 ) ) Predefining ingredients An interaction normally requires all its input ingredients to be provided from Events . Sometimes however it is useful to predefine (or hard code ) the value of an ingredient. For example: An email template An application/requester id when calling an external system This can be done by: . withInteractions ( of ( SendEmail . class ) . withPredefinedIngredient ( \"emailTemplate\" , \"Welcome to ING!\" ) ) Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call. Each time all remaining ingredients are provided, the interaction will fire. You can not predefine ALL input ingredients of an interaction. Event renames Sometimes it useful to rename an interaction event and/or its ingredients to fit better in the context of your recipe. For example, to rename the GoodsManufactured event and its ingredient. . withInteractions ( of ( ManufactureGoods . class ) . withEventTransformation ( GoodsManufactured . class , \"ManufacturingDone\" , ImmutableMap . of ( \"goods\" , \"manufacturedGoods\" ) ) ) ) Event requirements As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions. However, sometimes data requirements are not enough. For example, you might want to be sure to only send an invoice ( SendInvoice ) AFTER the goods where shipped ( GoodsShipped ). of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ) In this case the GoodsShipped event MUST happen before the interaction may execute. You can specify multiple events in a single clause. These are bundled with an AND condition, meaning ALL events in the clause are required. You can also require a single event from a number of options. of ( SendInvoice . class ) . withRequiredOneOfEvents ( EventA . class , EventB . class ) In this case the interaction may fire if either EventA OR EventB has occured. Interaction Failure strategy When an interaction throws an exception there are a number of mitigation strategies: Block interaction This is the DEFAULT strategy if no other is defined and no default strategy is defined. This option is suitable for non idempotent interactions that cannot be retried. When an exception is thrown from the interaction the interaction is blocked . This means that the interaction cannot execute again automatically. It requires manual intervening to continue the process from then on. Fire event This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( \"ValidateOrderFailed\" ) ) ) Retry with incremental backoff Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The backoff factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis -> 200 millis -> 400 millis -> ... -> 100 seconds -> 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number. Retry exhaustion It can happen that after some time, when an interaction keeps failing, that the retry is exhausted. When this happens 2 things may happen. Either the interaction becomes [blocked(#blocked-interaction). Or if you configure so, the process continues with a predefined event: .withFailureStrategy(new RetryWithIncrementalBackoffBuilder() .withFireRetryExhaustedEvent(SomeEvent.class)) Note that this event class requires an empty constructor to be present and cannot provide ingredients. Default failure strategy You can also define a default failure strategy on the recipe level. This then serves as a fallback if none is defined for an interaction. For example: final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Recipe DSL"},{"location":"archive/recipe-dsl/#recipe-dsl","text":"The recipe DSL allows you to declaritively describe your process. Let's start with the web shop recipe as an example. The complete code example can be found here . final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class , PaymentMade . class ) . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class ) . withRequiredEvents ( PaymentMade . class , ValidateOrder . Valid . class ), of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ), of ( ShipGoods . class )) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Recipe DSL"},{"location":"archive/recipe-dsl/#sensory-events","text":"Events are simple POJO classes. For example: Scala case class CustomerInfoReceived ( customerInfo : CustomerInfo ) Java public class CustomerInfoReceived { public final CustomerInfo customerInfo ; public CustomerInfoReceived ( CustomerInfo customerInfo ) { this . customerInfo = customerInfo ; } } The field types of the POJO class must be compatible with the Baker type system. See the supported types for more information. The names of the fields are obtained using java reflection. They can be added using the .withSensoryEvents(..) method.","title":"Sensory events"},{"location":"archive/recipe-dsl/#firing-limit","text":"A firing limit is a limit on the number of times a sensory event may be received by a process instance . By default sensory events have a firing limit of 1 per process instance. This means the event will be rejected with status FiringLimitMet after the first time it is received. If you want to send an event more then once you may add it like this: . withSensoryEventsNoFiringLimit ( CustomerInfoReceived . class ) In this example the CustomerInfoReceived can now be received multiple times by a process instance.","title":"Firing limit"},{"location":"archive/recipe-dsl/#interactions","text":"Interactions are interfaces with some requirements. See here how to define them. You can include interactions in your recipe using the static of(..) method. import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withInteractions ( of ( ValidateOrder . class ) ) There are a number of options to tailor an interaction for your recipe.","title":"Interactions"},{"location":"archive/recipe-dsl/#maximum-interaction-count","text":"By default there is no limit on the number of times an Interaction may fire. Sometimes you may want to set a limit. For example, to ensure the goods are shipped only once. . withInteractions ( of ( ShipGoods . class ). withMaximumInteractionCount ( 1 ) )","title":"Maximum interaction count"},{"location":"archive/recipe-dsl/#predefining-ingredients","text":"An interaction normally requires all its input ingredients to be provided from Events . Sometimes however it is useful to predefine (or hard code ) the value of an ingredient. For example: An email template An application/requester id when calling an external system This can be done by: . withInteractions ( of ( SendEmail . class ) . withPredefinedIngredient ( \"emailTemplate\" , \"Welcome to ING!\" ) ) Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call. Each time all remaining ingredients are provided, the interaction will fire. You can not predefine ALL input ingredients of an interaction.","title":"Predefining ingredients"},{"location":"archive/recipe-dsl/#event-renames","text":"Sometimes it useful to rename an interaction event and/or its ingredients to fit better in the context of your recipe. For example, to rename the GoodsManufactured event and its ingredient. . withInteractions ( of ( ManufactureGoods . class ) . withEventTransformation ( GoodsManufactured . class , \"ManufacturingDone\" , ImmutableMap . of ( \"goods\" , \"manufacturedGoods\" ) ) ) )","title":"Event renames"},{"location":"archive/recipe-dsl/#event-requirements","text":"As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions. However, sometimes data requirements are not enough. For example, you might want to be sure to only send an invoice ( SendInvoice ) AFTER the goods where shipped ( GoodsShipped ). of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ) In this case the GoodsShipped event MUST happen before the interaction may execute. You can specify multiple events in a single clause. These are bundled with an AND condition, meaning ALL events in the clause are required. You can also require a single event from a number of options. of ( SendInvoice . class ) . withRequiredOneOfEvents ( EventA . class , EventB . class ) In this case the interaction may fire if either EventA OR EventB has occured.","title":"Event requirements"},{"location":"archive/recipe-dsl/#interaction-failure-strategy","text":"When an interaction throws an exception there are a number of mitigation strategies:","title":"Interaction Failure strategy"},{"location":"archive/recipe-dsl/#block-interaction","text":"This is the DEFAULT strategy if no other is defined and no default strategy is defined. This option is suitable for non idempotent interactions that cannot be retried. When an exception is thrown from the interaction the interaction is blocked . This means that the interaction cannot execute again automatically. It requires manual intervening to continue the process from then on.","title":"Block interaction"},{"location":"archive/recipe-dsl/#fire-event","text":"This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( \"ValidateOrderFailed\" ) ) )","title":"Fire event"},{"location":"archive/recipe-dsl/#retry-with-incremental-backoff","text":"Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The backoff factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis -> 200 millis -> 400 millis -> ... -> 100 seconds -> 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number. Retry exhaustion It can happen that after some time, when an interaction keeps failing, that the retry is exhausted. When this happens 2 things may happen. Either the interaction becomes [blocked(#blocked-interaction). Or if you configure so, the process continues with a predefined event: .withFailureStrategy(new RetryWithIncrementalBackoffBuilder() .withFireRetryExhaustedEvent(SomeEvent.class)) Note that this event class requires an empty constructor to be present and cannot provide ingredients.","title":"Retry with incremental backoff"},{"location":"archive/recipe-dsl/#default-failure-strategy","text":"You can also define a default failure strategy on the recipe level. This then serves as a fallback if none is defined for an interaction. For example: final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Default failure strategy"},{"location":"archive/recipe-visualization/","text":"Recipe Visualization Here we explain how to create a visual representation of your recipe like this one Generate a .dot representation Baker can turn a recipe into a .dot representation. .dot is a notation for representing graphs. Scala val recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ) println ( recipe . getRecipeVisualization ) Java final CompiledRecipe recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ); System . out . println ( recipe . getRecipeVisualization ()); This should output something like this: digraph d { A [label=\"Hello\"] B [label=\"World\"] C [label=\"Everyone\"] A -> { B C } } Visualize Once you have a .dot representation there are a few methods to visualize this. Online You can copy the .dot string and use webgraphviz.com . Local To generate an image locally you require the graphviz tool. See graphviz.org on how to install it. On mac you can use brew . brew install graphviz Once installed the dot command can be used to create an SVG by running: dot -v -Tsvg -O graph.dot In application Alternatively you can use graphviz-java to generate the SVG in your code: Scala import guru.nidi.graphviz.engine. { Format , Graphviz } import guru.nidi.graphviz.parse.Parser val graph = Parser . read ( recipe . getRecipeVisualization ) Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString Java import guru.nidi.graphviz.engine.Format ; import guru.nidi.graphviz.engine.Graphviz ; import guru.nidi.graphviz.parse.Parser ; import guru.nidi.graphviz.model.MutableGraph ; MutableGraph graph = Parser . read ( recipe . getRecipeVisualization ); Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString ; Style customization It is possible to define a custom visual style for your recipes. To do so you need to add some configuration in your application.conf : baker.visualization { style = \"custom\" styles.custom = { // place your style attributes here } } Please see the default theme in the reference.conf as an example. For an overview on what is possible to configure check out the graphviz documentation. It is not possible to alter the shape attribute, it is hard coded (fixed) for all elements in the graph. This is done to garuantee a common visual language for all recipes.","title":"Recipe Visualization"},{"location":"archive/recipe-visualization/#recipe-visualization","text":"Here we explain how to create a visual representation of your recipe like this one","title":"Recipe Visualization"},{"location":"archive/recipe-visualization/#generate-a-dot-representation","text":"Baker can turn a recipe into a .dot representation. .dot is a notation for representing graphs. Scala val recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ) println ( recipe . getRecipeVisualization ) Java final CompiledRecipe recipe = RecipeCompiler . compileRecipe ( Examples . webshop . webShopRecipe ); System . out . println ( recipe . getRecipeVisualization ()); This should output something like this: digraph d { A [label=\"Hello\"] B [label=\"World\"] C [label=\"Everyone\"] A -> { B C } }","title":"Generate a .dot representation"},{"location":"archive/recipe-visualization/#visualize","text":"Once you have a .dot representation there are a few methods to visualize this.","title":"Visualize"},{"location":"archive/recipe-visualization/#online","text":"You can copy the .dot string and use webgraphviz.com .","title":"Online"},{"location":"archive/recipe-visualization/#local","text":"To generate an image locally you require the graphviz tool. See graphviz.org on how to install it. On mac you can use brew . brew install graphviz Once installed the dot command can be used to create an SVG by running: dot -v -Tsvg -O graph.dot","title":"Local"},{"location":"archive/recipe-visualization/#in-application","text":"Alternatively you can use graphviz-java to generate the SVG in your code: Scala import guru.nidi.graphviz.engine. { Format , Graphviz } import guru.nidi.graphviz.parse.Parser val graph = Parser . read ( recipe . getRecipeVisualization ) Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString Java import guru.nidi.graphviz.engine.Format ; import guru.nidi.graphviz.engine.Graphviz ; import guru.nidi.graphviz.parse.Parser ; import guru.nidi.graphviz.model.MutableGraph ; MutableGraph graph = Parser . read ( recipe . getRecipeVisualization ); Graphviz . fromGraph ( graph ). render ( Format . SVG ). toString ;","title":"In application"},{"location":"archive/recipe-visualization/#style-customization","text":"It is possible to define a custom visual style for your recipes. To do so you need to add some configuration in your application.conf : baker.visualization { style = \"custom\" styles.custom = { // place your style attributes here } } Please see the default theme in the reference.conf as an example. For an overview on what is possible to configure check out the graphviz documentation. It is not possible to alter the shape attribute, it is hard coded (fixed) for all elements in the graph. This is done to garuantee a common visual language for all recipes.","title":"Style customization"},{"location":"archive/split-brain-resolver/","text":"Split Brain Resolver Description Note: This feature is applicable to clustered baker configuration. If your Baker application is using local actors, thus not using Akka cluster, a Split Brain Resolver is not needed. Baker library, when configured to be a cluster, runs in an Akka cluster to distribute the baker processes over multiple nodes. Running a cluster with multiple nodes with shared state has some difficulties to tackle in some network failure scenarios, like network partitions. When there's a network partition in a cluster, the nodes at the different sides of the partition cannot receive messages from each other and eventually diverge their states unless it is a network hick-up. When this happens, you need a mechanism to prevent state inconsistency, i.e. by stopping nodes at one side of the partition, so the nodes at the surviving side still run with consistent states. A Split Brain Resolver algorithm for Akka prevents inconsistent states during network partitions, or huge network delays, or non-responding cluster members. Baker Split Brain Resolver is a general purpose implementation for Akka which could be configured for a Baker cluster as well as for another Akka cluster without bBker. Strategies The current version of the Split Brain Resolver algorithm supports only the Majority strategy which makes the majority of the nodes survive and downs (terminates) the nodes at the minority side of the network partition. In case of the number of nodes on each side of the network partition are equal, the side with the oldest Akka node survives. By deciding to down one side, you do not end up with twi Akka clusters during the network partition. There could be other strategies implemented later, for now the Majority strategy works for most of the use cases. You can read about other possible strategies supported by the commercial Lightbend Split Brain Resolver here . Majority strategy is configured by default, so you do not need extra configuration for this. How to use In order to use Baker SplitBrainResolver , first of all, you need to add baker-split-brain-resolver dependency to your project. See example below: Sbt libraryDependencies += \"com.ing.baker\" %% \"baker-split-brain-resolver\" % \"2.0.3\" Maven <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-split-brain-resolver_2.12 </artifactId> <version> 2.0.3 </version> </dependency> Then the algorithm needs to be configured as the Akka downing provider and the stable-after config needs to set to some duration depending on your cluster size. stable-after config is needed to decide on how quickly to react on the Akka cluster state changes. Very short durations may allow quicker 'downing' decisions for unreachable nodes, but may also cause to down some nodes unnecessarily too early. Please see the suggested values for this in the documentation of the commercial Lightbend Split Brain Resolver. One other Akka cluster configuration suggested keep in sync with stable-after is the akka.cluster.down-removal-margin config. The suggested values and more information on this config can be found in the Cluster Singleton and Cluster Sharding section of the commercial Lightbend Split Brain Resolver. Example config for a Baker cluster having less than 10 nodes is the following: akka.cluster.down-removal-margin = 7 seconds akka.cluster.downing-provider-class = com.ing.baker.runtime.core.actor.downing.SplitBrainResolver baker-split-brain-resolver { stable-after = 7 seconds }","title":"Split Brain Resolver"},{"location":"archive/split-brain-resolver/#split-brain-resolver","text":"","title":"Split Brain Resolver"},{"location":"archive/split-brain-resolver/#description","text":"Note: This feature is applicable to clustered baker configuration. If your Baker application is using local actors, thus not using Akka cluster, a Split Brain Resolver is not needed. Baker library, when configured to be a cluster, runs in an Akka cluster to distribute the baker processes over multiple nodes. Running a cluster with multiple nodes with shared state has some difficulties to tackle in some network failure scenarios, like network partitions. When there's a network partition in a cluster, the nodes at the different sides of the partition cannot receive messages from each other and eventually diverge their states unless it is a network hick-up. When this happens, you need a mechanism to prevent state inconsistency, i.e. by stopping nodes at one side of the partition, so the nodes at the surviving side still run with consistent states. A Split Brain Resolver algorithm for Akka prevents inconsistent states during network partitions, or huge network delays, or non-responding cluster members. Baker Split Brain Resolver is a general purpose implementation for Akka which could be configured for a Baker cluster as well as for another Akka cluster without bBker.","title":"Description"},{"location":"archive/split-brain-resolver/#strategies","text":"The current version of the Split Brain Resolver algorithm supports only the Majority strategy which makes the majority of the nodes survive and downs (terminates) the nodes at the minority side of the network partition. In case of the number of nodes on each side of the network partition are equal, the side with the oldest Akka node survives. By deciding to down one side, you do not end up with twi Akka clusters during the network partition. There could be other strategies implemented later, for now the Majority strategy works for most of the use cases. You can read about other possible strategies supported by the commercial Lightbend Split Brain Resolver here . Majority strategy is configured by default, so you do not need extra configuration for this.","title":"Strategies"},{"location":"archive/split-brain-resolver/#how-to-use","text":"In order to use Baker SplitBrainResolver , first of all, you need to add baker-split-brain-resolver dependency to your project. See example below: Sbt libraryDependencies += \"com.ing.baker\" %% \"baker-split-brain-resolver\" % \"2.0.3\" Maven <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-split-brain-resolver_2.12 </artifactId> <version> 2.0.3 </version> </dependency> Then the algorithm needs to be configured as the Akka downing provider and the stable-after config needs to set to some duration depending on your cluster size. stable-after config is needed to decide on how quickly to react on the Akka cluster state changes. Very short durations may allow quicker 'downing' decisions for unreachable nodes, but may also cause to down some nodes unnecessarily too early. Please see the suggested values for this in the documentation of the commercial Lightbend Split Brain Resolver. One other Akka cluster configuration suggested keep in sync with stable-after is the akka.cluster.down-removal-margin config. The suggested values and more information on this config can be found in the Cluster Singleton and Cluster Sharding section of the commercial Lightbend Split Brain Resolver. Example config for a Baker cluster having less than 10 nodes is the following: akka.cluster.down-removal-margin = 7 seconds akka.cluster.downing-provider-class = com.ing.baker.runtime.core.actor.downing.SplitBrainResolver baker-split-brain-resolver { stable-after = 7 seconds }","title":"How to use"},{"location":"archive/type-system/","text":"Type system The purpose of the type system is express the form of ingredients in baker. Why not use the java type system? To garuantee that all data can be read back from persistent storage. This is for the benefit of being able to write generic analysis/data-mining tools on the persisted events. To run Baker As A Service, receiving new recipes at runtime. Unless opting for OSGi or similar, you cannot load new class definitions. This makes it very impractical or impossible to depend on java classes. The main concepts in this type system are Types and Values . An important difference from type systems in programming languages is that Values do not have an explicit inherint type associated with them. You can argue whether you can call this a type system at all. Perhaps a schema system is more accurate. Types Primitives Type Java parallel Description Bool boolean single bit, true or false , 1 or 0 Char char Unsigned 16 bit integer Byte byte Signed 8 bit integer Int16 short Signed 16 bit integer Int32 int Signed 32 bit integer Int64 long Signed 64 bit integer IntBig BigInteger Integer of arbitrary size Float32 float Signed 32 bit floating point Float64 double Signed 64 bit floating point FloatBig BigDecimal Floating point of arbitrary size Date long A UTC date in the ISO-8601 calendar system with millisecond precision ByteArray Array<Byte> Byte array, often used for binary data CharArray String Character array, or commmonly called String Structured types Type Java parallel Description ListType<T> java.util.List<T> A list of values, all of the same type OptionType<T> java.util.Optional<T> Matches against T or null EnumType enum class A set of predifined options (strings) RecordType POJO class A record with a specific set of fields MapType<T> java.util.Map<String, T> A record with arbitrary fields, all of the same type Values Values are pure data without any direct associated type. These very closely match the JSON data format. Value Description NullValue Analogues to null , Optional.empty , None , etc ... PrimitiveValue Wrapper for for: - A Java primitive (or boxed variant) - java.lang.String - java.math.BigInteger - java.math.BigDecimal - scala.math.BigInt - Array<Byte> ListValue A list of values RecordValue A set of String -> Value pairs Interoptability with java types Because it is impractical to directly work with the baker types in java/scala code there is conversion system. Default supported types java primitives and their boxed variants Enum types java.util.List java.util.Set java.util.Map java.math.BigInt java.math.BigDecimal java.util.Optional POJO classes scala primitives and their boxed variants case classes scala.collection.immutable.List scala.collection.immutable.Set scala.collection.immutable.Map BigInt BigDecimal scala.Option Registering a custom type adapter All default type adapters are registered in the reference.conf of the baker-types module. You can add your custom type adapter by registering it in a reference.conf . baker.types { \"com.example.MyCustomType\" = \"com.example.MyCustomTypeAdpater\" } For an example how to implement an adapter see here","title":"Type system"},{"location":"archive/type-system/#type-system","text":"The purpose of the type system is express the form of ingredients in baker.","title":"Type system"},{"location":"archive/type-system/#why-not-use-the-java-type-system","text":"To garuantee that all data can be read back from persistent storage. This is for the benefit of being able to write generic analysis/data-mining tools on the persisted events. To run Baker As A Service, receiving new recipes at runtime. Unless opting for OSGi or similar, you cannot load new class definitions. This makes it very impractical or impossible to depend on java classes. The main concepts in this type system are Types and Values . An important difference from type systems in programming languages is that Values do not have an explicit inherint type associated with them. You can argue whether you can call this a type system at all. Perhaps a schema system is more accurate.","title":"Why not use the java type system?"},{"location":"archive/type-system/#types","text":"","title":"Types"},{"location":"archive/type-system/#primitives","text":"Type Java parallel Description Bool boolean single bit, true or false , 1 or 0 Char char Unsigned 16 bit integer Byte byte Signed 8 bit integer Int16 short Signed 16 bit integer Int32 int Signed 32 bit integer Int64 long Signed 64 bit integer IntBig BigInteger Integer of arbitrary size Float32 float Signed 32 bit floating point Float64 double Signed 64 bit floating point FloatBig BigDecimal Floating point of arbitrary size Date long A UTC date in the ISO-8601 calendar system with millisecond precision ByteArray Array<Byte> Byte array, often used for binary data CharArray String Character array, or commmonly called String","title":"Primitives"},{"location":"archive/type-system/#structured-types","text":"Type Java parallel Description ListType<T> java.util.List<T> A list of values, all of the same type OptionType<T> java.util.Optional<T> Matches against T or null EnumType enum class A set of predifined options (strings) RecordType POJO class A record with a specific set of fields MapType<T> java.util.Map<String, T> A record with arbitrary fields, all of the same type","title":"Structured types"},{"location":"archive/type-system/#values","text":"Values are pure data without any direct associated type. These very closely match the JSON data format. Value Description NullValue Analogues to null , Optional.empty , None , etc ... PrimitiveValue Wrapper for for: - A Java primitive (or boxed variant) - java.lang.String - java.math.BigInteger - java.math.BigDecimal - scala.math.BigInt - Array<Byte> ListValue A list of values RecordValue A set of String -> Value pairs","title":"Values"},{"location":"archive/type-system/#interoptability-with-java-types","text":"Because it is impractical to directly work with the baker types in java/scala code there is conversion system.","title":"Interoptability with java types"},{"location":"archive/type-system/#default-supported-types","text":"","title":"Default supported types"},{"location":"archive/type-system/#java","text":"primitives and their boxed variants Enum types java.util.List java.util.Set java.util.Map java.math.BigInt java.math.BigDecimal java.util.Optional POJO classes","title":"java"},{"location":"archive/type-system/#scala","text":"primitives and their boxed variants case classes scala.collection.immutable.List scala.collection.immutable.Set scala.collection.immutable.Map BigInt BigDecimal scala.Option","title":"scala"},{"location":"archive/type-system/#registering-a-custom-type-adapter","text":"All default type adapters are registered in the reference.conf of the baker-types module. You can add your custom type adapter by registering it in a reference.conf . baker.types { \"com.example.MyCustomType\" = \"com.example.MyCustomTypeAdpater\" } For an example how to implement an adapter see here","title":"Registering a custom type adapter"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/","text":"Declare, verify and execute microservices-based process flows with Baker Scale By the Bay 2017, San Francisco Nikola Kasev | ING Bank Global Financial Institution in Over 40 Countries Software Company with a Banking License Microservices Architecture Our Challenge Interact with 12 Different Systems A Flow of 27 Steps From 2 minutes to 6 hours Afraid to Change the Application Code Functionality Breaks Unexpectedly Slow Time to Market How to Turn This Around? Simplify Domain Specific Language for Orchestration Flows Declarative Easy to Change Recipes Interactions Ingredients Events Communicate Visualize your code Non-IT understand as well Reason About Comfortably Let's Cook Some Cr\u00eapes! Good to Know Short-lived vs. long-running flows State is taken care of: Cassandra for persistent storage Ingredients encrypted by default State recovered automatically When failure occurs: Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Ownerhip Register Ownership n/a https://github.com/ing-bank/baker Why Petri net? ^3 Design-time val registerIndividual = Interaction ( name = \"RegisterIndividual\" , inputIngredients = Seq ( name , address ), output = Seq ( registerIndividualSuccessful , registerIndividualFailed ) ) val recipe = Recipe ( \"OpenAccountRecipe\" ) . withInteractions ( assignAccount , getAccount , registerIndividual ) val recipe = Recipe ( \"OpenAccountRecipe\" ) . withInteractions ( assignAccount , getAccount . withRequiredEvent ( termsAndConditionsAccepted ), registerIndividual ) . withSensoryEvents ( termsAndConditionsAccepted , individualInformationSubmitted ) Run-time //for each process instance, bake the recipe baker . bake ( recipeInstanceId ); //notify Baker when events occur baker . processEvent ( recipeInstanceId , individualInformationSubmitted . instance ( name , address )); baker . processEvent ( recipeInstanceId , termsAndConditionsAccepted . instance ()); //retrieve ingredients stored in the accumulated state assert ( baker . getIngredients ( recipeInstanceId ). get ( \"customerId\" ). equals ( customerId )); assert ( baker . getIngredients ( recipeInstanceId ). get ( \"iban\" ). equals ( iban )); //retrieve all events that have occurred baker . events ( recipeInstanceId ) val groceriesDone = new Event(\"GroceriesDone\", Seq(milk, eggs, flour, butter, creme), Some(1)) val mixFirstThree = Interaction( name = \"MixFirstThree\", inputIngredients = Seq(milk, eggs, flour), output = Seq(batterMixed) ) val mixFirstThreeImpl = mixFirstThree implement { (milk: String, eggs: String, flour: String) => println(s\"mixing $milk, $eggs, and $flour\") batterMixed.instance(\"batter\") } I love cooking food and for the rest of the talk I'll be using examples from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#declare-verify-and-execute-microservices-based-process-flows-with-baker","text":"","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#scale-by-the-bay-2017-san-francisco","text":"","title":"Scale By the Bay 2017, San Francisco"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#nikola-kasev-ing-bank","text":"","title":"Nikola Kasev | ING Bank"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#global-financial-institution-in-over-40-countries","text":"","title":"Global Financial Institution in Over 40 Countries"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#software-company-with-a-banking-license","text":"","title":"Software Company with a Banking License"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#microservices-architecture","text":"","title":"Microservices Architecture"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#our-challenge","text":"","title":"Our Challenge"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#interact-with-12-different-systems","text":"","title":"Interact with 12 Different Systems"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#a-flow-of-27-steps","text":"","title":"A Flow of 27 Steps"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#from-2-minutes-to-6-hours","text":"","title":"From 2 minutes to 6 hours"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#afraid-to-change-the-application-code","text":"","title":"Afraid to Change the Application Code"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#functionality-breaks-unexpectedly","text":"","title":"Functionality Breaks Unexpectedly"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#slow-time-to-market","text":"","title":"Slow Time to Market"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#how-to-turn-this-around","text":"","title":"How to Turn This Around?"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#simplify","text":"","title":"Simplify"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#domain-specific-language-for-orchestration-flows","text":"","title":"Domain Specific Language for Orchestration Flows"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#declarative","text":"","title":"Declarative"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#easy-to-change","text":"","title":"Easy to Change"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#recipes","text":"","title":"Recipes"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#interactions","text":"","title":"Interactions"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#ingredients","text":"","title":"Ingredients"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#events","text":"","title":"Events"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#communicate","text":"","title":"Communicate"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#visualize-your-code","text":"","title":"Visualize your code"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#non-it-understand-as-well","text":"","title":"Non-IT understand as well"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#reason-about-comfortably","text":"","title":"Reason About Comfortably"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#lets-cook-some-crepes","text":"","title":"Let's Cook Some Cr\u00eapes!"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#good-to-know","text":"","title":"Good to Know"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#short-lived-vs-long-running-flows","text":"","title":"Short-lived vs. long-running flows"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#state-is-taken-care-of","text":"Cassandra for persistent storage Ingredients encrypted by default State recovered automatically","title":"State is taken care of:"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#when-failure-occurs","text":"Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Ownerhip Register Ownership n/a","title":"When failure occurs:"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#httpsgithubcoming-bankbaker","text":"","title":"https://github.com/ing-bank/baker"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#why-petri-net3","text":"","title":"Why Petri net?^3"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#design-time","text":"val registerIndividual = Interaction ( name = \"RegisterIndividual\" , inputIngredients = Seq ( name , address ), output = Seq ( registerIndividualSuccessful , registerIndividualFailed ) ) val recipe = Recipe ( \"OpenAccountRecipe\" ) . withInteractions ( assignAccount , getAccount , registerIndividual ) val recipe = Recipe ( \"OpenAccountRecipe\" ) . withInteractions ( assignAccount , getAccount . withRequiredEvent ( termsAndConditionsAccepted ), registerIndividual ) . withSensoryEvents ( termsAndConditionsAccepted , individualInformationSubmitted )","title":"Design-time"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#run-time","text":"//for each process instance, bake the recipe baker . bake ( recipeInstanceId ); //notify Baker when events occur baker . processEvent ( recipeInstanceId , individualInformationSubmitted . instance ( name , address )); baker . processEvent ( recipeInstanceId , termsAndConditionsAccepted . instance ()); //retrieve ingredients stored in the accumulated state assert ( baker . getIngredients ( recipeInstanceId ). get ( \"customerId\" ). equals ( customerId )); assert ( baker . getIngredients ( recipeInstanceId ). get ( \"iban\" ). equals ( iban )); //retrieve all events that have occurred baker . events ( recipeInstanceId ) val groceriesDone = new Event(\"GroceriesDone\", Seq(milk, eggs, flour, butter, creme), Some(1)) val mixFirstThree = Interaction( name = \"MixFirstThree\", inputIngredients = Seq(milk, eggs, flour), output = Seq(batterMixed) ) val mixFirstThreeImpl = mixFirstThree implement { (milk: String, eggs: String, flour: String) => println(s\"mixing $milk, $eggs, and $flour\") batterMixed.instance(\"batter\") } I love cooking food and for the rest of the talk I'll be using examples from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"Run-time"},{"location":"archive/presentations/baker-pitch/","text":"[fit] Orchestration Logic is Hard to Change Baker is a Java Library Declare the Logic Like a Recipe Visualize the Logic Don't Worry About Retries and State Added Value Reuse of Code -> Rapid Time to Market Visualization -> Business and IT Speak the Same Language Data-driven Refactoring -> Robust Software Under the Hood DSL for Recipes Actor Model with Petri nets Event-Driven Architecture ```java, [.highlight: 3,4,6] return new Recipe(\"DemoAtTwitterHQ\"). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); } --- ```java //notify Baker when events occur baker.processEvent(recipeInstanceId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(recipeInstanceId, new SensoryEvents.TermsAndConditionsAccepted());","title":"[fit] Orchestration Logic is Hard to Change"},{"location":"archive/presentations/baker-pitch/#fit-orchestration-logic-is-hard-to-change","text":"","title":"[fit] Orchestration Logic is Hard to Change"},{"location":"archive/presentations/baker-pitch/#baker-is-a-java-library","text":"","title":"Baker is a Java Library"},{"location":"archive/presentations/baker-pitch/#declare-the-logic-like-a-recipe","text":"","title":"Declare the Logic Like a Recipe"},{"location":"archive/presentations/baker-pitch/#visualize-the-logic","text":"","title":"Visualize the Logic"},{"location":"archive/presentations/baker-pitch/#dont-worry-about-retries-and-state","text":"","title":"Don't Worry About Retries and State"},{"location":"archive/presentations/baker-pitch/#added-value","text":"","title":"Added Value"},{"location":"archive/presentations/baker-pitch/#reuse-of-code-rapid-time-to-market","text":"","title":"Reuse of Code -&gt; Rapid Time to Market"},{"location":"archive/presentations/baker-pitch/#visualization-business-and-it-speak-the-same-language","text":"","title":"Visualization -&gt; Business and IT Speak the Same Language"},{"location":"archive/presentations/baker-pitch/#data-driven-refactoring-robust-software","text":"","title":"Data-driven Refactoring -&gt; Robust Software"},{"location":"archive/presentations/baker-pitch/#under-the-hood","text":"","title":"Under the Hood"},{"location":"archive/presentations/baker-pitch/#dsl-for-recipes","text":"","title":"DSL for Recipes"},{"location":"archive/presentations/baker-pitch/#actor-model-with-petri-nets","text":"","title":"Actor Model with Petri nets"},{"location":"archive/presentations/baker-pitch/#event-driven-architecture","text":"```java, [.highlight: 3,4,6] return new Recipe(\"DemoAtTwitterHQ\"). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); } --- ```java //notify Baker when events occur baker.processEvent(recipeInstanceId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(recipeInstanceId, new SensoryEvents.TermsAndConditionsAccepted());","title":"Event-Driven Architecture"},{"location":"archive/presentations/muCon-London-7-Nov-2017/","text":"Declare, verify and execute microservices-based process flows with Baker http://github.com/nikolakasev | ING Symptoms of a Failing Restaurant Symptoms of a Failing (Microservices) Architecture Afraid to change the application code Functionality breaks unexpectedly Slow time to market How to turn this around? Simplify Domain Specific Language for orchestration flows Declarative Easy to change Reuse Recipes Interactions Ingredients Events Communicate Visualize your code Non-IT understand as well Reason About Comfortably Design-time ```[.highlight: 1,6,7] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @recipeInstanceId String recipeInstanceId, @RequiresIngredient(\"name\") String name, @RequiresIngredient(\"address\") String address ); } --- ```[.highlight: 2,3] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @recipeInstanceId String recipeInstanceId, @RequiresIngredient(\"name\") String name, @RequiresIngredient(\"address\") String address ); } ```java, [.highlight: 3-6] public Recipe get(){ return new Recipe(\"MuConf2017Demo\"). withInteractions( of(AssignAccount.class), of(GetAccount.class), of(RegisterIndividual.class)); } --- ![fit](recipe-no-sensory.png) --- ```java, [.highlight: 5, 7-9] return new Recipe(\"MuConf2017Demo\"). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); } Run-time ```java, [.highlight: 2,4,5,8,9,13] //for each process instance, bake the recipe baker.bake(recipeInstanceId); //notify Baker when events occur baker.processEvent(recipeInstanceId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(recipeInstanceId, new SensoryEvents.TermsAndConditionsAccepted()); //retrieve ingredients stored in the accumulated state assert(baker.getIngredients(recipeInstanceId).get(\"customerId\").equals(customerId)); assert(baker.getIngredients(recipeInstanceId).get(\"iban\").equals(iban)); //retrieve all events that have occurred Set occurredEvents = new HashSet<>( baker.getEvents(recipeInstanceId).getEventNameList() ); ``` Under the Hood Why Scala? Best fit for developing DSLs ^1 on the JVM Compile-time recipe validation Type safety Why Akka? Event Sourcing ^2 (events can be replayed) Persistent actors (with Cassandra) Distributed actors across machines (with cluster sharding) Why Petri net? ^3 Best Practices Short-lived vs. long-running flows State is taken care of: Cassandra for persistent storage Ingredients encrypted by default State recovered automatically Run Baker inside of your API \"Smart endpoints and dumb pipes\" When failure occurs: Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Product Owner Register Product Owner n/a https://github.com/ing-bank/baker Speed of change matters to anyone building software. Many engineering teams have identified Microservices as an important component of this architectural approach to designing more flexible systems that can meet the needs of their fast changing businesses. Applying this approach however, is hard. And ideas and practices are still very much evolving. To help with that, we've launched muCon - a conference to learn about emerging technologies and approaches, share challenges and evolve practices and ideas. Their applications are built on top of microservices. If there careful enough their application serve bad meals. If we are building microservices or a monolith or any type of service in general we are serving business logic to our clients. So no matter what we can not escape the architectural discussion. If we are not careful of how we architect our applications we end up serving bad meals. I love cooking food and for the rest of the talk I'll be using analogies from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#declare-verify-and-execute-microservices-based-process-flows-with-baker","text":"","title":"Declare, verify and execute microservices-based process flows with Baker"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#httpgithubcomnikolakasev-ing","text":"","title":"http://github.com/nikolakasev | ING"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#symptoms-of-a-failing-restaurant","text":"","title":"Symptoms of a Failing Restaurant"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#symptoms-of-a-failing-microservices-architecture","text":"","title":"Symptoms of a Failing (Microservices) Architecture"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#afraid-to-change-the-application-code","text":"","title":"Afraid to change the application code"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#functionality-breaks-unexpectedly","text":"","title":"Functionality breaks unexpectedly"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#slow-time-to-market","text":"","title":"Slow time to market"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#how-to-turn-this-around","text":"","title":"How to turn this around?"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#simplify","text":"","title":"Simplify"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#domain-specific-language-for-orchestration-flows","text":"","title":"Domain Specific Language for orchestration flows"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#declarative","text":"","title":"Declarative"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#easy-to-change","text":"","title":"Easy to change"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#reuse","text":"","title":"Reuse"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#recipes","text":"","title":"Recipes"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#interactions","text":"","title":"Interactions"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#ingredients","text":"","title":"Ingredients"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#events","text":"","title":"Events"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#communicate","text":"","title":"Communicate"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#visualize-your-code","text":"","title":"Visualize your code"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#non-it-understand-as-well","text":"","title":"Non-IT understand as well"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#reason-about-comfortably","text":"","title":"Reason About Comfortably"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#design-time","text":"```[.highlight: 1,6,7] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @recipeInstanceId String recipeInstanceId, @RequiresIngredient(\"name\") String name, @RequiresIngredient(\"address\") String address ); } --- ```[.highlight: 2,3] public interface RegisterIndividual extends Interaction { @FiresEvent(oneOf = {RegisterIndividualSuccessful.class, RegisterIndividualFailed.class}) RegisterIndividualOutcome apply( @recipeInstanceId String recipeInstanceId, @RequiresIngredient(\"name\") String name, @RequiresIngredient(\"address\") String address ); } ```java, [.highlight: 3-6] public Recipe get(){ return new Recipe(\"MuConf2017Demo\"). withInteractions( of(AssignAccount.class), of(GetAccount.class), of(RegisterIndividual.class)); } --- ![fit](recipe-no-sensory.png) --- ```java, [.highlight: 5, 7-9] return new Recipe(\"MuConf2017Demo\"). withInteractions( of(AssignAccount.class), of(GetAccount.class). withRequiredEvent(TermsAndConditionsAccepted.class), of(RegisterIndividual.class)). withSensoryEvents( TermsAndConditionsAccepted.class, IndividualInformationSubmitted.class); }","title":"Design-time"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#run-time","text":"```java, [.highlight: 2,4,5,8,9,13] //for each process instance, bake the recipe baker.bake(recipeInstanceId); //notify Baker when events occur baker.processEvent(recipeInstanceId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(recipeInstanceId, new SensoryEvents.TermsAndConditionsAccepted()); //retrieve ingredients stored in the accumulated state assert(baker.getIngredients(recipeInstanceId).get(\"customerId\").equals(customerId)); assert(baker.getIngredients(recipeInstanceId).get(\"iban\").equals(iban)); //retrieve all events that have occurred Set occurredEvents = new HashSet<>( baker.getEvents(recipeInstanceId).getEventNameList() ); ```","title":"Run-time"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#under-the-hood","text":"","title":"Under the Hood"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#why-scala","text":"Best fit for developing DSLs ^1 on the JVM Compile-time recipe validation Type safety","title":"Why Scala?"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#why-akka","text":"Event Sourcing ^2 (events can be replayed) Persistent actors (with Cassandra) Distributed actors across machines (with cluster sharding)","title":"Why Akka?"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#why-petri-net3","text":"","title":"Why Petri net?^3"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#best-practices","text":"","title":"Best Practices"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#short-lived-vs-long-running-flows","text":"","title":"Short-lived vs. long-running flows"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#state-is-taken-care-of","text":"Cassandra for persistent storage Ingredients encrypted by default State recovered automatically","title":"State is taken care of:"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#run-baker-inside-of-your-api","text":"","title":"Run Baker inside of your API"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#smart-endpoints-and-dumb-pipes","text":"","title":"\"Smart endpoints and dumb pipes\""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#when-failure-occurs","text":"Baker retries technical failures with exponential backoff Works well with idempotent services Deal with functional failure in your recipe Baker Capability Matrix: Investigate not one, not two, but all business processes in your company Where do you see re-use? Map using MoSCoW ^4 to give importance (M = 10, S = 5, C = 2, W = 1) Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account n/a Issue Debit Card n/a n/a Send Message Send Message Send Message Register Product Owner Register Product Owner n/a","title":"When failure occurs:"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#httpsgithubcoming-bankbaker","text":"Speed of change matters to anyone building software. Many engineering teams have identified Microservices as an important component of this architectural approach to designing more flexible systems that can meet the needs of their fast changing businesses. Applying this approach however, is hard. And ideas and practices are still very much evolving. To help with that, we've launched muCon - a conference to learn about emerging technologies and approaches, share challenges and evolve practices and ideas. Their applications are built on top of microservices. If there careful enough their application serve bad meals. If we are building microservices or a monolith or any type of service in general we are serving business logic to our clients. So no matter what we can not escape the architectural discussion. If we are not careful of how we architect our applications we end up serving bad meals. I love cooking food and for the rest of the talk I'll be using analogies from there. It's very similar to our industry : long hours, hard work, and delivering experiences to our customers. Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners , it still makes me shiver . If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients . So no matter what, we cannot escape the architectural discussion . If we are not careful of how we architect our applications we end up serving a bad meal to our clients.","title":"https://github.com/ing-bank/baker"},{"location":"sections/concepts/","text":"Concepts Baker introduces interactions , ingredients , and events as a model of abstracting. With these three components we can create recipes (process blue prints) Ingredient Ingredients are pure data . This data is immutable and can not be changed after entering the process. There is no hierarchy in this data. ( Animal -> Dog -> Labrador is not possible to express) Examples: an IBAN a track and trace code a list of phone numbers a customer information object with name, email, etc ... An ingredient is defined by a name and type . The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...) The type sets limits on the form of data that is accepted. (a number, a list of strings, ...) This type is expressed by the Baker type system . Interaction An interaction is similar to a function. It requires input ( ingredients ) and provides output ( events ). Within this contract it may do anything. For example: query an external system put a message on a bus generate a document or image extract or compose ingredients into others When finished, an interaction provides an event as its output. Interaction failure An interaction may fail to fulfill its intended purpose. We distinquish two types of failures. A technical failure is one that could be retried and succeed. For example: Time outs because of an unreliable network or packet loss External system is temporarily down or unresponsive External system returned a malformed/unexpected response These failures are unexpected and are modeled by throwing an exception from the interaction. A functional failure is one that cannot be retried. For example: The customer is too young for the request. Not enough credit to perform the transfer. These failures are expected possible outcomes of the interaction. They are modelled by returning an event from the interaction. Failure mitigation In case of technical failures, baker offers two mitigation strategies: Retry with incremental back-off This retries the interaction with some configurable parameters: initialTimeout : The initial delay for the first retry. backoffFactor : The back-off factor. maximumInterval : The maximum interval between retries. Continue with an event. This is analagous to a try/catch in Java code. The exception is logged but the process continues with a specified event. The interaction gets blocked when no failure strategy is defined for it. Event An event has a name and can (optionally) provide ingredients. The purpose of events is therefore twofold. It signifies that something of interest has happened for a recipe instance . Example, \"the customer placed the order\" , \"terms and conditions were accepted\" The event may provide ingredients required to continue the process. Example, \"OrderPlaced\" -> <list of products> We distinguish two conceptual types of events. Sensory events ( external ) These events are provided from outside of the process. Interaction output ( internal ) These events are a result of an interaction being executed. Both of these are still just instances of the EventInstance class, and the distinction is only used as practical terms. Recipe Events , Interactions and Ingredients can be composed into recipes. Recipes are similar to process blueprints. Baker provides a recipe DSL in which you can declaratively describe your recipe. A small example: new Recipe ( \"webshop\" ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class )); The main take away is that when declaring your recipe you do not have to think about order. Everything is automatically linked by the data requirements of the interactions. Continuing from here After adding the dependencies you can continue to: Go through the development life cycle section if you like learning by doing; Go through the reference section if you like learning by description.","title":"Concepts"},{"location":"sections/concepts/#concepts","text":"Baker introduces interactions , ingredients , and events as a model of abstracting. With these three components we can create recipes (process blue prints)","title":"Concepts"},{"location":"sections/concepts/#ingredient","text":"Ingredients are pure data . This data is immutable and can not be changed after entering the process. There is no hierarchy in this data. ( Animal -> Dog -> Labrador is not possible to express) Examples: an IBAN a track and trace code a list of phone numbers a customer information object with name, email, etc ... An ingredient is defined by a name and type . The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...) The type sets limits on the form of data that is accepted. (a number, a list of strings, ...) This type is expressed by the Baker type system .","title":"Ingredient"},{"location":"sections/concepts/#interaction","text":"An interaction is similar to a function. It requires input ( ingredients ) and provides output ( events ). Within this contract it may do anything. For example: query an external system put a message on a bus generate a document or image extract or compose ingredients into others When finished, an interaction provides an event as its output.","title":"Interaction"},{"location":"sections/concepts/#interaction-failure","text":"An interaction may fail to fulfill its intended purpose. We distinquish two types of failures. A technical failure is one that could be retried and succeed. For example: Time outs because of an unreliable network or packet loss External system is temporarily down or unresponsive External system returned a malformed/unexpected response These failures are unexpected and are modeled by throwing an exception from the interaction. A functional failure is one that cannot be retried. For example: The customer is too young for the request. Not enough credit to perform the transfer. These failures are expected possible outcomes of the interaction. They are modelled by returning an event from the interaction.","title":"Interaction failure"},{"location":"sections/concepts/#failure-mitigation","text":"In case of technical failures, baker offers two mitigation strategies: Retry with incremental back-off This retries the interaction with some configurable parameters: initialTimeout : The initial delay for the first retry. backoffFactor : The back-off factor. maximumInterval : The maximum interval between retries. Continue with an event. This is analagous to a try/catch in Java code. The exception is logged but the process continues with a specified event. The interaction gets blocked when no failure strategy is defined for it.","title":"Failure mitigation"},{"location":"sections/concepts/#event","text":"An event has a name and can (optionally) provide ingredients. The purpose of events is therefore twofold. It signifies that something of interest has happened for a recipe instance . Example, \"the customer placed the order\" , \"terms and conditions were accepted\" The event may provide ingredients required to continue the process. Example, \"OrderPlaced\" -> <list of products> We distinguish two conceptual types of events. Sensory events ( external ) These events are provided from outside of the process. Interaction output ( internal ) These events are a result of an interaction being executed. Both of these are still just instances of the EventInstance class, and the distinction is only used as practical terms.","title":"Event"},{"location":"sections/concepts/#recipe","text":"Events , Interactions and Ingredients can be composed into recipes. Recipes are similar to process blueprints. Baker provides a recipe DSL in which you can declaratively describe your recipe. A small example: new Recipe ( \"webshop\" ) . withSensoryEvents ( OrderPlaced . class , CustomerInfoReceived . class . withInteractions ( of ( ValidateOrder . class ), of ( ManufactureGoods . class )); The main take away is that when declaring your recipe you do not have to think about order. Everything is automatically linked by the data requirements of the interactions.","title":"Recipe"},{"location":"sections/concepts/#continuing-from-here","text":"After adding the dependencies you can continue to: Go through the development life cycle section if you like learning by doing; Go through the reference section if you like learning by description.","title":"Continuing from here"},{"location":"sections/feature-comparison/","text":"This is a comparison of Baker with similar solutions. Feedback and contributions to solutions not listed are most welcome. Feature Baker Camunda Pega Netflix Conductor Uber Cadence Apache Airflow Owned By ING Camunda PEGA Systems Netflix Uber Community Primary Purpose Orchestration of (micro-)services Process Automation Workflow or case management Orchestration of (micro-)services Orchestration of long-running business logic Workflow of big-data pipelines Typical Use Straight Through Processing (STP) Business Processes with Decision Making Business Processes with Decision Making STP STP Big data Skill-set required Java or Scala Java, Business Process Modelling Notation (BPMN) Pega-specific JSON Java Python, Bash Execution Model Petri-net BPMN for workflows, Decision Model and Notation (DMN) for business rules Don\u2019t know Queueing Theory Queueing Theory Graph Theory In-memory processing Yes Yes No Yes No No Data Persistence Event sourcing with Cassandra Relational DB via JDBC Relational Dedicated Storage (Dynomite) Cassandra N/A Process Visualization Graphviz Based on BPMN Based on BPMN Dedicated UI No Dedicated UI License Model Open-source Community Platform is open-source Pay per Case Open-source Open-source Open-source Rich UI No Yes Yes Yes No Yes","title":"Feature comparison"},{"location":"sections/getting-started/","text":"Getting Started Project setup Baker is released to maven central . You can add below dependencies to your maven or sbt project to start using it. Baker is released cross compiled for Scala 2.12 and Scala 2.13. Sbt dependencies += \"com.ing.baker\" %% \"baker-recipe-dsl\" % \"3.5.0\" dependencies += \"com.ing.baker\" %% \"baker-compiler\" % \"3.5.0\" dependencies += \"com.ing.baker\" %% \"baker-runtime\" % \"3.5.0\" Maven <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-recipe-dsl_2.13 </artifactId> <version> 3.5.0 </version> </dependency> <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-compiler_2.13 </artifactId> <version> 3.5.0 </version> </dependency> <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-runtime_2.13 </artifactId> <version> 3.5.0 </version> </dependency> This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need. Modules An explanation of the baker modules. Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri Net model that the runtime can execute This is the dependency graph between the modules. Continuing from here After adding the dependencies you can continue to: Understand the high level concepts . If you like learning by doing, go through the development life cycle section . If you like learning by description, go through the reference section .","title":"Getting Started"},{"location":"sections/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"sections/getting-started/#project-setup","text":"Baker is released to maven central . You can add below dependencies to your maven or sbt project to start using it. Baker is released cross compiled for Scala 2.12 and Scala 2.13. Sbt dependencies += \"com.ing.baker\" %% \"baker-recipe-dsl\" % \"3.5.0\" dependencies += \"com.ing.baker\" %% \"baker-compiler\" % \"3.5.0\" dependencies += \"com.ing.baker\" %% \"baker-runtime\" % \"3.5.0\" Maven <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-recipe-dsl_2.13 </artifactId> <version> 3.5.0 </version> </dependency> <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-compiler_2.13 </artifactId> <version> 3.5.0 </version> </dependency> <dependency> <groupId> com.ing.baker </groupId> <artifactId> baker-runtime_2.13 </artifactId> <version> 3.5.0 </version> </dependency> This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need.","title":"Project setup"},{"location":"sections/getting-started/#modules","text":"An explanation of the baker modules. Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri Net model that the runtime can execute This is the dependency graph between the modules.","title":"Modules"},{"location":"sections/getting-started/#continuing-from-here","text":"After adding the dependencies you can continue to: Understand the high level concepts . If you like learning by doing, go through the development life cycle section . If you like learning by description, go through the reference section .","title":"Continuing from here"},{"location":"sections/development-life-cycle/","text":"Development Life Cycle In this section we will explain every step in the process of developing business functionality across your microservices using Baker, we will focus on practical aspects: how to do things and why you should do them. The general steps in the development lifecycle are: 1) Design a Recipe: In Baker you are always required to make a distinction between specification (Recipe) and implementation (Runtime) of your business process, you will use the Recipe DSL to express the interface of ingredients and events (data) and interactions (actions), which will help Baker understand your orchestration flow. Baker recipes are the interface of your business process, they specify Baker Types without values for Ingredients and Events, and specify input Ingredients and output Events without implementation for Interactions. 2) Use Visualizations: Baker is able to create a graphical representation of your recipe, this becomes very useful for reasoning about your business process, and easily communicate and discuss about it. 3) Implement Interactions: To execute the orchestration plan specified by the recipe, you must create interaction implementations, which are the code blocks that match the interfaces of the ingredient/event/interactions. These must be registered to baker, which will imply their correspondence with the recipe by matching the interfaces. 4) Create Process Instances, Fire Events and Inquiry: After registering recipes and implementations, you are able to create instances of the recipes, which execute after you fire events, which will execute calls to your microservices. The state of a given process may be requested at any time for application utility. 5) Test: Common methods of testing are, independently test each implementation, running a process instance and then inspect the current state, and running a process instance using mocked implementations. 6) Configure: There are several parts of Baker that can be configured, including but not limited to: event store connection, clustering, etc. 7) Deploy: Baker has a cluster mode, which must be deployed with a certain order or by configuring service discovery. 8) Monitor: Baker provides event listeners, which will allow you to monitor the process instances. 9) Resolve Failed Processes:","title":"Development Life Cycle"},{"location":"sections/development-life-cycle/#development-life-cycle","text":"In this section we will explain every step in the process of developing business functionality across your microservices using Baker, we will focus on practical aspects: how to do things and why you should do them. The general steps in the development lifecycle are: 1) Design a Recipe: In Baker you are always required to make a distinction between specification (Recipe) and implementation (Runtime) of your business process, you will use the Recipe DSL to express the interface of ingredients and events (data) and interactions (actions), which will help Baker understand your orchestration flow. Baker recipes are the interface of your business process, they specify Baker Types without values for Ingredients and Events, and specify input Ingredients and output Events without implementation for Interactions. 2) Use Visualizations: Baker is able to create a graphical representation of your recipe, this becomes very useful for reasoning about your business process, and easily communicate and discuss about it. 3) Implement Interactions: To execute the orchestration plan specified by the recipe, you must create interaction implementations, which are the code blocks that match the interfaces of the ingredient/event/interactions. These must be registered to baker, which will imply their correspondence with the recipe by matching the interfaces. 4) Create Process Instances, Fire Events and Inquiry: After registering recipes and implementations, you are able to create instances of the recipes, which execute after you fire events, which will execute calls to your microservices. The state of a given process may be requested at any time for application utility. 5) Test: Common methods of testing are, independently test each implementation, running a process instance and then inspect the current state, and running a process instance using mocked implementations. 6) Configure: There are several parts of Baker that can be configured, including but not limited to: event store connection, clustering, etc. 7) Deploy: Baker has a cluster mode, which must be deployed with a certain order or by configuring service discovery. 8) Monitor: Baker provides event listeners, which will allow you to monitor the process instances. 9) Resolve Failed Processes:","title":"Development Life Cycle"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/","text":"Bake, Fire Events and Inquiry At this moment we already have a Recipe and InteractionInstances , the next step is to create a Baker runtime, and add to it the ImplementationInstances and the Recipe (in that order, since adding a Recipe validates that there exist valid InteractionInstances for each Interaction ). For this example we are going to create an Akka-based, non-cluster, local runtime. This runtime is based on a library called Akka which helps us manage concurrency and gives us distributed-systems semantics for the cluster mode, this is almost completely hidden from you, but currently for some configuration and managing a Baker cluster, it might be useful to check the Akka documentation. Also note that to add a Recipe you need to first transform it into a CompiledRecipe by using the provided RecipeCompiler.compileRecipe(recipe) API. Note: Since Baker 3.0 all APIs of the runtime are asynchronous by default. That means all APIs return Future[A] for Scala (IO interface will come in the future depending on demand) and CompletableFuture<A> for Java. If you are not familiar with these constructs we highly recommend checking one of the many tutorials and documentation pages in the internet, otherwise for now you can do .join on any CompletableFuture or Await.result(yourFuture, 1.second) on any Future to block and do normal synchronous/blocking programming. Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker import scala.concurrent. { Await , Future } import scala.concurrent.duration._ import scala.concurrent.ExecutionContext.Implicits.global implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . akkaLocalDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstancesReflection . reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) } yield () Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.concurrent.CompletableFuture ; public class JMain { static public void main ( String [] args ) { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); CompletableFuture < String > asyncRecipeId = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))); // Blocks, not recommended but useful for testing or trying things out String recipeId = asyncRecipeId . join (); } } Bake Next, you can start one instance of your process by baking a recipe, this will internally create a RecipeInstance which will hold the state of your process, listen to EventInstances , execute your InteractionInstances when IngredientInstances are available and handle any failure state. RecipeInstances can be created by choosing a CompiledRecipe by using the recipeId yielded by the Baker.addRecipe(RecipeRecord.of(compiledRecipe)) API, and by providing a recipeInstanceId of your choosing; you will use this last id to reference and interact with the created RecipeInstance . Use the Baker.bake(recipeId, recipeInstanceId) API for creating a RecipeInstance . Note: In an Akka-cluster-based Baker, these RecipeInstances are also automatically distributed over nodes, and the cluster will ensure that there is 1 RecipeInstance running on 1 node, and if the node dies, it will detect it and restore the RecipeInstance in another available node, for this you need to configure an underlying distributed store; for more on this please refer to the configuration section and the runtime section . Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker import scala.concurrent. { Await , Future } import scala.concurrent.duration._ import scala.concurrent.ExecutionContext.Implicits.global implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstancesReflection . reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) _ <- baker . bake ( recipeId , \"first-instance-id\" ) } yield () Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.concurrent.CompletableFuture ; // As a small quirk ok the Java API, all operations which are ment to not return something, will return a // scala.runtime.BoxedUnit object. You should think of it like Java's Void or void and you can safely // ignore it except for your type signatures. import scala.runtime.BoxedUnit ; public class JMain { static public void main ( String [] args ) { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); CompletableFuture < BoxedUnit > asyncRecipeId = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )); } } Fire Events Next, we want our process to start flowing through it's state, and start executing InteractionInstances , for that we need to fire the nicknamed SensoryEvents which are just EventInstances which match the root Events from our Recipe . There are several supported semantics for firing an event. When you fire an event you might want to be notified and continue your asynchronous computation on 1 of 4 different moments: When the event got accepted by the RecipeInstance but has not started cascading the execution of InteractionInstances . For this use the Baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance) API. This will return a Future[SensoryEventStatus] enum notifying of the outcome (the event might get rejected). When the event got accepted by the RecipeInstance and has finished cascading the execution of InteractionInstances up to the point that it requires more EventInstances ( SensoryEvents ) to continue, or the process has finished. For this use the Baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance) API. This will return a Future[EventResult] object containing a SensoryEventStatus , the Event names that got fired in consequence of this SensoryEvent , and the current available Ingredients output of the InteractionInstances that got executed as consequence of the SensoryEvent . You want to do something on both of the previously mentioned moments, then use the Baker.fireEvent(recipeInstanceId, eventInstance) API, which will return an EventResolutions object which contains both Future[SensoryEventStatus] and Future[EventResult] (or its CompletableFuture<A> equivalents in Java). As soon as an intermediate Event fires from one of the InteractionInstances that execute as consequence of the fired SensoryEvent . For this use the Baker.fireEventAndResolveOnEvent(recipeInstanceId, eventInstance, onEventName) API. This will return a similar Future[EventResult to the one returned by Baker.fireEventAndResolveWhenCompleted except the data will be up to the moment the onEventName was fired. Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker import scala.concurrent. { Await , Future } import scala.concurrent.duration._ import scala.concurrent.ExecutionContext.Implicits.global implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstancesReflection . reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) _ <- baker . bake ( recipeId , \"first-instance-id\" ) firstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( \"order-uuid\" , List ( \"item1\" , \"item2\" ))) result <- baker . fireEventAndResolveWhenCompleted ( \"first-instance-id\" , firstOrderPlaced ) _ = assert ( result . events == Seq ( WebshopRecipe . Events . OrderPlaced . name , WebshopRecipe . Events . ItemsReserved . name ) } yield () Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.EventInstance ; import com.ing.baker.runtime.javadsl.EventResult ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.ArrayList ; import java.util.List ; import java.util.concurrent.CompletableFuture ; public class JMain { static public void main ( String [] args ) { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenApply ( EventResult :: events ); List < String > blockedResult = result . join (); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"ReservedItems\" )); } } Inquiry Recipe Instance State As a final step on what you might want to do with Baker (without considering handling failed RecipeInstances ), is that you can query the state of a RecipeInstance at any given moment. For this you can use the Baker.getInteractionInstanceState(recipeInstanceId) API. This will return an InteractionInstanceState object which contains all the event names with timestamps that have executed, and the current available provided ingredients waiting for the next InteractionInstances to consume. Recipe Instance State Visualizations Another method of fetching state is the visual representation of it. You can do that with the Baker.getVisualState(recipeInstanceId) API. This will return a GraphViz string like the visualization api that you can convert into an image. Here is a visualization of the state of another webshop example, one can clearly see that the process is flowing correctly without failures and that it is still waiting for the payment sensory event to be fired.","title":"Bake, Fire Events and Inquiry"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/#bake-fire-events-and-inquiry","text":"At this moment we already have a Recipe and InteractionInstances , the next step is to create a Baker runtime, and add to it the ImplementationInstances and the Recipe (in that order, since adding a Recipe validates that there exist valid InteractionInstances for each Interaction ). For this example we are going to create an Akka-based, non-cluster, local runtime. This runtime is based on a library called Akka which helps us manage concurrency and gives us distributed-systems semantics for the cluster mode, this is almost completely hidden from you, but currently for some configuration and managing a Baker cluster, it might be useful to check the Akka documentation. Also note that to add a Recipe you need to first transform it into a CompiledRecipe by using the provided RecipeCompiler.compileRecipe(recipe) API. Note: Since Baker 3.0 all APIs of the runtime are asynchronous by default. That means all APIs return Future[A] for Scala (IO interface will come in the future depending on demand) and CompletableFuture<A> for Java. If you are not familiar with these constructs we highly recommend checking one of the many tutorials and documentation pages in the internet, otherwise for now you can do .join on any CompletableFuture or Await.result(yourFuture, 1.second) on any Future to block and do normal synchronous/blocking programming. Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker import scala.concurrent. { Await , Future } import scala.concurrent.duration._ import scala.concurrent.ExecutionContext.Implicits.global implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . akkaLocalDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstancesReflection . reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) } yield () Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.concurrent.CompletableFuture ; public class JMain { static public void main ( String [] args ) { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); CompletableFuture < String > asyncRecipeId = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))); // Blocks, not recommended but useful for testing or trying things out String recipeId = asyncRecipeId . join (); } }","title":"Bake, Fire Events and Inquiry"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/#bake","text":"Next, you can start one instance of your process by baking a recipe, this will internally create a RecipeInstance which will hold the state of your process, listen to EventInstances , execute your InteractionInstances when IngredientInstances are available and handle any failure state. RecipeInstances can be created by choosing a CompiledRecipe by using the recipeId yielded by the Baker.addRecipe(RecipeRecord.of(compiledRecipe)) API, and by providing a recipeInstanceId of your choosing; you will use this last id to reference and interact with the created RecipeInstance . Use the Baker.bake(recipeId, recipeInstanceId) API for creating a RecipeInstance . Note: In an Akka-cluster-based Baker, these RecipeInstances are also automatically distributed over nodes, and the cluster will ensure that there is 1 RecipeInstance running on 1 node, and if the node dies, it will detect it and restore the RecipeInstance in another available node, for this you need to configure an underlying distributed store; for more on this please refer to the configuration section and the runtime section . Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker import scala.concurrent. { Await , Future } import scala.concurrent.duration._ import scala.concurrent.ExecutionContext.Implicits.global implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstancesReflection . reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) _ <- baker . bake ( recipeId , \"first-instance-id\" ) } yield () Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.concurrent.CompletableFuture ; // As a small quirk ok the Java API, all operations which are ment to not return something, will return a // scala.runtime.BoxedUnit object. You should think of it like Java's Void or void and you can safely // ignore it except for your type signatures. import scala.runtime.BoxedUnit ; public class JMain { static public void main ( String [] args ) { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); CompletableFuture < BoxedUnit > asyncRecipeId = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )); } }","title":"Bake"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/#fire-events","text":"Next, we want our process to start flowing through it's state, and start executing InteractionInstances , for that we need to fire the nicknamed SensoryEvents which are just EventInstances which match the root Events from our Recipe . There are several supported semantics for firing an event. When you fire an event you might want to be notified and continue your asynchronous computation on 1 of 4 different moments: When the event got accepted by the RecipeInstance but has not started cascading the execution of InteractionInstances . For this use the Baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance) API. This will return a Future[SensoryEventStatus] enum notifying of the outcome (the event might get rejected). When the event got accepted by the RecipeInstance and has finished cascading the execution of InteractionInstances up to the point that it requires more EventInstances ( SensoryEvents ) to continue, or the process has finished. For this use the Baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance) API. This will return a Future[EventResult] object containing a SensoryEventStatus , the Event names that got fired in consequence of this SensoryEvent , and the current available Ingredients output of the InteractionInstances that got executed as consequence of the SensoryEvent . You want to do something on both of the previously mentioned moments, then use the Baker.fireEvent(recipeInstanceId, eventInstance) API, which will return an EventResolutions object which contains both Future[SensoryEventStatus] and Future[EventResult] (or its CompletableFuture<A> equivalents in Java). As soon as an intermediate Event fires from one of the InteractionInstances that execute as consequence of the fired SensoryEvent . For this use the Baker.fireEventAndResolveOnEvent(recipeInstanceId, eventInstance, onEventName) API. This will return a similar Future[EventResult to the one returned by Baker.fireEventAndResolveWhenCompleted except the data will be up to the moment the onEventName was fired. Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker import scala.concurrent. { Await , Future } import scala.concurrent.duration._ import scala.concurrent.ExecutionContext.Implicits.global implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstancesReflection . reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) _ <- baker . bake ( recipeId , \"first-instance-id\" ) firstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( \"order-uuid\" , List ( \"item1\" , \"item2\" ))) result <- baker . fireEventAndResolveWhenCompleted ( \"first-instance-id\" , firstOrderPlaced ) _ = assert ( result . events == Seq ( WebshopRecipe . Events . OrderPlaced . name , WebshopRecipe . Events . ItemsReserved . name ) } yield () Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.EventInstance ; import com.ing.baker.runtime.javadsl.EventResult ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.ArrayList ; import java.util.List ; import java.util.concurrent.CompletableFuture ; public class JMain { static public void main ( String [] args ) { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenApply ( EventResult :: events ); List < String > blockedResult = result . join (); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"ReservedItems\" )); } }","title":"Fire Events"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/#inquiry","text":"","title":"Inquiry"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/#recipe-instance-state","text":"As a final step on what you might want to do with Baker (without considering handling failed RecipeInstances ), is that you can query the state of a RecipeInstance at any given moment. For this you can use the Baker.getInteractionInstanceState(recipeInstanceId) API. This will return an InteractionInstanceState object which contains all the event names with timestamps that have executed, and the current available provided ingredients waiting for the next InteractionInstances to consume.","title":"Recipe Instance State"},{"location":"sections/development-life-cycle/bake-fire-events-and-inquiry/#recipe-instance-state-visualizations","text":"Another method of fetching state is the visual representation of it. You can do that with the Baker.getVisualState(recipeInstanceId) API. This will return a GraphViz string like the visualization api that you can convert into an image. Here is a visualization of the state of another webshop example, one can clearly see that the process is flowing correctly without failures and that it is still waiting for the payment sensory event to be fired.","title":"Recipe Instance State Visualizations"},{"location":"sections/development-life-cycle/configure/","text":"Configure Minimal configuration When creating a baker instance using the constructor Baker.akka(config, actorSystem) baker will require you to add the minimal baker configuration, you can do this by adding this to your application.conf file: include \"baker.conf\" This will add the following minimal configuration: akka.cluster.sharding.state-store-mode = persistence akka.actor.allow-java-serialization = off reference.conf Here you will find the reference.conf of Baker, this represents the current default configuration of Baker. Note: Since the Baker runtime is based on Akka, there is extra configuration that can be done, please refer to the Akka configuration documentation baker { actor { # the id of the journal to read events from read-journal-plugin = \"inmemory-read-journal\" # either \"local\" or \"cluster-sharded\" provider = \"local\" # the recommended nr is number-of-cluster-nodes * 10 cluster.nr-of-shards = 50 # the time that inactive actors (processes) stay in memory idle-timeout = 5 minutes # The interval that a check is done of processes should be deleted retention-check-interval = 1 minutes } # the default timeout for Baker.bake(..) process creation calls bake-timeout = 10 seconds # the timeout for refreshing the local recipe cache process-index-update-cache-timeout = 5 seconds # the default timeout for Baker.processEvent(..) process-event-timeout = 10 seconds # the default timeout for inquires on Baker, this means getIngredients(..) & getEvents(..) process-inquire-timeout = 10 seconds # when baker starts up, it attempts to 'initialize' the journal connection, this may take some time journal-initialize-timeout = 30 seconds # the default timeout for adding a recipe to Baker add-recipe-timeout = 10 seconds # the time to wait for a graceful shutdown shutdown-timeout = 30 seconds # the timeout when calling executeSingleInteraction execute-single-interaction-timeout = 60 seconds # The ingredients that are filtered out when getting the process instance. # This should be used if there are big ingredients to improve performance and memory usage. # The ingredients will be in the ingredients map but there value will be an empty String. filtered-ingredient-values = [] # encryption settings encryption { # whether to encrypt data stored in the journal, off or on enabled = off # if enabled = on, a secret should be set # secret = ??? } } akka { # by default we use the in memory journal from: https://github.com/dnvriend/akka-persistence-inmemory persistence.journal.plugin = \"inmemory-journal\" persistence.snapshot-store.plugin = \"inmemory-snapshot-store\" }","title":"Configure"},{"location":"sections/development-life-cycle/configure/#configure","text":"","title":"Configure"},{"location":"sections/development-life-cycle/configure/#minimal-configuration","text":"When creating a baker instance using the constructor Baker.akka(config, actorSystem) baker will require you to add the minimal baker configuration, you can do this by adding this to your application.conf file: include \"baker.conf\" This will add the following minimal configuration: akka.cluster.sharding.state-store-mode = persistence akka.actor.allow-java-serialization = off","title":"Minimal configuration"},{"location":"sections/development-life-cycle/configure/#referenceconf","text":"Here you will find the reference.conf of Baker, this represents the current default configuration of Baker. Note: Since the Baker runtime is based on Akka, there is extra configuration that can be done, please refer to the Akka configuration documentation baker { actor { # the id of the journal to read events from read-journal-plugin = \"inmemory-read-journal\" # either \"local\" or \"cluster-sharded\" provider = \"local\" # the recommended nr is number-of-cluster-nodes * 10 cluster.nr-of-shards = 50 # the time that inactive actors (processes) stay in memory idle-timeout = 5 minutes # The interval that a check is done of processes should be deleted retention-check-interval = 1 minutes } # the default timeout for Baker.bake(..) process creation calls bake-timeout = 10 seconds # the timeout for refreshing the local recipe cache process-index-update-cache-timeout = 5 seconds # the default timeout for Baker.processEvent(..) process-event-timeout = 10 seconds # the default timeout for inquires on Baker, this means getIngredients(..) & getEvents(..) process-inquire-timeout = 10 seconds # when baker starts up, it attempts to 'initialize' the journal connection, this may take some time journal-initialize-timeout = 30 seconds # the default timeout for adding a recipe to Baker add-recipe-timeout = 10 seconds # the time to wait for a graceful shutdown shutdown-timeout = 30 seconds # the timeout when calling executeSingleInteraction execute-single-interaction-timeout = 60 seconds # The ingredients that are filtered out when getting the process instance. # This should be used if there are big ingredients to improve performance and memory usage. # The ingredients will be in the ingredients map but there value will be an empty String. filtered-ingredient-values = [] # encryption settings encryption { # whether to encrypt data stored in the journal, off or on enabled = off # if enabled = on, a secret should be set # secret = ??? } } akka { # by default we use the in memory journal from: https://github.com/dnvriend/akka-persistence-inmemory persistence.journal.plugin = \"inmemory-journal\" persistence.snapshot-store.plugin = \"inmemory-snapshot-store\" }","title":"reference.conf"},{"location":"sections/development-life-cycle/design-a-recipe/","text":"Design a Recipe Full project examples including tests and configuration can be found here . The Development Life Cycle section provides a \"top-down\"/\"by-example\" guide to baker, all of the concepts are introduced through exemplification on hypothetical development situations. Modeling the order placement process for a webshop using Ingredients, Events and Recipes. The recipe DSL allows you to declaratively describe your business process. The design always starts with the business requirements, lets say you are developing a webshop which will have many different microservices on the backend. The initial requirements for the order reservation process reads: \"An order contains an order id and a list of store item identifiers, when an order is placed it must first be validated by reserving the items from the warehouse service, a success scenario yields the ids of the reserved items, but if at least one item is unavailable at the warehouse a failure yields the list of unavailable items and the process stops\" When developing with Baker we must first translate the requirements into our 3 essential building blocks, Ingredients for raw data, Events for happenings (that might contain ingredients), and Interactions which have ingredients as input, execute actions with other systems, and yield more events. We will do this so that the baker runtime can orchestrate the execution of our process through the underlying microservices. Ingredients and Events A recipe always starts with initial events, also called Sensory Events , in the case of our first requirement we could model the placing of an order as an event, which will provide 2 ingredients: the order id and the list of items. Scala import com.ing.baker.recipe.scaladsl._ object Ingredients { val OrderId : Ingredient [ String ] = Ingredient [ String ]( \"orderId\" ) val Items : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"items\" ) } object Events { val OrderPlaced : Event = Event ( name = \"OrderPlaced\" , providedIngredients = Seq ( Ingredients . OrderId , Ingredients . Items ), maxFiringLimit = Some ( 1 ) ) } Java // In Java the data structures to represent Events and Ingredients // will be extraxted from a class by the reflection API when building // the Recipe. (see below for full example) public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } } Depending on your programming language, you might want to import the corresponding dsl, i.e. scaladsl vs javadsl . Ingredients and events are just data structures that describe your process data, carrying not just the names, but also the type information, for example Ingredient[String](\"order-id\") creates an ingredient of name \"order-id\" of type \"String\", for more information about Baker types please refer to this section . As shown in the code, events might carry ingredients, and have a maximum about of times they are allowed to fire, the runtime will enforce this limit. For more information about this and other features of events please refer to this section . Interactions Then, the desired actions can be modeled as interactions , in our case we are told that it exists a warehouse service which we need to call to reserve the items, but this might either succeed or fail. Note: Notice that when using the reflection API, the Java interface or Scala trait that will represent your interaction must have a method named apply , this is the method that the reflection API will convert into Baker types/ingredients/events. Scala object Interactions { val ReserveItems : Interaction = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredients . OrderId , Ingredients . Items , ), output = Seq ( Events . OrderHadUnavailableItems , Events . ItemsReserved ) ) } object Ingredients { // ... previous ingredients val ReservedItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"reservedItems\" ) val UnavailableItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"unavailableItems\" ) } object Events { // ... previous events val OrderHadUnavailableItems : Event = Event ( name = \"OrderHadUnavailableItems\" , providedIngredients = Seq ( Ingredients . UnavailableItems ), maxFiringLimit = Some ( 1 ) ) val ItemsReserved : Event = Event ( name = \"ItemsReserved\" , providedIngredients = Seq ( Ingredients . ReservedItems ), maxFiringLimit = Some ( 1 ) ) } Java (Reflection API) public class JWebshopRecipe { // ... previous event // Interface that will represent our Interaction, notice that it is declaring inner events. public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } // The @FireEvent annotation communicates the reflection API about several possible outcome events. @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) // The @RequiresIngredient annotation communicates the reflection API about the ingredient names that other events // must provide to execute this interaction. // The method MUST be named `apply` ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } } An interaction resembles a function, it takes input ingredients and outputs 1 of several possible events. At runtime, when an event fires, baker tries to match the provided ingredients of 1 or several events to the input of awaiting interactions, as soon as there is a match on data, baker will execute the interactions, creating a cascading effect that will execute your business process in an asynchronous manner. This was a simple example, but you might have already concluded that this can be further composed into bigger processes by making new interactions that require events and ingredients which are output of previous interactions. You can create also interactions which take no input ingredients but are executed after events (with or without provided ingredients) are fired, for this and other features please refer to the conceptual documentation found here . The Recipe The final step is to create an object that will hold all of these descriptions into what we call a Recipe, this becomes the \"blueprint\" of your process, it can define failure handling strategies, and will \"auto-bind\" the interactions, that means it detects the composition between interactions by matching the ingredients provided by events to the input ingredients required by interactions. Scala object WebshopRecipe { val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Events . OrderPlaced ) . withInteractions ( Interactions . ReserveItems , ) } Java public class JWebshopRecipe { // ... previous events and interactions. public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); } Let us remember that this is just a description of what our program across multiple services should do, on the next sections we will see how to visualize it, create runtime instances of our recipes and their parts, what common practices are there for testing, everything you need to know to deploy and monitor a baker cluster, and how Baker helps you handle and resolve failure which is not modeled in the domain (in the recipe). As you might have realised Ingredients , Events and Interactions could be reused on different Recipes, giving common business verbs that your programs and organisation can use across teams, the same way different cooking recipes share same processes (simmering, boiling, cutting) you should reuse interactions across your different business recipes. As a bonus; you might have though that this API is verbose, we agree and that is why we developed an alternative API which uses Java and Scala reflection. Scala (Reflection API) package webshop import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } object WebshopRecipeReflection { case class OrderPlaced ( orderId : String , items : List [ String ]) sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput val ReserveItems = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) ) val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Event [ OrderPlaced ]) . withInteractions ( ReserveItems ) } Java (Reflection API) package webshop ; import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.Interaction ; import com.ing.baker.recipe.javadsl.Recipe ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } // The @FireEvent annotation communicates the reflection API about several possible outcome events. @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) // The @RequiresIngredient annotation communicates the reflection API about the ingredient names that other events // must provide to execute this interaction. ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); }","title":"Design a Recipe"},{"location":"sections/development-life-cycle/design-a-recipe/#design-a-recipe","text":"Full project examples including tests and configuration can be found here . The Development Life Cycle section provides a \"top-down\"/\"by-example\" guide to baker, all of the concepts are introduced through exemplification on hypothetical development situations.","title":"Design a Recipe"},{"location":"sections/development-life-cycle/design-a-recipe/#modeling-the-order-placement-process-for-a-webshop-using-ingredients-events-and-recipes","text":"The recipe DSL allows you to declaratively describe your business process. The design always starts with the business requirements, lets say you are developing a webshop which will have many different microservices on the backend. The initial requirements for the order reservation process reads: \"An order contains an order id and a list of store item identifiers, when an order is placed it must first be validated by reserving the items from the warehouse service, a success scenario yields the ids of the reserved items, but if at least one item is unavailable at the warehouse a failure yields the list of unavailable items and the process stops\" When developing with Baker we must first translate the requirements into our 3 essential building blocks, Ingredients for raw data, Events for happenings (that might contain ingredients), and Interactions which have ingredients as input, execute actions with other systems, and yield more events. We will do this so that the baker runtime can orchestrate the execution of our process through the underlying microservices.","title":"Modeling the order placement process for a webshop using Ingredients, Events and Recipes."},{"location":"sections/development-life-cycle/design-a-recipe/#ingredients-and-events","text":"A recipe always starts with initial events, also called Sensory Events , in the case of our first requirement we could model the placing of an order as an event, which will provide 2 ingredients: the order id and the list of items. Scala import com.ing.baker.recipe.scaladsl._ object Ingredients { val OrderId : Ingredient [ String ] = Ingredient [ String ]( \"orderId\" ) val Items : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"items\" ) } object Events { val OrderPlaced : Event = Event ( name = \"OrderPlaced\" , providedIngredients = Seq ( Ingredients . OrderId , Ingredients . Items ), maxFiringLimit = Some ( 1 ) ) } Java // In Java the data structures to represent Events and Ingredients // will be extraxted from a class by the reflection API when building // the Recipe. (see below for full example) public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } } Depending on your programming language, you might want to import the corresponding dsl, i.e. scaladsl vs javadsl . Ingredients and events are just data structures that describe your process data, carrying not just the names, but also the type information, for example Ingredient[String](\"order-id\") creates an ingredient of name \"order-id\" of type \"String\", for more information about Baker types please refer to this section . As shown in the code, events might carry ingredients, and have a maximum about of times they are allowed to fire, the runtime will enforce this limit. For more information about this and other features of events please refer to this section .","title":"Ingredients and Events"},{"location":"sections/development-life-cycle/design-a-recipe/#interactions","text":"Then, the desired actions can be modeled as interactions , in our case we are told that it exists a warehouse service which we need to call to reserve the items, but this might either succeed or fail. Note: Notice that when using the reflection API, the Java interface or Scala trait that will represent your interaction must have a method named apply , this is the method that the reflection API will convert into Baker types/ingredients/events. Scala object Interactions { val ReserveItems : Interaction = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredients . OrderId , Ingredients . Items , ), output = Seq ( Events . OrderHadUnavailableItems , Events . ItemsReserved ) ) } object Ingredients { // ... previous ingredients val ReservedItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"reservedItems\" ) val UnavailableItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"unavailableItems\" ) } object Events { // ... previous events val OrderHadUnavailableItems : Event = Event ( name = \"OrderHadUnavailableItems\" , providedIngredients = Seq ( Ingredients . UnavailableItems ), maxFiringLimit = Some ( 1 ) ) val ItemsReserved : Event = Event ( name = \"ItemsReserved\" , providedIngredients = Seq ( Ingredients . ReservedItems ), maxFiringLimit = Some ( 1 ) ) } Java (Reflection API) public class JWebshopRecipe { // ... previous event // Interface that will represent our Interaction, notice that it is declaring inner events. public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } // The @FireEvent annotation communicates the reflection API about several possible outcome events. @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) // The @RequiresIngredient annotation communicates the reflection API about the ingredient names that other events // must provide to execute this interaction. // The method MUST be named `apply` ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } } An interaction resembles a function, it takes input ingredients and outputs 1 of several possible events. At runtime, when an event fires, baker tries to match the provided ingredients of 1 or several events to the input of awaiting interactions, as soon as there is a match on data, baker will execute the interactions, creating a cascading effect that will execute your business process in an asynchronous manner. This was a simple example, but you might have already concluded that this can be further composed into bigger processes by making new interactions that require events and ingredients which are output of previous interactions. You can create also interactions which take no input ingredients but are executed after events (with or without provided ingredients) are fired, for this and other features please refer to the conceptual documentation found here .","title":"Interactions"},{"location":"sections/development-life-cycle/design-a-recipe/#the-recipe","text":"The final step is to create an object that will hold all of these descriptions into what we call a Recipe, this becomes the \"blueprint\" of your process, it can define failure handling strategies, and will \"auto-bind\" the interactions, that means it detects the composition between interactions by matching the ingredients provided by events to the input ingredients required by interactions. Scala object WebshopRecipe { val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Events . OrderPlaced ) . withInteractions ( Interactions . ReserveItems , ) } Java public class JWebshopRecipe { // ... previous events and interactions. public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); } Let us remember that this is just a description of what our program across multiple services should do, on the next sections we will see how to visualize it, create runtime instances of our recipes and their parts, what common practices are there for testing, everything you need to know to deploy and monitor a baker cluster, and how Baker helps you handle and resolve failure which is not modeled in the domain (in the recipe). As you might have realised Ingredients , Events and Interactions could be reused on different Recipes, giving common business verbs that your programs and organisation can use across teams, the same way different cooking recipes share same processes (simmering, boiling, cutting) you should reuse interactions across your different business recipes. As a bonus; you might have though that this API is verbose, we agree and that is why we developed an alternative API which uses Java and Scala reflection. Scala (Reflection API) package webshop import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } object WebshopRecipeReflection { case class OrderPlaced ( orderId : String , items : List [ String ]) sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput val ReserveItems = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) ) val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Event [ OrderPlaced ]) . withInteractions ( ReserveItems ) } Java (Reflection API) package webshop ; import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.Interaction ; import com.ing.baker.recipe.javadsl.Recipe ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } // The @FireEvent annotation communicates the reflection API about several possible outcome events. @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) // The @RequiresIngredient annotation communicates the reflection API about the ingredient names that other events // must provide to execute this interaction. ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); }","title":"The Recipe"},{"location":"sections/development-life-cycle/implement-interactions/","text":"Implement Interactions After creating a recipe, and before we can even run processes from it, we need to create InteractionInstances that the Baker runtime will use to execute the real actions of your Recipe , these instances must match the Interactions in the Recipe , that means that the name and the input types must match. For the Scala DSL you need to create an object of InteractionImplementation , or use the reflection API in a similar way to the Java DSL. For the Java DSL you need to implement the interface with the apply method that you used for the Interaction in the Recipe and then use the InteractionImplementation.from(new Implementation()) reflection API, this will create a new InteractionImplementation that we will later on add to a baker runtime. Scala Reflection API import com.ing.baker.runtime.scaladsl.InteractionInstance import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } class ReserveItemsInstance extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] = { // Http call to the Warehouse service val response : Future [ Either [ List [ String ] , List [ String ]]] = // This is mocked for the sake of the example Future . successful ( Right ( items )) // Build an event instance that Baker understands response . map { case Left ( unavailableItems ) => WebshopRecipeReflection . OrderHadUnavailableItems ( unavailableItems ) case Right ( reservedItems ) => WebshopRecipeReflection . ItemsReserved ( reservedItems ) } } } val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) Scala import com.ing.baker.runtime.scaladsl. { EventInstance , IngredientInstance , InteractionInstance } import com.ing.baker.types. { CharArray , ListType , ListValue , PrimitiveValue } import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global val ReserveItemsInstance = InteractionInstance ( name = ReserveItems . name , input = Seq ( CharArray , ListType ( CharArray )) run = handleReserveItems ) def handleReserveItems ( input : Seq [ IngredientInstance ]) : Future [ Option [ EventInstance ]] = ??? // The body of this function is going to be executed by the Baker runtime when the ingredients are available. // ListValue and PrimitiveValue are used in the body Java import com.ing.baker.runtime.javadsl.InteractionInstance ; public class ReserveItems implements JWebshopRecipe . ReserveItems { // The body of this method is going to be executed by the Baker runtime when the ingredients are available. @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new JWebshopRecipe . ReserveItems . ItemsReserved ( items ); } } InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ());","title":"Implement Interactions"},{"location":"sections/development-life-cycle/implement-interactions/#implement-interactions","text":"After creating a recipe, and before we can even run processes from it, we need to create InteractionInstances that the Baker runtime will use to execute the real actions of your Recipe , these instances must match the Interactions in the Recipe , that means that the name and the input types must match. For the Scala DSL you need to create an object of InteractionImplementation , or use the reflection API in a similar way to the Java DSL. For the Java DSL you need to implement the interface with the apply method that you used for the Interaction in the Recipe and then use the InteractionImplementation.from(new Implementation()) reflection API, this will create a new InteractionImplementation that we will later on add to a baker runtime. Scala Reflection API import com.ing.baker.runtime.scaladsl.InteractionInstance import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } class ReserveItemsInstance extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] = { // Http call to the Warehouse service val response : Future [ Either [ List [ String ] , List [ String ]]] = // This is mocked for the sake of the example Future . successful ( Right ( items )) // Build an event instance that Baker understands response . map { case Left ( unavailableItems ) => WebshopRecipeReflection . OrderHadUnavailableItems ( unavailableItems ) case Right ( reservedItems ) => WebshopRecipeReflection . ItemsReserved ( reservedItems ) } } } val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) Scala import com.ing.baker.runtime.scaladsl. { EventInstance , IngredientInstance , InteractionInstance } import com.ing.baker.types. { CharArray , ListType , ListValue , PrimitiveValue } import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global val ReserveItemsInstance = InteractionInstance ( name = ReserveItems . name , input = Seq ( CharArray , ListType ( CharArray )) run = handleReserveItems ) def handleReserveItems ( input : Seq [ IngredientInstance ]) : Future [ Option [ EventInstance ]] = ??? // The body of this function is going to be executed by the Baker runtime when the ingredients are available. // ListValue and PrimitiveValue are used in the body Java import com.ing.baker.runtime.javadsl.InteractionInstance ; public class ReserveItems implements JWebshopRecipe . ReserveItems { // The body of this method is going to be executed by the Baker runtime when the ingredients are available. @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new JWebshopRecipe . ReserveItems . ItemsReserved ( items ); } } InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ());","title":"Implement Interactions"},{"location":"sections/development-life-cycle/monitor/","text":"Monitor To monitor a Baker application we recommend doing so by using the baker.registerEventListener(recipeName?, listenerFunction) and the baker.registerBakerEventListener(listenerFunction) . The former can notify of every EventInstance that is being fired globally or per CompiledRecipe . And the latter notifies of baker operations that happen like new InteractionInstances being executed or failing. These accept a function that can call your logging or metrics system: Scala (Recipe Events) baker . registerEventListener (( recipeInstanceId : String , event : EventInstance ) => { println ( s\"Recipe instance : $recipeInstanceId processed event ${ event . name } \" ) }) Java (Recipe Events) BiConsumer < String , EventInstance > handler = ( String recipeInstanceId , EventInstance event ) -> System . out . println ( \"Recipe Instance \" + recipeInstanceId + \" processed event \" + event . name ()); baker . registerEventListener ( handler ); Scala (Baker Events) import com.ing.baker.runtime.scaladsl._ baker . registerBakerEventListener (( event : BakerEvent ) => { event match { case e : EventReceived => println ( e ) case e : EventRejected => println ( e ) case e : InteractionFailed => println ( e ) case e : InteractionStarted => println ( e ) case e : InteractionCompleted => println ( e ) case e : ProcessCreated => println ( e ) case e : RecipeAdded => println ( e ) } }) Java (Baker Events) import com.ing.baker.runtime.javadsl.BakerEvent ; baker . registerBakerEventListener (( BakerEvent event ) -> System . out . println ( event ));","title":"Monitor"},{"location":"sections/development-life-cycle/monitor/#monitor","text":"To monitor a Baker application we recommend doing so by using the baker.registerEventListener(recipeName?, listenerFunction) and the baker.registerBakerEventListener(listenerFunction) . The former can notify of every EventInstance that is being fired globally or per CompiledRecipe . And the latter notifies of baker operations that happen like new InteractionInstances being executed or failing. These accept a function that can call your logging or metrics system: Scala (Recipe Events) baker . registerEventListener (( recipeInstanceId : String , event : EventInstance ) => { println ( s\"Recipe instance : $recipeInstanceId processed event ${ event . name } \" ) }) Java (Recipe Events) BiConsumer < String , EventInstance > handler = ( String recipeInstanceId , EventInstance event ) -> System . out . println ( \"Recipe Instance \" + recipeInstanceId + \" processed event \" + event . name ()); baker . registerEventListener ( handler ); Scala (Baker Events) import com.ing.baker.runtime.scaladsl._ baker . registerBakerEventListener (( event : BakerEvent ) => { event match { case e : EventReceived => println ( e ) case e : EventRejected => println ( e ) case e : InteractionFailed => println ( e ) case e : InteractionStarted => println ( e ) case e : InteractionCompleted => println ( e ) case e : ProcessCreated => println ( e ) case e : RecipeAdded => println ( e ) } }) Java (Baker Events) import com.ing.baker.runtime.javadsl.BakerEvent ; baker . registerBakerEventListener (( BakerEvent event ) -> System . out . println ( event ));","title":"Monitor"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/","text":"Resolve Failed Recipes Interaction Failure strategy When an interaction throws an exception there are a number of mitigation strategies: Block interaction This is the DEFAULT strategy if no default strategy is defined. This option is suitable for non idempotent interactions that cannot be retried. When an exception is thrown from the interaction the interaction is blocked . This means that the interaction cannot execute again automatically. Fire event This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( \"ValidateOrderFailed\" ) ) ) Retry with incremental back-off Incremental back-off allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The back-off factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis -> 200 millis -> 400 millis -> ... -> 100 seconds -> 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number. Retry exhaustion It can happen that after some time, when an interaction keeps failing, that the retry is exhausted. When this happens 2 things may happen. Either the interaction becomes [blocked(#blocked-interaction). Or if you configure so, the process continues with a predefined event: . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withFireRetryExhaustedEvent ( SomeEvent . class )) Note that this event class requires an empty constructor to be present and cannot provide ingredients. Default failure strategy You can also define a default failure strategy on the recipe level. This then serves as a fallback if none is defined for an interaction. For example: final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ()); baker.retryInteraction(recipeInstanceId, interactionName) It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception (and the FailureStrategy of the Interaction of the Recipe was set to block) or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways. This one involves forcing another try, resulting either on a successful continued process, or again on a failed state, to check this you will need to request the state of the RecipeInstance again. Note: this behaviour can be automatically preconfigured by using the RetryWithIncrementalBackoff FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" ); baker.resolveInteraction(recipeInstanceId, interactionName, event) It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways. This one involves resolving the interaction with a chosen EventInstance to replace the one that would have had been computed by the InteractionInstance . Note: this behaviour can be automatically preconfigured by using the FireEventAfterFailure(eventName) FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , ItemsReserved ( List ( \"item1\" ))) Java CompletableFuture < BoxedUnit > program = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , new ItemsReserved ( List ( \"item1\" ))); baker.stopRetryingInteraction(recipeInstanceId, interactionName) If an Interaction is configured with a RetryWithIncrementalBackoff FailureStrategy then it will not stop retrying until you call this API or a successful outcome happens from the InteractionInstance . Scala val program : Future [ Unit ] = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" );","title":"Resolve Failed Recipes"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#resolve-failed-recipes","text":"","title":"Resolve Failed Recipes"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#interaction-failure-strategy","text":"When an interaction throws an exception there are a number of mitigation strategies:","title":"Interaction Failure strategy"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#block-interaction","text":"This is the DEFAULT strategy if no default strategy is defined. This option is suitable for non idempotent interactions that cannot be retried. When an exception is thrown from the interaction the interaction is blocked . This means that the interaction cannot execute again automatically.","title":"Block interaction"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#fire-event","text":"This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( \"ValidateOrderFailed\" ) ) )","title":"Fire event"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#retry-with-incremental-back-off","text":"Incremental back-off allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The back-off factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis -> 200 millis -> 400 millis -> ... -> 100 seconds -> 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number. Retry exhaustion It can happen that after some time, when an interaction keeps failing, that the retry is exhausted. When this happens 2 things may happen. Either the interaction becomes [blocked(#blocked-interaction). Or if you configure so, the process continues with a predefined event: . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withFireRetryExhaustedEvent ( SomeEvent . class )) Note that this event class requires an empty constructor to be present and cannot provide ingredients.","title":"Retry with incremental back-off"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#default-failure-strategy","text":"You can also define a default failure strategy on the recipe level. This then serves as a fallback if none is defined for an interaction. For example: final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Default failure strategy"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#bakerretryinteractionrecipeinstanceid-interactionname","text":"It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception (and the FailureStrategy of the Interaction of the Recipe was set to block) or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways. This one involves forcing another try, resulting either on a successful continued process, or again on a failed state, to check this you will need to request the state of the RecipeInstance again. Note: this behaviour can be automatically preconfigured by using the RetryWithIncrementalBackoff FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" );","title":"baker.retryInteraction(recipeInstanceId, interactionName)"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#bakerresolveinteractionrecipeinstanceid-interactionname-event","text":"It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways. This one involves resolving the interaction with a chosen EventInstance to replace the one that would have had been computed by the InteractionInstance . Note: this behaviour can be automatically preconfigured by using the FireEventAfterFailure(eventName) FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , ItemsReserved ( List ( \"item1\" ))) Java CompletableFuture < BoxedUnit > program = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , new ItemsReserved ( List ( \"item1\" )));","title":"baker.resolveInteraction(recipeInstanceId, interactionName, event)"},{"location":"sections/development-life-cycle/resolve-failed-recipe-instances/#bakerstopretryinginteractionrecipeinstanceid-interactionname","text":"If an Interaction is configured with a RetryWithIncrementalBackoff FailureStrategy then it will not stop retrying until you call this API or a successful outcome happens from the InteractionInstance . Scala val program : Future [ Unit ] = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" );","title":"baker.stopRetryingInteraction(recipeInstanceId, interactionName)"},{"location":"sections/development-life-cycle/test/","text":"Test The Baker model already enforces separation and decoupling between parts of your system, which eases testability, it presents a model that divides units of code into modularized sections, more specifically, it provides a clear distinction between business logic and implementation through the Recipe and InteractionImplementations , and independence between Interactions , since every Interaction should only depend on the input. We present the layers of testing when using Baker, and how to write tests for such layers, use them as necessary. Testing Recipes for Soundness: Compiling the Recipe in a Test First, one important notice is that currently Baker does not check at compile time the soundness of your Recipe (if your Recipe makes any sense), but it does so when compiling it with the RecipeCompiler.compileRecipe(recipe) API. Errors are thrown in the form of exceptions describing the issue. So a simple unit test that simply compiles your Recipe is essential. Scala class WebshopRecipeSpec extends FlatSpec with Matchers { \"The WebshopRecipe\" should \"compile the recipe without errors\" in { RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) } } Java public class JWebshopRecipeTests { @Test public void shouldCompileTheRecipeWithoutIssues () { RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); } } Testing Recipes for Correctness: Mocking Interaction Implementations The next layer is to test that the Recipe actually does what you expect it to do at the business logic level independently of the underlying implementations. One way of doing so is by providing InteractionImplementations that behave as expected according to a testing scenario. On the next example we will: Create a new local instance of baker. Setup mocked interaction instances that behave according to your desired test scenario. Wire the recipe and implementations to fire sensory events according to your desired test scenario. Inspect the recipe instance state. Assert expectations on the state and/or the sensory event results. Note: Take into consideration the asynchronous nature of Baker, some times the easiest is to use fireAndResolveWhenCompleted that will resolve when a sensory event has completely finished affecting the state of the recipe instance. Scala /** Interface used to mock the ReserveItems interaction using the reflection API. */ trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } /** Mock of the ReserveItems interaction. */ class ReserveItemsMock extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] = Future . successful ( WebshopRecipeReflection . ItemsReserved ( items )) } \"The Webshop Recipe\" should \"reserve items in happy conditions\" in { val system : ActorSystem = ActorSystem ( \"baker-webshop-system\" ) val baker : Baker = AkkaBaker . localDefaul ( system ) val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val recipeInstanceId : String = UUID . randomUUID (). toString val orderId : String = \"order-id\" val items : List [ String ] = List ( \"item1\" , \"item2\" ) val orderPlaced = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( orderId , items )) val paymentMade = EventInstance . unsafeFrom ( WebshopRecipeReflection . PaymentMade ()) val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsMock ) for { _ <- baker . addInteractionInstace ( reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiled )) _ <- baker . bake ( recipeId , recipeInstanceId ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , orderPlaced ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade ) state <- baker . getRecipeInstanceState ( recipeInstanceId ) provided = state . ingredients . find ( _ . _1 == \"reservedItems\" ) . map ( _ . _2 . as [ List [ String ]]) . map ( _ . mkString ( \", \" )) . getOrElse ( \"No reserved items\" ) } yield provided shouldBe items . mkString ( \", \" ) } Java static public class HappyFlowReserveItems implements JWebshopRecipe . ReserveItems { @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new ItemsReserved ( items ); } } @Test public void shouldRunSimpleInstance () { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); EventInstance paymentMade = EventInstance . from ( new JWebshopRecipe . PaymentMade ()); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new HappyFlowReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstace ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade )) . thenCompose ( ignore -> baker . getRecipeInstanceState ( recipeInstanceId )) . thenApply ( x -> x . events (). stream (). map ( EventMoment :: getName ). collect ( Collectors . toList ())); List < String > blockedResult = result . join (); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"PaymentMade\" ) && blockedResult . contains ( \"ItemsReserved\" )); } This test is replicating a full round through a Recipe , the only difference with your normal production code is that InteractionInstances are adapted to fit the scenario you want to check, so the objective here is to test that the Recipe ends on the desired state given a certain order of firing sensory events and that the interaction instances return the specific data. Note: We recommend you abstract away these scenarios with a function that will run them given different interaction instances, so that you can run the same scenario on different environments, like when you want to do a E2E on a test environment. Mocking Interaction Implementations with Mockito Baker supports InteractionInstances that are mockito mocks, this will give you the added semantics of Mockito, like verifying that the interaction instance was called, or even called with the expected data. Scala trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } \"The Webshop Recipe\" should \"reserve items in happy conditions (mockito)\" in { val system : ActorSystem = ActorSystem ( \"baker-webshop-system\" ) val baker : Baker = AkkaBaker . localDefault ( system ) val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val recipeInstanceId : String = UUID . randomUUID (). toString val orderId : String = \"order-id\" val items : List [ String ] = List ( \"item1\" , \"item2\" ) val orderPlaced = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( orderId , items )) val paymentMade = EventInstance . unsafeFrom ( WebshopRecipeReflection . PaymentMade ()) // The ReserveItems interaction being mocked by Mockito val mockedReserveItems : ReserveItems = mock [ ReserveItems ] val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( mockedReserveItems ) when ( mockedReserveItems . apply ( orderId , items )) . thenReturn ( Future . successful ( WebshopRecipeReflection . ItemsReserved ( items ))) for { _ <- baker . addInteractionInstace ( reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiled )) _ <- baker . bake ( recipeId , recipeInstanceId ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , orderPlaced ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade ) state <- baker . getRecipeInstanceState ( recipeInstanceId ) provided = state . ingredients . find ( _ . _1 == \"reservedItems\" ) . map ( _ . _2 . as [ List [ String ]]) . map ( _ . mkString ( \", \" )) . getOrElse ( \"No reserved items\" ) // Verify that the mock was called with the expected data _ = verify ( mockedReserveItems ). apply ( orderId , items ) } yield provided shouldBe items . mkString ( \", \" ) } Java import static org.mockito.Mockito.* ; @Test public void shouldRunSimpleInstanceMockitoSample () { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); EventInstance paymentMade = EventInstance . from ( new JWebshopRecipe . PaymentMade ()); // The ReserveItems interaction being mocked by Mockito JWebshopRecipe . ReserveItems reserveItemsMock = mock ( JWebshopRecipe . ReserveItems . class ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( reserveItemsMock ); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); // Add input expectations and their returned event instances when ( reserveItemsMock . apply ( \"order-uuid\" , items )). thenReturn ( new JWebshopRecipe . ReserveItems . ItemsReserved ( items )); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstace ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade )) . thenCompose ( ignore -> baker . getRecipeInstanceState ( recipeInstanceId )) . thenApply ( x -> x . events (). stream (). map ( EventMoment :: getName ). collect ( Collectors . toList ())); List < String > blockedResult = result . join (); // Verify that the mock was called with the expected data verify ( reserveItemsMock ). apply ( \"order-uuid\" , items ); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"PaymentMade\" ) && blockedResult . contains ( \"ItemsReserved\" )); } Testing Individual Implementations The final layer is to individually test your implementations, which will resemble your normal e2e tests, interconnectivity tests, or unit tests which mock the dependencies. If we put a code example here it would be more of a tutorial on how to generally test code than Baker, which is a good argument to show that Baker si all about decoupling your code and automatically orchestrate it through distributed boundaries.","title":"Test"},{"location":"sections/development-life-cycle/test/#test","text":"The Baker model already enforces separation and decoupling between parts of your system, which eases testability, it presents a model that divides units of code into modularized sections, more specifically, it provides a clear distinction between business logic and implementation through the Recipe and InteractionImplementations , and independence between Interactions , since every Interaction should only depend on the input. We present the layers of testing when using Baker, and how to write tests for such layers, use them as necessary.","title":"Test"},{"location":"sections/development-life-cycle/test/#testing-recipes-for-soundness-compiling-the-recipe-in-a-test","text":"First, one important notice is that currently Baker does not check at compile time the soundness of your Recipe (if your Recipe makes any sense), but it does so when compiling it with the RecipeCompiler.compileRecipe(recipe) API. Errors are thrown in the form of exceptions describing the issue. So a simple unit test that simply compiles your Recipe is essential. Scala class WebshopRecipeSpec extends FlatSpec with Matchers { \"The WebshopRecipe\" should \"compile the recipe without errors\" in { RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) } } Java public class JWebshopRecipeTests { @Test public void shouldCompileTheRecipeWithoutIssues () { RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); } }","title":"Testing Recipes for Soundness: Compiling the Recipe in a Test"},{"location":"sections/development-life-cycle/test/#testing-recipes-for-correctness-mocking-interaction-implementations","text":"The next layer is to test that the Recipe actually does what you expect it to do at the business logic level independently of the underlying implementations. One way of doing so is by providing InteractionImplementations that behave as expected according to a testing scenario. On the next example we will: Create a new local instance of baker. Setup mocked interaction instances that behave according to your desired test scenario. Wire the recipe and implementations to fire sensory events according to your desired test scenario. Inspect the recipe instance state. Assert expectations on the state and/or the sensory event results. Note: Take into consideration the asynchronous nature of Baker, some times the easiest is to use fireAndResolveWhenCompleted that will resolve when a sensory event has completely finished affecting the state of the recipe instance. Scala /** Interface used to mock the ReserveItems interaction using the reflection API. */ trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } /** Mock of the ReserveItems interaction. */ class ReserveItemsMock extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] = Future . successful ( WebshopRecipeReflection . ItemsReserved ( items )) } \"The Webshop Recipe\" should \"reserve items in happy conditions\" in { val system : ActorSystem = ActorSystem ( \"baker-webshop-system\" ) val baker : Baker = AkkaBaker . localDefaul ( system ) val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val recipeInstanceId : String = UUID . randomUUID (). toString val orderId : String = \"order-id\" val items : List [ String ] = List ( \"item1\" , \"item2\" ) val orderPlaced = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( orderId , items )) val paymentMade = EventInstance . unsafeFrom ( WebshopRecipeReflection . PaymentMade ()) val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsMock ) for { _ <- baker . addInteractionInstace ( reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiled )) _ <- baker . bake ( recipeId , recipeInstanceId ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , orderPlaced ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade ) state <- baker . getRecipeInstanceState ( recipeInstanceId ) provided = state . ingredients . find ( _ . _1 == \"reservedItems\" ) . map ( _ . _2 . as [ List [ String ]]) . map ( _ . mkString ( \", \" )) . getOrElse ( \"No reserved items\" ) } yield provided shouldBe items . mkString ( \", \" ) } Java static public class HappyFlowReserveItems implements JWebshopRecipe . ReserveItems { @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new ItemsReserved ( items ); } } @Test public void shouldRunSimpleInstance () { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); EventInstance paymentMade = EventInstance . from ( new JWebshopRecipe . PaymentMade ()); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new HappyFlowReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstace ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade )) . thenCompose ( ignore -> baker . getRecipeInstanceState ( recipeInstanceId )) . thenApply ( x -> x . events (). stream (). map ( EventMoment :: getName ). collect ( Collectors . toList ())); List < String > blockedResult = result . join (); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"PaymentMade\" ) && blockedResult . contains ( \"ItemsReserved\" )); } This test is replicating a full round through a Recipe , the only difference with your normal production code is that InteractionInstances are adapted to fit the scenario you want to check, so the objective here is to test that the Recipe ends on the desired state given a certain order of firing sensory events and that the interaction instances return the specific data. Note: We recommend you abstract away these scenarios with a function that will run them given different interaction instances, so that you can run the same scenario on different environments, like when you want to do a E2E on a test environment.","title":"Testing Recipes for Correctness: Mocking Interaction Implementations"},{"location":"sections/development-life-cycle/test/#mocking-interaction-implementations-with-mockito","text":"Baker supports InteractionInstances that are mockito mocks, this will give you the added semantics of Mockito, like verifying that the interaction instance was called, or even called with the expected data. Scala trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } \"The Webshop Recipe\" should \"reserve items in happy conditions (mockito)\" in { val system : ActorSystem = ActorSystem ( \"baker-webshop-system\" ) val baker : Baker = AkkaBaker . localDefault ( system ) val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val recipeInstanceId : String = UUID . randomUUID (). toString val orderId : String = \"order-id\" val items : List [ String ] = List ( \"item1\" , \"item2\" ) val orderPlaced = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( orderId , items )) val paymentMade = EventInstance . unsafeFrom ( WebshopRecipeReflection . PaymentMade ()) // The ReserveItems interaction being mocked by Mockito val mockedReserveItems : ReserveItems = mock [ ReserveItems ] val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( mockedReserveItems ) when ( mockedReserveItems . apply ( orderId , items )) . thenReturn ( Future . successful ( WebshopRecipeReflection . ItemsReserved ( items ))) for { _ <- baker . addInteractionInstace ( reserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiled )) _ <- baker . bake ( recipeId , recipeInstanceId ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , orderPlaced ) _ <- baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade ) state <- baker . getRecipeInstanceState ( recipeInstanceId ) provided = state . ingredients . find ( _ . _1 == \"reservedItems\" ) . map ( _ . _2 . as [ List [ String ]]) . map ( _ . mkString ( \", \" )) . getOrElse ( \"No reserved items\" ) // Verify that the mock was called with the expected data _ = verify ( mockedReserveItems ). apply ( orderId , items ) } yield provided shouldBe items . mkString ( \", \" ) } Java import static org.mockito.Mockito.* ; @Test public void shouldRunSimpleInstanceMockitoSample () { ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); EventInstance paymentMade = EventInstance . from ( new JWebshopRecipe . PaymentMade ()); // The ReserveItems interaction being mocked by Mockito JWebshopRecipe . ReserveItems reserveItemsMock = mock ( JWebshopRecipe . ReserveItems . class ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( reserveItemsMock ); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); // Add input expectations and their returned event instances when ( reserveItemsMock . apply ( \"order-uuid\" , items )). thenReturn ( new JWebshopRecipe . ReserveItems . ItemsReserved ( items )); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstace ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade )) . thenCompose ( ignore -> baker . getRecipeInstanceState ( recipeInstanceId )) . thenApply ( x -> x . events (). stream (). map ( EventMoment :: getName ). collect ( Collectors . toList ())); List < String > blockedResult = result . join (); // Verify that the mock was called with the expected data verify ( reserveItemsMock ). apply ( \"order-uuid\" , items ); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"PaymentMade\" ) && blockedResult . contains ( \"ItemsReserved\" )); }","title":"Mocking Interaction Implementations with Mockito"},{"location":"sections/development-life-cycle/test/#testing-individual-implementations","text":"The final layer is to individually test your implementations, which will resemble your normal e2e tests, interconnectivity tests, or unit tests which mock the dependencies. If we put a code example here it would be more of a tutorial on how to generally test code than Baker, which is a good argument to show that Baker si all about decoupling your code and automatically orchestrate it through distributed boundaries.","title":"Testing Individual Implementations"},{"location":"sections/development-life-cycle/use-visualizations/","text":"Use Visualizations One of the first big advantages of creating Baker recipes is visualization. We have found that the visualization creates a great way to reason on very complex and big processes, and also they create a bridge between developers and business oriented people. You can generate one from a compiled recipe. Scala import com.ing.baker.il.CompiledRecipe import com.ing.baker.compiler.RecipeCompiler val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val visualization : String = compiled . getRecipeVisualization Java import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.compiler.RecipeCompiler ; CompiledRecipe recipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String visualization = recipe . getRecipeVisualization (); The visualization is a graphviz string that will look like this: digraph { node [fontname = \"ING Me\", fontsize = 22, fontcolor = white] pad = 0.2 ReserveItems [shape = rect, style = \"rounded, filled\", color = \"#525199\", penwidth = 2, margin = 0.5] reservedItems [shape = circle, style = filled, color = \"#FF6200\"] OrderHadUnavailableItems [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3] unavailableItems [shape = circle, style = filled, color = \"#FF6200\"] orderId [shape = circle, style = filled, color = \"#FF6200\"] OrderPlaced [shape = diamond, style = \"rounded, filled\", color = \"#767676\", fillcolor = \"#D5D5D5\", fontcolor = black, penwidth = 2, margin = 0.3] ReserveItems -> OrderHadUnavailableItems OrderHadUnavailableItems -> unavailableItems OrderPlaced -> items OrderPlaced -> orderId items -> ReserveItems ItemsReserved [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3] orderId -> ReserveItems items [shape = circle, style = filled, color = \"#FF6200\"] ReserveItems -> ItemsReserved ItemsReserved -> reservedItems } You can use tools like this web page to create an svg image. For example the visualization of the Webshop recipe that we designed on the last section looks like this: For complete documentation of how to configure the visualization, refer to this section .","title":"Use Visualizations"},{"location":"sections/development-life-cycle/use-visualizations/#use-visualizations","text":"One of the first big advantages of creating Baker recipes is visualization. We have found that the visualization creates a great way to reason on very complex and big processes, and also they create a bridge between developers and business oriented people. You can generate one from a compiled recipe. Scala import com.ing.baker.il.CompiledRecipe import com.ing.baker.compiler.RecipeCompiler val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val visualization : String = compiled . getRecipeVisualization Java import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.compiler.RecipeCompiler ; CompiledRecipe recipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String visualization = recipe . getRecipeVisualization (); The visualization is a graphviz string that will look like this: digraph { node [fontname = \"ING Me\", fontsize = 22, fontcolor = white] pad = 0.2 ReserveItems [shape = rect, style = \"rounded, filled\", color = \"#525199\", penwidth = 2, margin = 0.5] reservedItems [shape = circle, style = filled, color = \"#FF6200\"] OrderHadUnavailableItems [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3] unavailableItems [shape = circle, style = filled, color = \"#FF6200\"] orderId [shape = circle, style = filled, color = \"#FF6200\"] OrderPlaced [shape = diamond, style = \"rounded, filled\", color = \"#767676\", fillcolor = \"#D5D5D5\", fontcolor = black, penwidth = 2, margin = 0.3] ReserveItems -> OrderHadUnavailableItems OrderHadUnavailableItems -> unavailableItems OrderPlaced -> items OrderPlaced -> orderId items -> ReserveItems ItemsReserved [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3] orderId -> ReserveItems items [shape = circle, style = filled, color = \"#FF6200\"] ReserveItems -> ItemsReserved ItemsReserved -> reservedItems } You can use tools like this web page to create an svg image. For example the visualization of the Webshop recipe that we designed on the last section looks like this: For complete documentation of how to configure the visualization, refer to this section .","title":"Use Visualizations"},{"location":"sections/reference/baker-types-and-values/","text":"Baker Types and Values Because of the distributed nature of Baker and how the runtime works, we need to have serializable types and values to transfer recipes and data between nodes and to match over such data, that is why we implemented a type system on top of Scala. They help not just to model your domain but also for Baker to identify when to execute interactions. If you are using all of our reflection APIs then you will not use them directly, but it is good to know of their existence. Scala import com.ing.baker.types._ val data : ( Type , Value ) = ( Int32 , PrimitiveValue ( 42 )) Java import com.ing.baker.types.* ; Type dataType = Int32$ . MODULE$ ; Value dataValue = PrimitiveValue . apply ( 42 ); Types are specifically used to describe Ingredients , specifically Ingredients are just a relation between a name and a type. In a similar way that a programming language variable is just a relation between a name and a type at compile time, the baker Ingredient is a relation between a name and a Baker Type at \"recipe time\"; the same happens with values, in a programming language values must respect types otherwise runtime exceptions are thrown, similarly in Baker, at runtime the name of an ingredient will hold a value that respects the ingredient's type. Here is a complete list of Types and Values of Baker. Primitives Type Java parallel Description Bool boolean single bit, true or false , 1 or 0 Char char Unsigned 16 bit integer Byte byte Signed 8 bit integer Int16 short Signed 16 bit integer Int32 int Signed 32 bit integer Int64 long Signed 64 bit integer IntBig BigInteger Integer of arbitrary size Float32 float Signed 32 bit floating point Float64 double Signed 64 bit floating point FloatBig BigDecimal Floating point of arbitrary size Date long A UTC date in the ISO-8601 calendar system with millisecond precision ByteArray Array<Byte> Byte array, often used for binary data CharArray String Character array, or commmonly called String Structured types Type Java parallel Description ListType<T> java.util.List<T> A list of values, all of the same type OptionType<T> java.util.Optional<T> Matches against T or null EnumType enum class A set of predifined options (strings) RecordType POJO class A record with a specific set of fields MapType<T> java.util.Map<String, T> A record with arbitrary fields, all of the same type Values Values are pure data without any direct associated type. These very closely match the JSON data format. Value Description NullValue Analogues to null , Optional.empty , None , etc ... PrimitiveValue Wrapper for for: - A Java primitive (or boxed variant) - java.lang.String - java.math.BigInteger - java.math.BigDecimal - scala.math.BigInt - Array<Byte> ListValue A list of values RecordValue A set of String -> Value pairs Interoptability with java types Because it is impractical to directly work with the baker types in java/scala code there is conversion system. Default supported types java primitives and their boxed variants Enum types java.util.List java.util.Set java.util.Map java.math.BigInt java.math.BigDecimal java.util.Optional POJO classes scala primitives and their boxed variants case classes scala.collection.immutable.List scala.collection.immutable.Set scala.collection.immutable.Map BigInt BigDecimal scala.Option Registering a custom type adapter All default type adapters are registered in the reference.conf of the baker-types module. You can add your custom type adapter by registering it in a reference.conf . baker.types { \"com.example.MyCustomType\" = \"com.example.MyCustomTypeAdpater\" } For an example how to implement an adapter see here","title":"Baker Types and Values"},{"location":"sections/reference/baker-types-and-values/#baker-types-and-values","text":"Because of the distributed nature of Baker and how the runtime works, we need to have serializable types and values to transfer recipes and data between nodes and to match over such data, that is why we implemented a type system on top of Scala. They help not just to model your domain but also for Baker to identify when to execute interactions. If you are using all of our reflection APIs then you will not use them directly, but it is good to know of their existence. Scala import com.ing.baker.types._ val data : ( Type , Value ) = ( Int32 , PrimitiveValue ( 42 )) Java import com.ing.baker.types.* ; Type dataType = Int32$ . MODULE$ ; Value dataValue = PrimitiveValue . apply ( 42 ); Types are specifically used to describe Ingredients , specifically Ingredients are just a relation between a name and a type. In a similar way that a programming language variable is just a relation between a name and a type at compile time, the baker Ingredient is a relation between a name and a Baker Type at \"recipe time\"; the same happens with values, in a programming language values must respect types otherwise runtime exceptions are thrown, similarly in Baker, at runtime the name of an ingredient will hold a value that respects the ingredient's type. Here is a complete list of Types and Values of Baker.","title":"Baker Types and Values"},{"location":"sections/reference/baker-types-and-values/#primitives","text":"Type Java parallel Description Bool boolean single bit, true or false , 1 or 0 Char char Unsigned 16 bit integer Byte byte Signed 8 bit integer Int16 short Signed 16 bit integer Int32 int Signed 32 bit integer Int64 long Signed 64 bit integer IntBig BigInteger Integer of arbitrary size Float32 float Signed 32 bit floating point Float64 double Signed 64 bit floating point FloatBig BigDecimal Floating point of arbitrary size Date long A UTC date in the ISO-8601 calendar system with millisecond precision ByteArray Array<Byte> Byte array, often used for binary data CharArray String Character array, or commmonly called String","title":"Primitives"},{"location":"sections/reference/baker-types-and-values/#structured-types","text":"Type Java parallel Description ListType<T> java.util.List<T> A list of values, all of the same type OptionType<T> java.util.Optional<T> Matches against T or null EnumType enum class A set of predifined options (strings) RecordType POJO class A record with a specific set of fields MapType<T> java.util.Map<String, T> A record with arbitrary fields, all of the same type","title":"Structured types"},{"location":"sections/reference/baker-types-and-values/#values","text":"Values are pure data without any direct associated type. These very closely match the JSON data format. Value Description NullValue Analogues to null , Optional.empty , None , etc ... PrimitiveValue Wrapper for for: - A Java primitive (or boxed variant) - java.lang.String - java.math.BigInteger - java.math.BigDecimal - scala.math.BigInt - Array<Byte> ListValue A list of values RecordValue A set of String -> Value pairs","title":"Values"},{"location":"sections/reference/baker-types-and-values/#interoptability-with-java-types","text":"Because it is impractical to directly work with the baker types in java/scala code there is conversion system.","title":"Interoptability with java types"},{"location":"sections/reference/baker-types-and-values/#default-supported-types","text":"","title":"Default supported types"},{"location":"sections/reference/baker-types-and-values/#java","text":"primitives and their boxed variants Enum types java.util.List java.util.Set java.util.Map java.math.BigInt java.math.BigDecimal java.util.Optional POJO classes","title":"java"},{"location":"sections/reference/baker-types-and-values/#scala","text":"primitives and their boxed variants case classes scala.collection.immutable.List scala.collection.immutable.Set scala.collection.immutable.Map BigInt BigDecimal scala.Option","title":"scala"},{"location":"sections/reference/baker-types-and-values/#registering-a-custom-type-adapter","text":"All default type adapters are registered in the reference.conf of the baker-types module. You can add your custom type adapter by registering it in a reference.conf . baker.types { \"com.example.MyCustomType\" = \"com.example.MyCustomTypeAdpater\" } For an example how to implement an adapter see here","title":"Registering a custom type adapter"},{"location":"sections/reference/dsls/","text":"Recipe DSLs Conceptually a Recipe allows you to declaratively describe your business process and is a \"blueprint\" that can be used to start a RecipeInstance on the runtime. To create such \"blueprint\" you need to use either the Java or Scala DSLs, there a Recipe is just a data structure that bundles Events , Interactions and some execution configuration like firing limits or error handling mechanics. Note: Ingredients are indirectly added to the Recipe because they come inside Events . These data structures are just that, data, and to ease their construction and improve the user experience of the library we provide an API that uses Java and Scala reflection to generate most of the data from language constructions like case classes or interfaces. Scala import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilDeadline import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } import scala.concurrent.duration._ object WebshopRecipe { val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Events . OrderPlaced , Events . PaymentMade ) . withInteractions ( Interactions . ReserveItems . withRequiredEvent ( Events . PaymentMade )) . withDefaultFailureStrategy ( RetryWithIncrementalBackoff . builder () . withInitialDelay ( 100 milliseconds ) . withUntil ( Some ( UntilDeadline ( 24 hours ))) . withMaxTimeBetweenRetries ( Some ( 10 minutes )) . build ()) object Ingredients { val OrderId : Ingredient [ String ] = Ingredient [ String ]( \"orderId\" ) val Items : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"items\" ) val ReservedItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"reservedItems\" ) val UnavailableItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"unavailableItems\" ) } object Events { val OrderPlaced : Event = Event ( name = \"OrderPlaced\" , providedIngredients = Seq ( Ingredients . OrderId , Ingredients . Items ), maxFiringLimit = Some ( 1 ) ) val PaymentMade : Event = Event ( name = \"PaymentMade\" , providedIngredients = Seq . empty , maxFiringLimit = Some ( 1 ) ) val OrderHadUnavailableItems : Event = Event ( name = \"OrderHadUnavailableItems\" , providedIngredients = Seq ( Ingredients . UnavailableItems ), maxFiringLimit = Some ( 1 ) ) val ItemsReserved : Event = Event ( name = \"ItemsReserved\" , providedIngredients = Seq ( Ingredients . ReservedItems ), maxFiringLimit = Some ( 1 ) ) } object Interactions { val ReserveItems : Interaction = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredients . OrderId , Ingredients . Items , ), output = Seq ( Events . OrderHadUnavailableItems , Events . ItemsReserved ) ) } } Scala (Reflection API) import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilDeadline import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } import scala.concurrent.duration._ object WebshopRecipeReflection { case class OrderPlaced ( orderId : String , items : List [ String ]) case class PaymentMade () sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput val ReserveItems = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) ) val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Event [ OrderPlaced ], Event [ PaymentMade ]) . withInteractions ( ReserveItems . withRequiredEvent ( Event [ PaymentMade ])) . withDefaultFailureStrategy ( RetryWithIncrementalBackoff . builder () . withInitialDelay ( 100 milliseconds ) . withUntil ( Some ( UntilDeadline ( 24 hours ))) . withMaxTimeBetweenRetries ( Some ( 10 minutes )) . build ()) } Java (Reflection API) import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.InteractionFailureStrategy.RetryWithIncrementalBackoffBuilder ; import com.ing.baker.recipe.javadsl.Interaction ; import com.ing.baker.recipe.javadsl.Recipe ; import java.time.Duration ; import java.util.List ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } public static class PaymentMade {} public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class , PaymentMade . class ) . withInteractions ( of ( ReserveItems . class ) . withRequiredEvent ( PaymentMade . class )) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ()); } Events Events are simple POJO classes. For example: Scala case class CustomerInfoReceived ( customerInfo : CustomerInfo ) Java public class CustomerInfoReceived { public final CustomerInfo customerInfo ; public CustomerInfoReceived ( CustomerInfo customerInfo ) { this . customerInfo = customerInfo ; } } The field types of the POJO class must be compatible with the baker type system. See the supported types for more information. The names of the fields are obtained using reflection. They can be added using the .withSensoryEvents(..) method. Firing limit A firing limit is a limit on the number of times a sensory event may be received by a recipe instance . By default sensory events have a firing limit of 1 per process instance. This means the event will be rejected with status FiringLimitMet after the first time it is received. If you want to send an event more then once you may add it like this: . withSensoryEventsNoFiringLimit ( CustomerInfoReceived . class ) In this example the CustomerInfoReceived can now be received multiple times by a process instance. Interactions Interactions are interfaces with some requirements. See here how to define them. You can include interactions in your recipe using the static of(..) method. import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withInteractions ( of ( ValidateOrder . class ) ) There are a number of options to tailor an interaction for your recipe. Maximum interaction count By default there is no limit on the number of times an Interaction may fire. Sometimes you may want to set a limit. For example, to ensure the goods are shipped only once. . withInteractions ( of ( ShipGoods . class ). withMaximumInteractionCount ( 1 ) ) Predefining ingredients An interaction normally requires all its input ingredients to be provided from Events . Sometimes however it is useful to predefine (or hard code ) the value of an ingredient. For example: An email template An application/requester id when calling an external system This can be done by: . withInteractions ( of ( SendEmail . class ) . withPredefinedIngredient ( \"emailTemplate\" , \"Welcome to ING!\" ) ) Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call. Each time all remaining ingredients are provided, the interaction will fire. You can not predefine ALL input ingredients of an interaction. Event renames Sometimes it useful to rename an interaction event and/or its ingredients to fit better in the context of your recipe. For example, to rename the GoodsManufactured event and its ingredient. . withInteractions ( of ( ManufactureGoods . class ) . withEventTransformation ( GoodsManufactured . class , \"ManufacturingDone\" , ImmutableMap . of ( \"goods\" , \"manufacturedGoods\" ) ) ) ) Event requirements As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions. However, sometimes data requirements are not enough. For example, you might want to be sure to only send an invoice ( SendInvoice ) AFTER the goods where shipped ( GoodsShipped ). of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ) In this case the GoodsShipped event MUST happen before the interaction may execute. You can specify multiple events in a single clause. These are bundled with an AND condition, meaning ALL events in the clause are required. You can also require a single event from a number of options. of ( SendInvoice . class ) . withRequiredOneOfEvents ( EventA . class , EventB . class ) In this case the interaction may fire if either EventA OR EventB has occured. Interaction Failure strategy When an interaction throws an exception there are a number of mitigation strategies: Block interaction This is the DEFAULT strategy if no other is defined and no default strategy is defined. This option is suitable for non idempotent interactions that cannot be retried. When an exception is thrown from the interaction the interaction is blocked . This means that the interaction cannot execute again automatically. It requires manual intervening to continue the process from then on. Fire event This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( \"ValidateOrderFailed\" ) ) ) Retry with incremental backoff Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The backoff factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis -> 200 millis -> 400 millis -> ... -> 100 seconds -> 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number. Retry exhaustion It can happen that after some time, when an interaction keeps failing, that the retry is exhausted. When this happens 2 things may happen. Either the interaction becomes [blocked(#blocked-interaction). Or if you configure so, the process continues with a predefined event: . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withFireRetryExhaustedEvent ( SomeEvent . class )) Note that this event class requires an empty constructor to be present and cannot provide ingredients. Default failure strategy You can also define a default failure strategy on the recipe level. This then serves as a fallback if none is defined for an interaction. For example: final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Recipe DSLs"},{"location":"sections/reference/dsls/#recipe-dsls","text":"Conceptually a Recipe allows you to declaratively describe your business process and is a \"blueprint\" that can be used to start a RecipeInstance on the runtime. To create such \"blueprint\" you need to use either the Java or Scala DSLs, there a Recipe is just a data structure that bundles Events , Interactions and some execution configuration like firing limits or error handling mechanics. Note: Ingredients are indirectly added to the Recipe because they come inside Events . These data structures are just that, data, and to ease their construction and improve the user experience of the library we provide an API that uses Java and Scala reflection to generate most of the data from language constructions like case classes or interfaces. Scala import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilDeadline import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } import scala.concurrent.duration._ object WebshopRecipe { val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Events . OrderPlaced , Events . PaymentMade ) . withInteractions ( Interactions . ReserveItems . withRequiredEvent ( Events . PaymentMade )) . withDefaultFailureStrategy ( RetryWithIncrementalBackoff . builder () . withInitialDelay ( 100 milliseconds ) . withUntil ( Some ( UntilDeadline ( 24 hours ))) . withMaxTimeBetweenRetries ( Some ( 10 minutes )) . build ()) object Ingredients { val OrderId : Ingredient [ String ] = Ingredient [ String ]( \"orderId\" ) val Items : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"items\" ) val ReservedItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"reservedItems\" ) val UnavailableItems : Ingredient [ List [ String ]] = Ingredient [ List [ String ]]( \"unavailableItems\" ) } object Events { val OrderPlaced : Event = Event ( name = \"OrderPlaced\" , providedIngredients = Seq ( Ingredients . OrderId , Ingredients . Items ), maxFiringLimit = Some ( 1 ) ) val PaymentMade : Event = Event ( name = \"PaymentMade\" , providedIngredients = Seq . empty , maxFiringLimit = Some ( 1 ) ) val OrderHadUnavailableItems : Event = Event ( name = \"OrderHadUnavailableItems\" , providedIngredients = Seq ( Ingredients . UnavailableItems ), maxFiringLimit = Some ( 1 ) ) val ItemsReserved : Event = Event ( name = \"ItemsReserved\" , providedIngredients = Seq ( Ingredients . ReservedItems ), maxFiringLimit = Some ( 1 ) ) } object Interactions { val ReserveItems : Interaction = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredients . OrderId , Ingredients . Items , ), output = Seq ( Events . OrderHadUnavailableItems , Events . ItemsReserved ) ) } } Scala (Reflection API) import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff import com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilDeadline import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } import scala.concurrent.duration._ object WebshopRecipeReflection { case class OrderPlaced ( orderId : String , items : List [ String ]) case class PaymentMade () sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput val ReserveItems = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) ) val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Event [ OrderPlaced ], Event [ PaymentMade ]) . withInteractions ( ReserveItems . withRequiredEvent ( Event [ PaymentMade ])) . withDefaultFailureStrategy ( RetryWithIncrementalBackoff . builder () . withInitialDelay ( 100 milliseconds ) . withUntil ( Some ( UntilDeadline ( 24 hours ))) . withMaxTimeBetweenRetries ( Some ( 10 minutes )) . build ()) } Java (Reflection API) import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.InteractionFailureStrategy.RetryWithIncrementalBackoffBuilder ; import com.ing.baker.recipe.javadsl.Interaction ; import com.ing.baker.recipe.javadsl.Recipe ; import java.time.Duration ; import java.util.List ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } public static class PaymentMade {} public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class , PaymentMade . class ) . withInteractions ( of ( ReserveItems . class ) . withRequiredEvent ( PaymentMade . class )) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ()); }","title":"Recipe DSLs"},{"location":"sections/reference/dsls/#events","text":"Events are simple POJO classes. For example: Scala case class CustomerInfoReceived ( customerInfo : CustomerInfo ) Java public class CustomerInfoReceived { public final CustomerInfo customerInfo ; public CustomerInfoReceived ( CustomerInfo customerInfo ) { this . customerInfo = customerInfo ; } } The field types of the POJO class must be compatible with the baker type system. See the supported types for more information. The names of the fields are obtained using reflection. They can be added using the .withSensoryEvents(..) method.","title":"Events"},{"location":"sections/reference/dsls/#firing-limit","text":"A firing limit is a limit on the number of times a sensory event may be received by a recipe instance . By default sensory events have a firing limit of 1 per process instance. This means the event will be rejected with status FiringLimitMet after the first time it is received. If you want to send an event more then once you may add it like this: . withSensoryEventsNoFiringLimit ( CustomerInfoReceived . class ) In this example the CustomerInfoReceived can now be received multiple times by a process instance.","title":"Firing limit"},{"location":"sections/reference/dsls/#interactions","text":"Interactions are interfaces with some requirements. See here how to define them. You can include interactions in your recipe using the static of(..) method. import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withInteractions ( of ( ValidateOrder . class ) ) There are a number of options to tailor an interaction for your recipe.","title":"Interactions"},{"location":"sections/reference/dsls/#maximum-interaction-count","text":"By default there is no limit on the number of times an Interaction may fire. Sometimes you may want to set a limit. For example, to ensure the goods are shipped only once. . withInteractions ( of ( ShipGoods . class ). withMaximumInteractionCount ( 1 ) )","title":"Maximum interaction count"},{"location":"sections/reference/dsls/#predefining-ingredients","text":"An interaction normally requires all its input ingredients to be provided from Events . Sometimes however it is useful to predefine (or hard code ) the value of an ingredient. For example: An email template An application/requester id when calling an external system This can be done by: . withInteractions ( of ( SendEmail . class ) . withPredefinedIngredient ( \"emailTemplate\" , \"Welcome to ING!\" ) ) Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call. Each time all remaining ingredients are provided, the interaction will fire. You can not predefine ALL input ingredients of an interaction.","title":"Predefining ingredients"},{"location":"sections/reference/dsls/#event-renames","text":"Sometimes it useful to rename an interaction event and/or its ingredients to fit better in the context of your recipe. For example, to rename the GoodsManufactured event and its ingredient. . withInteractions ( of ( ManufactureGoods . class ) . withEventTransformation ( GoodsManufactured . class , \"ManufacturingDone\" , ImmutableMap . of ( \"goods\" , \"manufacturedGoods\" ) ) ) )","title":"Event renames"},{"location":"sections/reference/dsls/#event-requirements","text":"As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions. However, sometimes data requirements are not enough. For example, you might want to be sure to only send an invoice ( SendInvoice ) AFTER the goods where shipped ( GoodsShipped ). of ( SendInvoice . class ) . withRequiredEvents ( ShipGoods . GoodsShipped . class ) In this case the GoodsShipped event MUST happen before the interaction may execute. You can specify multiple events in a single clause. These are bundled with an AND condition, meaning ALL events in the clause are required. You can also require a single event from a number of options. of ( SendInvoice . class ) . withRequiredOneOfEvents ( EventA . class , EventB . class ) In this case the interaction may fire if either EventA OR EventB has occured.","title":"Event requirements"},{"location":"sections/reference/dsls/#interaction-failure-strategy","text":"When an interaction throws an exception there are a number of mitigation strategies:","title":"Interaction Failure strategy"},{"location":"sections/reference/dsls/#block-interaction","text":"This is the DEFAULT strategy if no other is defined and no default strategy is defined. This option is suitable for non idempotent interactions that cannot be retried. When an exception is thrown from the interaction the interaction is blocked . This means that the interaction cannot execute again automatically. It requires manual intervening to continue the process from then on.","title":"Block interaction"},{"location":"sections/reference/dsls/#fire-event","text":"This option is analagous to a try { } catch { } in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues. Example: . withInteractions ( of ( ValidateOrder . class ) . withInteractionFailureStrategy ( InteractionFailureStrategy . FireEvent ( \"ValidateOrderFailed\" ) ) )","title":"Fire event"},{"location":"sections/reference/dsls/#retry-with-incremental-backoff","text":"Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover. . withInteractions ( of ( ValidateOrder . class ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withBackoffFactor ( 2.0 ) . withMaxTimeBetweenRetries ( Duration . ofSeconds ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . build ()) ) What do these parameters mean? name meaning initialDelay The delay for the first retry. backoffFactor The backoff factor for the delay (optional, default = 2 ) maxTimeBetweenRetries The maximum interval between retries. deadLine The maximum total amount of time spend delaying. For our example this results in the following delay pattern: 100 millis -> 200 millis -> 400 millis -> ... -> 100 seconds -> 100 seconds Which can be visualized like this: Note that these delays do not include interaction execution time. For example, if the first retry execution takes 5 seconds (and fails again) then the second retry will be triggered after (from the start): (100 millis + 5 seconds + 200 millis) = 5.3 seconds This also means that the 24 hour deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number. Retry exhaustion It can happen that after some time, when an interaction keeps failing, that the retry is exhausted. When this happens 2 things may happen. Either the interaction becomes [blocked(#blocked-interaction). Or if you configure so, the process continues with a predefined event: . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withFireRetryExhaustedEvent ( SomeEvent . class )) Note that this event class requires an empty constructor to be present and cannot provide ingredients.","title":"Retry with incremental backoff"},{"location":"sections/reference/dsls/#default-failure-strategy","text":"You can also define a default failure strategy on the recipe level. This then serves as a fallback if none is defined for an interaction. For example: final Recipe webshopRecipe = new Recipe ( \"webshop\" ) . withDefaultFailureStrategy ( new RetryWithIncrementalBackoffBuilder () . withInitialDelay ( Duration . ofMillis ( 100 )) . withDeadline ( Duration . ofHours ( 24 )) . withMaxTimeBetweenRetries ( Duration . ofMinutes ( 10 )) . build ());","title":"Default failure strategy"},{"location":"sections/reference/event-listener/","text":"Event Listener After creating a baker runtime you can attach functions that will be called once EventInstances are fired or when different baker occurrences happen: baker.registerEventListener(recipeName, listenerFunction) Registers a listener to all runtime events for on a baker instance. Note that: - The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests Scala Java BiConsumer < String , EventInstance > handler = ( String recipeInstanceId , EventInstance event ) -> System . out . println ( \"Recipe Instance \" + recipeInstanceId + \" processed event \" + event . name ()); baker . registerEventListener ( handler ); baker.registerBakerEventListener(listenerFunction) Registers a listener to all runtime BAKER events, these are events that notify what Baker is doing, like RecipeInstances received EventInstances or CompiledRecipes being added to baker. Note that: The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: logging metrics unit tests Scala import com.ing.baker.runtime.scaladsl._ baker . registerBakerEventListener (( event : BakerEvent ) => { event match { case e : EventReceived => println ( e ) case e : EventRejected => println ( e ) case e : InteractionFailed => println ( e ) case e : InteractionStarted => println ( e ) case e : InteractionCompleted => println ( e ) case e : ProcessCreated => println ( e ) case e : RecipeAdded => println ( e ) } }) Java import com.ing.baker.runtime.javadsl.BakerEvent ; baker . registerBakerEventListener (( BakerEvent event ) -> System . out . println ( event ));","title":"Event Listener"},{"location":"sections/reference/event-listener/#event-listener","text":"After creating a baker runtime you can attach functions that will be called once EventInstances are fired or when different baker occurrences happen:","title":"Event Listener"},{"location":"sections/reference/event-listener/#bakerregistereventlistenerrecipename-listenerfunction","text":"Registers a listener to all runtime events for on a baker instance. Note that: - The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests Scala Java BiConsumer < String , EventInstance > handler = ( String recipeInstanceId , EventInstance event ) -> System . out . println ( \"Recipe Instance \" + recipeInstanceId + \" processed event \" + event . name ()); baker . registerEventListener ( handler );","title":"baker.registerEventListener(recipeName, listenerFunction)"},{"location":"sections/reference/event-listener/#bakerregisterbakereventlistenerlistenerfunction","text":"Registers a listener to all runtime BAKER events, these are events that notify what Baker is doing, like RecipeInstances received EventInstances or CompiledRecipes being added to baker. Note that: The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: logging metrics unit tests Scala import com.ing.baker.runtime.scaladsl._ baker . registerBakerEventListener (( event : BakerEvent ) => { event match { case e : EventReceived => println ( e ) case e : EventRejected => println ( e ) case e : InteractionFailed => println ( e ) case e : InteractionStarted => println ( e ) case e : InteractionCompleted => println ( e ) case e : ProcessCreated => println ( e ) case e : RecipeAdded => println ( e ) } }) Java import com.ing.baker.runtime.javadsl.BakerEvent ; baker . registerBakerEventListener (( BakerEvent event ) -> System . out . println ( event ));","title":"baker.registerBakerEventListener(listenerFunction)"},{"location":"sections/reference/execution-semantics/","text":"Execution Semantics Execution loop This is a short description of the execution loop of a RecipeInstance An EventInstance is fired and provides ingredients, either given to baker as a sensory event or as an output of an InteractionInstance . Baker tries to match the currently available provided IngredientInstances with the input of awaiting InteractionInstances . InteractionInstances that can be called, execute and when complete they fire more EventInstances , repeating the loop from step 1. This continues until there are no more InteractionInstances to execute, and the process is considered complete. Notes A sensory event may be provided 1 or more times depending on its firing limit . When IngredientInstances are provided multiple times, the latest value overrides the previous. An InteractionInstance fires when all it's IngredientInstances and required Events are provided. This may happen 1 or more times depending on the maximum interaction count . In depth This section explains deeply how ProcessInstances work, and how they execute your recipes. You don't have to understand this part to develop with Baker. It is just extra documentation for the curious and the contributors. A recipe can be represented (and visualized ) as a graph, which is actually a higher level representation of a Petri net (which is also a graph). When the process is represented as such it enables the RecipeInstance to execute the previously described execution loop, because Baker has your process state as a data structure that can be preserved as the state of the RecipeInstance . That is why you need to first use the RecipeCompiler and compile the recipe into a CompiledRecipe (petri net representation) before running a RecipeInstance from it. Translation rules The compiler has some rules about translating recipe parts to transitions and places in the petri net. Ingredient used by multiple interactions Often an ingredient will be used by multiple interactions in a recipe. Because tokens can only be consumed by one transition we have to add a layer to duplicate the token for all transitions. Interaction with precondition (AND) By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction. Interaction with precondition (OR) Events that are grouped in an OR combinator for an interaction output a token to the same place. Therefor when one of them fires the condition for the transition to fire is met. Sensory event with firing limit When specifying a sensory event with a firing limit of n we generate an in-adjacent place with n tokens in the initial marking.","title":"Execution Semantics"},{"location":"sections/reference/execution-semantics/#execution-semantics","text":"","title":"Execution Semantics"},{"location":"sections/reference/execution-semantics/#execution-loop","text":"This is a short description of the execution loop of a RecipeInstance An EventInstance is fired and provides ingredients, either given to baker as a sensory event or as an output of an InteractionInstance . Baker tries to match the currently available provided IngredientInstances with the input of awaiting InteractionInstances . InteractionInstances that can be called, execute and when complete they fire more EventInstances , repeating the loop from step 1. This continues until there are no more InteractionInstances to execute, and the process is considered complete.","title":"Execution loop"},{"location":"sections/reference/execution-semantics/#notes","text":"A sensory event may be provided 1 or more times depending on its firing limit . When IngredientInstances are provided multiple times, the latest value overrides the previous. An InteractionInstance fires when all it's IngredientInstances and required Events are provided. This may happen 1 or more times depending on the maximum interaction count .","title":"Notes"},{"location":"sections/reference/execution-semantics/#in-depth","text":"This section explains deeply how ProcessInstances work, and how they execute your recipes. You don't have to understand this part to develop with Baker. It is just extra documentation for the curious and the contributors. A recipe can be represented (and visualized ) as a graph, which is actually a higher level representation of a Petri net (which is also a graph). When the process is represented as such it enables the RecipeInstance to execute the previously described execution loop, because Baker has your process state as a data structure that can be preserved as the state of the RecipeInstance . That is why you need to first use the RecipeCompiler and compile the recipe into a CompiledRecipe (petri net representation) before running a RecipeInstance from it.","title":"In depth"},{"location":"sections/reference/execution-semantics/#translation-rules","text":"The compiler has some rules about translating recipe parts to transitions and places in the petri net.","title":"Translation rules"},{"location":"sections/reference/execution-semantics/#ingredient-used-by-multiple-interactions","text":"Often an ingredient will be used by multiple interactions in a recipe. Because tokens can only be consumed by one transition we have to add a layer to duplicate the token for all transitions.","title":"Ingredient used by multiple interactions"},{"location":"sections/reference/execution-semantics/#interaction-with-precondition-and","text":"By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction.","title":"Interaction with precondition (AND)"},{"location":"sections/reference/execution-semantics/#interaction-with-precondition-or","text":"Events that are grouped in an OR combinator for an interaction output a token to the same place. Therefor when one of them fires the condition for the transition to fire is met.","title":"Interaction with precondition (OR)"},{"location":"sections/reference/execution-semantics/#sensory-event-with-firing-limit","text":"When specifying a sensory event with a firing limit of n we generate an in-adjacent place with n tokens in the initial marking.","title":"Sensory event with firing limit"},{"location":"sections/reference/main-abstractions/","text":"Main Abstractions Baker makes a strong division between the specification of your business process and the runtime implementations. Specification Runtime Type Value Ingredient IngredientInstance Event EventInstance Interaction InteractionInstance Recipe RecipeInstance The first four are used to create Recipe s which serve as \"blueprints\" of your process. In the Baker runtime they are used within RecipeInstance s, which are created from a Recipe specification to execute the flow of your process. Type and Value Because of the distributed nature of Baker and how the runtime works, we need to have serializable types and values to transfer recipes and data between nodes and to match over such data, that is why we implemented a type system on top of Scala. They help not just to model your domain, but also for Baker to identify when to execute interactions. If you are using all of our reflection APIs then you will not use them directly, but it is good to know of their existence. Full documentation about the type system can be found here . Scala import com.ing.baker.types._ val data : ( Type , Value ) = ( Int32 , PrimitiveValue ( 42 )) Java import com.ing.baker.types.* ; Type dataType = Int32$ . MODULE$ ; Value dataValue = PrimitiveValue . apply ( 42 ); Ingredient and IngredientInstance Ingredients are containers for the data in your process. This data is immutable , which means that it can only be created and never changes in the process. There is no subtyping , nor hierarchy. Ingredients are carried through your process with Events , and are inputs for Interactions . For a Recipe there exist Ingredients which are a name and a Type , they are used to model the data of your process. For a RecipeInstance there exist IngredientInstance s, which are a name and a Value , they are used to move data through your process. Scala import com.ing.baker.recipe.scaladsl.Ingredient val OrderId : Ingredient [ String ] = Ingredient [ String ]( \"orderId\" ) import com.ing.baker.runtime.scaladsl.IngredientInstance val orderIdInstance : IngredientInstance = IngredientInstance ( \"orderId\" , PrimitiveValue ( \"uuid-123456789\" )) Java // In Java, Ingredients are extracted from a class // representing an Event by using java reflection. // See the full example at the \"Recipe and RecipeInstance\" section Event and EventInstance Events represent happenings in your process that might carry Ingredients , they represent an \"asynchronous boundary\", they are always either output from Interactions or a special case called SensoryEvent s; we call sensory events to the events that come from \"outside\" of your recipe and are normally used to start your process. For a Recipe there exist Events which are a name, a set of Ingredients and a maximum amount of firings; the maxFiringLimit is a property which describes the number of times an event is allowed to fire, this is later on enforced by the Baker runtime. To know more about firing limits and all the other configurable properties, please refer to the DSLs documentation . For a RecipeInstance there exist EventInstance s which are data structures that must match their interface equivalent declared as Events on the Recipe . They notify a baker RecipeInstance of an actual happening and may carry Ingredient values; the baker RecipeInstance will then use available Ingredients to execute InteractionInstance s. Note: Names of sensory Event and EventInstance must match, so that Baker can correctly execute your process flow. Scala /** Event */ import com.ing.baker.recipe.scaladsl.Event import com.ing.baker.recipe.scaladsl.Ingredient val OrderPlaced : Event = Event ( name = \"OrderPlaced\" , providedIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), maxFiringLimit = Some ( 1 ) ) /** EventInstance */ import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.types. { PrimitiveValue , ListValue } val firstOrderPlaced : EventInstance = EventInstance ( name = \"OrderPlaced\" , providedIngredients = Map ( \"orderId\" -> PrimitiveValue ( \"uuid-0123456789\" ), \"items\" -> ListValue ( List ( PrimitiveValue ( \"item1-id\" ), PrimitiveValue ( \"item2-id\" ))) ) ) Java // In Java, Events and EventInstances are extracted from a // class by using java reflection. // Please check the full recipe example below on the // Recipe and RecipeInstance subsection import com.ing.baker.runtime.javadsl.EventInstance ; public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); OrderPlaced order1 = new OrderPlaced ( \"uuid-0123456789\" , items ); EventInstance order1Event = EventInstance . from ( order1 ); To fire a SensoryEvent use the bakerRuntime.fireEvent(recipeInstanceId, event) API variations, after creating the baker runtime, adding your recipe to the runtime and baking a RecipeInstance . For full documentation on this please refer to the runtime documentation . Scala import akka.actor.ActorSystem import com.ing.baker.runtime.common.EventResult import com.ing.baker.runtime.scaladsl. { Baker , EventInstance } import scala.concurrent.Future implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) // This example is using the reflection API `EventInstance.unsafeFrom` val FirstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( OrderPlaced ( \"order-uuid\" , List ( \"item1\" , \"item2\" ))) val recipeInstanceId : String = \"recipe id from previously baked recipe instance\" val result : Future [ EventResult ] = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , FirstOrderPlaced ) Java import akka.actor.ActorSystem ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.EventInstance ; import com.ing.baker.runtime.javadsl.EventResult ; import java.util.concurrent.CompletableFuture ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); String recipeInstanceId = \"recipe id from previously baked recipe instance\" ; List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); CompletableFuture < EventResult > result = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced ); Interaction and InteractionInstance An interaction resemblance a function, it requires input ( Ingredients ) and provides output ( Events ). Within this contract it may do anything. For example: Query a microservice Send messages to an event broker like Kafka Await for a message from an event broker Generate a file Do transformations on the ingredients (we like to call these interactions Sieves ) For a Recipe there exist Interactions which are a name, a sequence of Ingredients describing all the input (all of), and a sequence of Events describing the possible event outputs (one of). At the recipe level there are several more specifics that can be configured, like requiring events without ingredients, adding predefined ingredients, overriding ingredient names, or handling unexpected failure, for these please refer to the DSLs documentation . For a RecipeInstance there exist InteractionInstance s which are a name, an input type description, and an implementation of a method/function that will be called when the interaction is executed. The input name and the input type description is used by the Baker runtime to find the correct InteractionImplementation to execute when the Ingredients are available. Note: Names of sensory Event and EventInstance must match, so that Baker can correctly execute your process flow. Note: For asynchronous programming, the Scala DSL InteractionInstance can return a Future[A] and the Java DSL can return a CompletableFuture<A> , and the Baker runtime will handle the async results of the instances. Scala /** Interaction */ import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction } val ReserveItems : Interaction = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Events . OrderHadUnavailableItems , Events . ItemsReserved ) ) /** InteractionInstance */ import com.ing.baker.runtime.scaladsl. { EventInstance , IngredientInstance , InteractionInstance } import com.ing.baker.types. { CharArray , ListType , ListValue , PrimitiveValue } import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global val ReserveItemsInstance = InteractionInstance ( name = ReserveItems . name , input = Seq ( CharArray , ListType ( CharArray )) run = handleReserveItems ) def handleReserveItems ( input : Seq [ IngredientInstance ]) : Future [ Option [ EventInstance ]] = ??? // ListValue and PrimitiveValue are used in the body Java /** Interaction */ import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.Interaction ; public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } // Annotations are needed for wiring ingredients and validating events. @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) // The name of the method must be \"apply\" for the reflection API to work. // This method can also return a `CompletableFuture<ReserveItemsOutcome>` for asynchronous programming. ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } /** InteractionInstance */ import com.ing.baker.runtime.javadsl.InteractionInstance ; public class ReserveItems implements JWebshopRecipe . ReserveItems { @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new JWebshopRecipe . ReserveItems . ItemsReserved ( items ); } } Scala (Reflection API) // See the DSLs documentation for more on the reflection API trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } class ReserveItemsInstance extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] = { // Http call to the Warehouse service val response : Future [ Either [ List [ String ] , List [ String ]]] = // This is mocked for the sake of the example Future . successful ( Right ( items )) // Build an event instance that Baker understands response . map { case Left ( unavailableItems ) => WebshopRecipeReflection . OrderHadUnavailableItems ( unavailableItems ) case Right ( reservedItems ) => WebshopRecipeReflection . ItemsReserved ( reservedItems ) } } } val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) After creating your InteractionInstance s, you need to add them to the baker runtime so that Baker can match them to the Interactions of your Recipe and call them when needed. Scala import akka.actor.ActorSystem import com.ing.baker.runtime.scaladsl.Baker import scala.concurrent.Future val done : Future [ Unit ] = baker . addInteractionInstance ( reserveItemsInstance ) Java import akka.actor.ActorSystem ; import com.ing.baker.runtime.akka.AkkaBaker ; import scala.runtime.BoxedUnit ; import java.util.concurrent.CompletableFuture ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); CompletableFuture < BoxedUnit > done = baker . addInteractionInstance ( reserveItemsInstance ); Recipe and RecipeInstance All you Ingredients , Events and Interactions must be added to a single unit called the Recipe , which works as the \"blueprint\" of your precess. Scala import com.ing.baker.recipe.scaladsl.Recipe val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Events . OrderPlaced ) . withInteractions ( Interactions . ReserveItems , ) Scala Full Example package webshop import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } object WebshopRecipeReflection { case class OrderPlaced ( orderId : String , items : List [ String ]) sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput val ReserveItems = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) ) val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Event [ OrderPlaced ], Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) . withInteractions ( ReserveItems ) } Java import com.ing.baker.recipe.javadsl.Recipe ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); Java Full Example package webshop ; import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.Interaction ; import com.ing.baker.recipe.javadsl.Recipe ; import java.util.List ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); } A recipe must be added to a baker runtime so that you can create \"bake\" a RecipeInstance from it. For that it must be first \"compiled\" by using the provided compiler. Here is a full example of creating a baker runtime, adding the InteractionInstances and the compiled Recipe (order matters becase baker validates that all recipes have valid implementations when added), and firing an Event that will execute the Interaction Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstances . ReserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) _ <- baker . bake ( recipeId , \"first-instance-id\" ) firstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( \"order-uuid\" , List ( \"item1\" , \"item2\" ))) result <- baker . fireEventAndResolveWhenCompleted ( \"first-instance-id\" , firstOrderPlaced ) } yield assert ( result . events == Seq ( WebshopRecipe . Events . OrderPlaced . name , WebshopRecipe . Events . ItemsReserved . name )) Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.EventInstance ; import com.ing.baker.runtime.javadsl.EventResult ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.ArrayList ; import java.util.List ; import java.util.concurrent.CompletableFuture ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenApply ( EventResult :: events ); List < String > blockedResult = result . join (); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"ReservedItems\" ));","title":"Main Abstractions"},{"location":"sections/reference/main-abstractions/#main-abstractions","text":"Baker makes a strong division between the specification of your business process and the runtime implementations. Specification Runtime Type Value Ingredient IngredientInstance Event EventInstance Interaction InteractionInstance Recipe RecipeInstance The first four are used to create Recipe s which serve as \"blueprints\" of your process. In the Baker runtime they are used within RecipeInstance s, which are created from a Recipe specification to execute the flow of your process.","title":"Main Abstractions"},{"location":"sections/reference/main-abstractions/#type-and-value","text":"Because of the distributed nature of Baker and how the runtime works, we need to have serializable types and values to transfer recipes and data between nodes and to match over such data, that is why we implemented a type system on top of Scala. They help not just to model your domain, but also for Baker to identify when to execute interactions. If you are using all of our reflection APIs then you will not use them directly, but it is good to know of their existence. Full documentation about the type system can be found here . Scala import com.ing.baker.types._ val data : ( Type , Value ) = ( Int32 , PrimitiveValue ( 42 )) Java import com.ing.baker.types.* ; Type dataType = Int32$ . MODULE$ ; Value dataValue = PrimitiveValue . apply ( 42 );","title":"Type and Value"},{"location":"sections/reference/main-abstractions/#ingredient-and-ingredientinstance","text":"Ingredients are containers for the data in your process. This data is immutable , which means that it can only be created and never changes in the process. There is no subtyping , nor hierarchy. Ingredients are carried through your process with Events , and are inputs for Interactions . For a Recipe there exist Ingredients which are a name and a Type , they are used to model the data of your process. For a RecipeInstance there exist IngredientInstance s, which are a name and a Value , they are used to move data through your process. Scala import com.ing.baker.recipe.scaladsl.Ingredient val OrderId : Ingredient [ String ] = Ingredient [ String ]( \"orderId\" ) import com.ing.baker.runtime.scaladsl.IngredientInstance val orderIdInstance : IngredientInstance = IngredientInstance ( \"orderId\" , PrimitiveValue ( \"uuid-123456789\" )) Java // In Java, Ingredients are extracted from a class // representing an Event by using java reflection. // See the full example at the \"Recipe and RecipeInstance\" section","title":"Ingredient and IngredientInstance"},{"location":"sections/reference/main-abstractions/#event-and-eventinstance","text":"Events represent happenings in your process that might carry Ingredients , they represent an \"asynchronous boundary\", they are always either output from Interactions or a special case called SensoryEvent s; we call sensory events to the events that come from \"outside\" of your recipe and are normally used to start your process. For a Recipe there exist Events which are a name, a set of Ingredients and a maximum amount of firings; the maxFiringLimit is a property which describes the number of times an event is allowed to fire, this is later on enforced by the Baker runtime. To know more about firing limits and all the other configurable properties, please refer to the DSLs documentation . For a RecipeInstance there exist EventInstance s which are data structures that must match their interface equivalent declared as Events on the Recipe . They notify a baker RecipeInstance of an actual happening and may carry Ingredient values; the baker RecipeInstance will then use available Ingredients to execute InteractionInstance s. Note: Names of sensory Event and EventInstance must match, so that Baker can correctly execute your process flow. Scala /** Event */ import com.ing.baker.recipe.scaladsl.Event import com.ing.baker.recipe.scaladsl.Ingredient val OrderPlaced : Event = Event ( name = \"OrderPlaced\" , providedIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), maxFiringLimit = Some ( 1 ) ) /** EventInstance */ import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.types. { PrimitiveValue , ListValue } val firstOrderPlaced : EventInstance = EventInstance ( name = \"OrderPlaced\" , providedIngredients = Map ( \"orderId\" -> PrimitiveValue ( \"uuid-0123456789\" ), \"items\" -> ListValue ( List ( PrimitiveValue ( \"item1-id\" ), PrimitiveValue ( \"item2-id\" ))) ) ) Java // In Java, Events and EventInstances are extracted from a // class by using java reflection. // Please check the full recipe example below on the // Recipe and RecipeInstance subsection import com.ing.baker.runtime.javadsl.EventInstance ; public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); OrderPlaced order1 = new OrderPlaced ( \"uuid-0123456789\" , items ); EventInstance order1Event = EventInstance . from ( order1 ); To fire a SensoryEvent use the bakerRuntime.fireEvent(recipeInstanceId, event) API variations, after creating the baker runtime, adding your recipe to the runtime and baking a RecipeInstance . For full documentation on this please refer to the runtime documentation . Scala import akka.actor.ActorSystem import com.ing.baker.runtime.common.EventResult import com.ing.baker.runtime.scaladsl. { Baker , EventInstance } import scala.concurrent.Future implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) // This example is using the reflection API `EventInstance.unsafeFrom` val FirstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( OrderPlaced ( \"order-uuid\" , List ( \"item1\" , \"item2\" ))) val recipeInstanceId : String = \"recipe id from previously baked recipe instance\" val result : Future [ EventResult ] = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , FirstOrderPlaced ) Java import akka.actor.ActorSystem ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.EventInstance ; import com.ing.baker.runtime.javadsl.EventResult ; import java.util.concurrent.CompletableFuture ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); String recipeInstanceId = \"recipe id from previously baked recipe instance\" ; List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); CompletableFuture < EventResult > result = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced );","title":"Event and EventInstance"},{"location":"sections/reference/main-abstractions/#interaction-and-interactioninstance","text":"An interaction resemblance a function, it requires input ( Ingredients ) and provides output ( Events ). Within this contract it may do anything. For example: Query a microservice Send messages to an event broker like Kafka Await for a message from an event broker Generate a file Do transformations on the ingredients (we like to call these interactions Sieves ) For a Recipe there exist Interactions which are a name, a sequence of Ingredients describing all the input (all of), and a sequence of Events describing the possible event outputs (one of). At the recipe level there are several more specifics that can be configured, like requiring events without ingredients, adding predefined ingredients, overriding ingredient names, or handling unexpected failure, for these please refer to the DSLs documentation . For a RecipeInstance there exist InteractionInstance s which are a name, an input type description, and an implementation of a method/function that will be called when the interaction is executed. The input name and the input type description is used by the Baker runtime to find the correct InteractionImplementation to execute when the Ingredients are available. Note: Names of sensory Event and EventInstance must match, so that Baker can correctly execute your process flow. Note: For asynchronous programming, the Scala DSL InteractionInstance can return a Future[A] and the Java DSL can return a CompletableFuture<A> , and the Baker runtime will handle the async results of the instances. Scala /** Interaction */ import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction } val ReserveItems : Interaction = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Events . OrderHadUnavailableItems , Events . ItemsReserved ) ) /** InteractionInstance */ import com.ing.baker.runtime.scaladsl. { EventInstance , IngredientInstance , InteractionInstance } import com.ing.baker.types. { CharArray , ListType , ListValue , PrimitiveValue } import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global val ReserveItemsInstance = InteractionInstance ( name = ReserveItems . name , input = Seq ( CharArray , ListType ( CharArray )) run = handleReserveItems ) def handleReserveItems ( input : Seq [ IngredientInstance ]) : Future [ Option [ EventInstance ]] = ??? // ListValue and PrimitiveValue are used in the body Java /** Interaction */ import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.Interaction ; public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } // Annotations are needed for wiring ingredients and validating events. @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) // The name of the method must be \"apply\" for the reflection API to work. // This method can also return a `CompletableFuture<ReserveItemsOutcome>` for asynchronous programming. ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } /** InteractionInstance */ import com.ing.baker.runtime.javadsl.InteractionInstance ; public class ReserveItems implements JWebshopRecipe . ReserveItems { @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new JWebshopRecipe . ReserveItems . ItemsReserved ( items ); } } Scala (Reflection API) // See the DSLs documentation for more on the reflection API trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] } class ReserveItemsInstance extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ WebshopRecipeReflection.ReserveItemsOutput ] = { // Http call to the Warehouse service val response : Future [ Either [ List [ String ] , List [ String ]]] = // This is mocked for the sake of the example Future . successful ( Right ( items )) // Build an event instance that Baker understands response . map { case Left ( unavailableItems ) => WebshopRecipeReflection . OrderHadUnavailableItems ( unavailableItems ) case Right ( reservedItems ) => WebshopRecipeReflection . ItemsReserved ( reservedItems ) } } } val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) After creating your InteractionInstance s, you need to add them to the baker runtime so that Baker can match them to the Interactions of your Recipe and call them when needed. Scala import akka.actor.ActorSystem import com.ing.baker.runtime.scaladsl.Baker import scala.concurrent.Future val done : Future [ Unit ] = baker . addInteractionInstance ( reserveItemsInstance ) Java import akka.actor.ActorSystem ; import com.ing.baker.runtime.akka.AkkaBaker ; import scala.runtime.BoxedUnit ; import java.util.concurrent.CompletableFuture ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); CompletableFuture < BoxedUnit > done = baker . addInteractionInstance ( reserveItemsInstance );","title":"Interaction and InteractionInstance"},{"location":"sections/reference/main-abstractions/#recipe-and-recipeinstance","text":"All you Ingredients , Events and Interactions must be added to a single unit called the Recipe , which works as the \"blueprint\" of your precess. Scala import com.ing.baker.recipe.scaladsl.Recipe val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Events . OrderPlaced ) . withInteractions ( Interactions . ReserveItems , ) Scala Full Example package webshop import com.ing.baker.recipe.scaladsl. { Event , Ingredient , Interaction , Recipe } object WebshopRecipeReflection { case class OrderPlaced ( orderId : String , items : List [ String ]) sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput val ReserveItems = Interaction ( name = \"ReserveItems\" , inputIngredients = Seq ( Ingredient [ String ]( \"orderId\" ), Ingredient [ List [ String ]]( \"items\" ) ), output = Seq ( Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) ) val recipe : Recipe = Recipe ( \"Webshop\" ) . withSensoryEvents ( Event [ OrderPlaced ], Event [ OrderHadUnavailableItems ], Event [ ItemsReserved ] ) . withInteractions ( ReserveItems ) } Java import com.ing.baker.recipe.javadsl.Recipe ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); Java Full Example package webshop ; import com.ing.baker.recipe.annotations.FiresEvent ; import com.ing.baker.recipe.annotations.RequiresIngredient ; import com.ing.baker.recipe.javadsl.Interaction ; import com.ing.baker.recipe.javadsl.Recipe ; import java.util.List ; import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of ; public class JWebshopRecipe { public static class OrderPlaced { public final String orderId ; public final List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } public interface ReserveItems extends Interaction { interface ReserveItemsOutcome { } class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } public final static Recipe recipe = new Recipe ( \"WebshopRecipe\" ) . withSensoryEvents ( OrderPlaced . class ) . withInteractions ( of ( ReserveItems . class )); } A recipe must be added to a baker runtime so that you can create \"bake\" a RecipeInstance from it. For that it must be first \"compiled\" by using the provided compiler. Here is a full example of creating a baker runtime, adding the InteractionInstances and the compiled Recipe (order matters becase baker validates that all recipes have valid implementations when added), and firing an Event that will execute the Interaction Scala import akka.actor.ActorSystem import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe import com.ing.baker.runtime.scaladsl.EventInstance import com.ing.baker.runtime.akka.AkkaBaker implicit val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( WebshopInstances . ReserveItemsInstance ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) _ <- baker . bake ( recipeId , \"first-instance-id\" ) firstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( WebshopRecipeReflection . OrderPlaced ( \"order-uuid\" , List ( \"item1\" , \"item2\" ))) result <- baker . fireEventAndResolveWhenCompleted ( \"first-instance-id\" , firstOrderPlaced ) } yield assert ( result . events == Seq ( WebshopRecipe . Events . OrderPlaced . name , WebshopRecipe . Events . ItemsReserved . name )) Java import akka.actor.ActorSystem ; import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.runtime.akka.AkkaBaker ; import com.ing.baker.runtime.javadsl.EventInstance ; import com.ing.baker.runtime.javadsl.EventResult ; import com.ing.baker.runtime.javadsl.InteractionInstance ; import java.util.ArrayList ; import java.util.List ; import java.util.concurrent.CompletableFuture ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); List < String > items = new ArrayList <> ( 2 ); items . add ( \"item1\" ); items . add ( \"item2\" ); EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String recipeInstanceId = \"first-instance-id\" ; CompletableFuture < List < String >> result = baker . addInteractionInstance ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )) . thenCompose ( ignore -> baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced )) . thenApply ( EventResult :: events ); List < String > blockedResult = result . join (); assert ( blockedResult . contains ( \"OrderPlaced\" ) && blockedResult . contains ( \"ReservedItems\" ));","title":"Recipe and RecipeInstance"},{"location":"sections/reference/runtime/","text":"The Akka Based Runtime Baker.akka(config, actorSystem) Baker provider several constructors to build a runtime to run your Recipes on. The current implementations are o Akka based, one in local mode, and another in cluster mode. Note: We recommend reviewing also Akka configuration. Scala import akka.actor.ActorSystem import com.ing.baker.runtime.scaladsl.Baker import com.typesafe.config. { Config , ConfigFactory } val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val config : Config = ConfigFactory . load () val baker : Baker = Baker . akka ( config , actorSystem ) Java import akka.actor.ActorSystem ; import com.ing.baker.runtime.javadsl.Baker ; import com.typesafe.config.Config ; import com.typesafe.config.ConfigFactory ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Config config = ConfigFactory . load (); Baker baker = Baker . akka ( config , actorSystem ); This last code snippet will build a Baker runtime and load all configuration from your default application.conf located in the resources directory. You can see more about configuration on this section . Alternatively there is a constructor that will provide the default configuration for a local mode Baker, this is recommended for tests. Scala val baker : Baker = AkkaBaker . localDefault ( actorSystem ) Java Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); Advantages of the Cluster Mode The capabilities gained when in cluster mode are: Elasticity: by adding/removing nodes to the cluster. Resilience: RecipeInstances are automatically restored in a new node when the hosting node fails. (For this you need to configure a distributed data store like Cassandra) Routing: You can fire EventInstances from anywhere on the cluster, and Baker will ensure that the corresponding RecipeInstance receives the firing event. Note: To run on cluster mode you need to configure a distributed data store, we highly recommend using Cassandra. InteractionInstance.from(object) (Reflection API) As part of our efforts to ease the creation of InteractionInstances we created this function that uses the Scala and the Java reflection capabilities to create an InteractionInstance from an instance of a class. The name of the InteractionInstance will be taken from the name of the implementing interface (Java) or trait (Scala) (it must match the name of the Interaction at the Recipe ). The interface MUST declare a public method called apply , and the types must match those of the expected provided ingredients. Notice that his function might throw an exception if the instance is not correctly done (this is why in Scala the API is named \"unsafe\"). Scala import com.ing.baker.runtime.scaladsl.InteractionInstance import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ ReserveItemsOutput ] } class ReserveItemsInstance extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ ReserveItemsOutput ] = { // Http call to the Warehouse service val response : Future [ Either [ List [ String ] , List [ String ]]] = // This is mocked for the sake of the example Future . successful ( Right ( items )) // Build an event instance that Baker understands response . map { case Left ( unavailableItems ) => OrderHadUnavailableItems ( unavailableItems ) case Right ( reservedItems ) => ItemsReserved ( reservedItems ) } } } val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) Java import com.ing.baker.runtime.javadsl.InteractionInstance ; import com.ing.baker.runtime.javadsl.Interaction ; /** Java interface used for the Recipe */ public interface ReserveItems extends Interaction { interface ReserveItemsOutcome {} class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } /** Implementation of the interface used for creating an InteractionInstance */ public class ReserveItems implements JWebshopRecipe . ReserveItems { // The body of this method is going to be executed by the Baker runtime when the ingredients are available. @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new ReserveItems . ItemsReserved ( items ); } } /** Create an InteractionInstance from an instance of the ReserveItems implementation */ InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); baker.addInteractionInstance(interactionInstance) The Baker runtime requires you to add all InteractionInstances before adding any related CompiledRecipes . This can be done using the baker.addInteractionInstance(interactionInstance) or the baker.addInteractionInstances(intance1, instance2, ...) APIs. Note: in Java the api returns a CompletableFuture<BoxedUnit> , this is because the API is implemented in Scala, so Scala's Unit get translated to BoxedUnit , but you should you ignore it and consider it as good as Java's void , except it comes in a CompletableFuture that will help you handle async programming. Scala val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItems ()) val result : Future [ Unit ] = baker . addInteractionInstance ( reserveItemsInstance ) Java Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompletableFuture < BoxedUnit > = baker . addInteractionInstance ( reserveItemsInstance ); RecipeCompiler.compile(recipe) Recipes once built must be converted into a data structure called CompiledRecipe that lets RecipeInstances to understand, store and run your process. These can be used to create a new RecipeInstance from a baker runtime that contains both a CompiledRecipe and the required InteractionInstances , or they can as well be converted into a visualziation . Scala import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( recipe ) Java import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe ); baker.addRecipe(RecipeRecord.of(compiledRecipe)) Once Recipes have been transformed into CompiledRecipes they must be added to a baker runtime. The baker.addRecipe(RecipeRecord.of(compiledRecipe)) API will do so and return an id that you can use to reference the added recipe later on. Note: Before doing this, baker requires you to add all related InteractionInstances to the runtime, this is because baker does validation to ensure that every recipe is runnable from the previously added InteractionInstances . Java val recipeId Future [ String ] = baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) Java CompletableFuture < String > recipeId = baker . addRecipe ( RecipeRecord . of ( compiledRecipe )); baker.getAllRecipes() The baker at runtime can give you a map of all the currently available recipes that has been previously added to Baker. Scala import com.ing.baker.runtime.scaladsl.RecipeInformation import scala.concurrent.Future val allRecipes : Future [ Map [ String , RecipeInformation ]] = baker . getAllRecipes Java import com.ing.baker.runtime.javadsl.RecipeInformation ; import java.util.concurrent.CompletableFuture ; import java.util.Map ; CompletableFuture < Map < String , RecipeInformation >> allRecipe = baker . getAllRecipes (); baker.bake(recipeId, recipeInstanceId) Once the Baker runtime contains a CompiledRecipe and all the associated InteractionInstances then you can use the baker.bake(recipeId, recipeInstanceId) API to create a RecipeInstance that will contain the state of your process and execute any InteractionInstance as soon as all its required InteractionIngredients are available. Note: This API requires you to choose a recipeInstanceId , the API does not provide one for you, this is so that you can manage this reference as required. Note: in Java the api returns a CompletableFuture<BoxedUnit> , this is because the API is implemented in Scala, so Scala's Unit get translated to BoxedUnit , but you should you ignore it and consider it as good as Java's void , except it comes in a CompletableFuture that will help you handle async programming. Scala val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( interactionInstances ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) recipeInstanceId = \"my-id\" _ <- baker . bake ( recipeId , recipeInstanceId ) } yield () Java String recipeInstanceId = \"my-id\" ; CompletableFuture < BoxedUnit > result = baker . addInteractionInstace ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId )); EventInstance.from(object) As part of our efforts to ease the creation of EventInstances , we added a function that uses Java and Scala reflection to create EventInstances from class objects. The name of the EventInstance will be taken from the name of the class (Java) or case class (Scala) (it must match the name of the Event at the Recipe ). And the argument names and types of the constructors will be translated to IngredientInstances with corresponding names and baker types. Notice that this function might throw an exception if the event is not correctly done (this is why in Scala the API is named \"unsafe\"). Scala import com.ing.baker.runtime.scaladsl.EventInstance case class OrderPlaced ( orderId : String , items : List [ String ]) val firstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( OrderPlaced ( \"order-id\" , List ( \"item1\" , \"item2\" ))) Java import com.ing.baker.runtime.javadsl.EventInstance ; class OrderPlaced { String orderId ; List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items )); baker.fireEvent(recipeInstanceId, eventInstance) After creation of a RecipeInstance , you use one of the variations of baker.fireEvent(recipeInstanceId, eventInstance) to fire your EventInstances and start/continue the process flow. There are several supported semantics for firing an event which depend on the moment you want to get notified and continue your asynchronous computation, these are the 4 different moments: When the event got accepted by the RecipeInstance but has not started cascading the execution of InteractionInstances . For this use the Baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance) API. This will return a Future[SensoryEventStatus] enum notifying of the outcome (the event might get rejected). When the event got accepted by the RecipeInstance and has finished cascading the execution of InteractionInstances up to the point that it requires more EventInstances ( SensoryEvents ) to continue, or the process has finished. For this use the Baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance) API. This will return a Future[EventResult] object containing a SensoryEventStatus , the Event names that got fired in consequence of this SensoryEvent , and the current available Ingredients output of the InteractionInstances that got executed as consequence of the SensoryEvent . You want to do something on both of the previously mentioned moments, then use the Baker.fireEvent(recipeInstanceId, eventInstance) API, which will return an EventResolutions object which contains both Future[SensoryEventStatus] and Future[EventResult] (or its CompletableFuture<A> equivalents in Java). As soon as an intermediate Event fires from one of the InteractionInstances that execute as consequence of the fired SensoryEvent . For this use the Baker.fireEventAndResolveOnEvent(recipeInstanceId, eventInstance, onEventName) API. This will return a similar Future[EventResult to the one returned by Baker.fireEventAndResolveWhenCompleted except the data will be up to the moment the onEventName was fired. correlationId Optionally you may provide a correlation id when firing a EventInstance . The purpose of this identifier is idempotent event delivery: when sending the same event correlation id multiple times, only the first will be processed. This can be applied to the OrderPlaced event for example. Scala val correlationOrderId = \"a unique order id\" for { statusA <- baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ) _ = assert ( statusA == Received ) statusB <- baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ) _ = assert ( statusB == AlreadyReceived ) } yield () Java String correlationOrderId = \"a unique order id\" ; SensoryEventStatus statusA = baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ); . join (); assert ( statusA == Received ); SensoryEventStatus statusB = baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ); . join (); assert ( statusB == AlreadyReceived ); SensoryEventStatus Status Description Received The event was received normally AlreadyReceived An event with the same correlation id was already received ProcessDeleted The process instance was deleted ReceivePeriodExpired The receive period for the process instance has passed FiringLimitMet The firing limit for the event was met baker.getRecipeInstanceState(recipeInstanceId) baker.getInteractionInstanceState(recipeInstanceId) will return an InteractionInstanceState object which contains all the event names with timestamps that have executed, and the current available provided ingredient data. Scala import com.ing.baker.runtime.scaladsl.RecipeInstanceState val state : Future [ RecipeInstanceState ] = baker . getRecipeInstanceState ( recipeInstanceId ) Java import com.ing.baker.runtime.javadsl.RecipeInstanceState ; CompletableFuture < RecipeInstanceState > state = baker . getRecipeInstanceState ( recipeInstanceId ); baker.getAllInteractionInstancesMetadata() Returns the recipeId, recipeInstanceId and creation timestamp of all running RecipeInstances . Note: Can potentially return a partial result when baker runs in cluster mode because not all shards might be reached within the given timeout. Note: Does not include deleted RecipeInstances . baker.getVisualState(recipeInstanceId, style) Another method of fetching state is the visual representation of it. You can do that with the Baker.getVisualState(recipeInstanceId) API. This will return a GraphViz string like the visualization api that you can convert into an image. Here is a visualization of the state of another webshop example, one can clearly see that the process is flowing correctly without failures and that it is still waiting for the payment sensory event to be fired. Scala val state : Future [ String ] = baker . getVisualState ( recipeInstanceId ) Java CompletableFuture < String > state = baker . getVisualState ( recipeInstanceId ); baker.registerEventListener(recipeName, listenerFunction) Registers a listener to all runtime events for this baker instance. Note that: - The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests Scala baker . registerEventListener (( recipeInstanceId : String , event : EventInstance ) => { println ( s\"Recipe instance : $recipeInstanceId processed event ${ event . name } \" ) }) Java BiConsumer < String , EventInstance > handler = ( String recipeInstanceId , EventInstance event ) -> System . out . println ( \"Recipe Instance \" + recipeInstanceId + \" processed event \" + event . name ()); baker . registerEventListener ( handler ); baker.registerBakerEventListener(listenerFunction) Registers a listener to all runtime BAKER events, these are events that notify what Baker is doing, like RecipeInstances received EventInstances or CompiledRecipes being added to baker. Note that: - The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests Scala import com.ing.baker.runtime.scaladsl._ baker . registerBakerEventListener (( event : BakerEvent ) => { event match { case e : EventReceived => println ( e ) case e : EventRejected => println ( e ) case e : InteractionFailed => println ( e ) case e : InteractionStarted => println ( e ) case e : InteractionCompleted => println ( e ) case e : ProcessCreated => println ( e ) case e : RecipeAdded => println ( e ) } }) Java import com.ing.baker.runtime.javadsl.BakerEvent ; baker . registerBakerEventListener (( BakerEvent event ) -> System . out . println ( event )); baker.retryInteraction(recipeInstanceId, interactionName) It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception (and the FailureStrategy of the Interaction of the Recipe was set to block) or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways. This one involves forcing another try, resulting either on a successful continued process, or again on a failed state, to check this you will need to request the state of the RecipeInstance again. Note: this behaviour can be automatically preconfigured by using the RetryWithIncrementalBackoff FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" ); baker.resolveInteraction(recipeInstanceId, interactionName, event) It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in two ways. This one involves resolving the interaction with a chosen EventInstance to replace the one that would have had been computed by the InteractionInstance . Note: this behaviour can be automatically preconfigured by using the FireEventAfterFailure(eventName) FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , ItemsReserved ( List ( \"item1\" ))) Java CompletableFuture < BoxedUnit > program = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , new ItemsReserved ( List ( \"item1\" ))); baker.stopRetryingInteraction(recipeInstanceId, interactionName) If an Interaction is configured with a RetryWithIncrementalBackoff FailureStrategy then it will not stop retrying until you call this API or a successful outcome happens from the InteractionInstance . Scala val program : Future [ Unit ] = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" );","title":"The Akka Based Runtime"},{"location":"sections/reference/runtime/#the-akka-based-runtime","text":"","title":"The Akka Based Runtime"},{"location":"sections/reference/runtime/#bakerakkaconfig-actorsystem","text":"Baker provider several constructors to build a runtime to run your Recipes on. The current implementations are o Akka based, one in local mode, and another in cluster mode. Note: We recommend reviewing also Akka configuration. Scala import akka.actor.ActorSystem import com.ing.baker.runtime.scaladsl.Baker import com.typesafe.config. { Config , ConfigFactory } val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val config : Config = ConfigFactory . load () val baker : Baker = Baker . akka ( config , actorSystem ) Java import akka.actor.ActorSystem ; import com.ing.baker.runtime.javadsl.Baker ; import com.typesafe.config.Config ; import com.typesafe.config.ConfigFactory ; ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Config config = ConfigFactory . load (); Baker baker = Baker . akka ( config , actorSystem ); This last code snippet will build a Baker runtime and load all configuration from your default application.conf located in the resources directory. You can see more about configuration on this section . Alternatively there is a constructor that will provide the default configuration for a local mode Baker, this is recommended for tests. Scala val baker : Baker = AkkaBaker . localDefault ( actorSystem ) Java Baker baker = AkkaBaker . javaLocalDefault ( actorSystem );","title":"Baker.akka(config, actorSystem)"},{"location":"sections/reference/runtime/#advantages-of-the-cluster-mode","text":"The capabilities gained when in cluster mode are: Elasticity: by adding/removing nodes to the cluster. Resilience: RecipeInstances are automatically restored in a new node when the hosting node fails. (For this you need to configure a distributed data store like Cassandra) Routing: You can fire EventInstances from anywhere on the cluster, and Baker will ensure that the corresponding RecipeInstance receives the firing event. Note: To run on cluster mode you need to configure a distributed data store, we highly recommend using Cassandra.","title":"Advantages of the Cluster Mode"},{"location":"sections/reference/runtime/#interactioninstancefromobject-reflection-api","text":"As part of our efforts to ease the creation of InteractionInstances we created this function that uses the Scala and the Java reflection capabilities to create an InteractionInstance from an instance of a class. The name of the InteractionInstance will be taken from the name of the implementing interface (Java) or trait (Scala) (it must match the name of the Interaction at the Recipe ). The interface MUST declare a public method called apply , and the types must match those of the expected provided ingredients. Notice that his function might throw an exception if the instance is not correctly done (this is why in Scala the API is named \"unsafe\"). Scala import com.ing.baker.runtime.scaladsl.InteractionInstance import scala.concurrent.Future import scala.concurrent.ExecutionContext.Implicits.global sealed trait ReserveItemsOutput case class OrderHadUnavailableItems ( unavailableItems : List [ String ]) extends ReserveItemsOutput case class ItemsReserved ( reservedItems : List [ String ]) extends ReserveItemsOutput trait ReserveItems { def apply ( orderId : String , items : List [ String ]) : Future [ ReserveItemsOutput ] } class ReserveItemsInstance extends ReserveItems { override def apply ( orderId : String , items : List [ String ]) : Future [ ReserveItemsOutput ] = { // Http call to the Warehouse service val response : Future [ Either [ List [ String ] , List [ String ]]] = // This is mocked for the sake of the example Future . successful ( Right ( items )) // Build an event instance that Baker understands response . map { case Left ( unavailableItems ) => OrderHadUnavailableItems ( unavailableItems ) case Right ( reservedItems ) => ItemsReserved ( reservedItems ) } } } val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) Java import com.ing.baker.runtime.javadsl.InteractionInstance ; import com.ing.baker.runtime.javadsl.Interaction ; /** Java interface used for the Recipe */ public interface ReserveItems extends Interaction { interface ReserveItemsOutcome {} class OrderHadUnavailableItems implements ReserveItemsOutcome { public final List < String > unavailableItems ; public OrderHadUnavailableItems ( List < String > unavailableItems ) { this . unavailableItems = unavailableItems ; } } class ItemsReserved implements ReserveItemsOutcome { public final List < String > reservedItems ; public ItemsReserved ( List < String > reservedItems ) { this . reservedItems = reservedItems ; } } @FiresEvent ( oneOf = { OrderHadUnavailableItems . class , ItemsReserved . class }) ReserveItemsOutcome apply ( @RequiresIngredient ( \"orderId\" ) String id , @RequiresIngredient ( \"items\" ) List < String > items ); } /** Implementation of the interface used for creating an InteractionInstance */ public class ReserveItems implements JWebshopRecipe . ReserveItems { // The body of this method is going to be executed by the Baker runtime when the ingredients are available. @Override public ReserveItemsOutcome apply ( String id , List < String > items ) { return new ReserveItems . ItemsReserved ( items ); } } /** Create an InteractionInstance from an instance of the ReserveItems implementation */ InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ());","title":"InteractionInstance.from(object) (Reflection API)"},{"location":"sections/reference/runtime/#bakeraddinteractioninstanceinteractioninstance","text":"The Baker runtime requires you to add all InteractionInstances before adding any related CompiledRecipes . This can be done using the baker.addInteractionInstance(interactionInstance) or the baker.addInteractionInstances(intance1, instance2, ...) APIs. Note: in Java the api returns a CompletableFuture<BoxedUnit> , this is because the API is implemented in Scala, so Scala's Unit get translated to BoxedUnit , but you should you ignore it and consider it as good as Java's void , except it comes in a CompletableFuture that will help you handle async programming. Scala val baker : Baker = AkkaBaker . localDefault ( actorSystem ) val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItems ()) val result : Future [ Unit ] = baker . addInteractionInstance ( reserveItemsInstance ) Java Baker baker = AkkaBaker . javaLocalDefault ( actorSystem ); InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItems ()); CompletableFuture < BoxedUnit > = baker . addInteractionInstance ( reserveItemsInstance );","title":"baker.addInteractionInstance(interactionInstance)"},{"location":"sections/reference/runtime/#recipecompilercompilerecipe","text":"Recipes once built must be converted into a data structure called CompiledRecipe that lets RecipeInstances to understand, store and run your process. These can be used to create a new RecipeInstance from a baker runtime that contains both a CompiledRecipe and the required InteractionInstances , or they can as well be converted into a visualziation . Scala import com.ing.baker.compiler.RecipeCompiler import com.ing.baker.il.CompiledRecipe val compiledRecipe : CompiledRecipe = RecipeCompiler . compileRecipe ( recipe ) Java import com.ing.baker.compiler.RecipeCompiler ; import com.ing.baker.il.CompiledRecipe ; CompiledRecipe compiledRecipe = RecipeCompiler . compileRecipe ( recipe );","title":"RecipeCompiler.compile(recipe)"},{"location":"sections/reference/runtime/#bakeraddrecipereciperecordofcompiledrecipe","text":"Once Recipes have been transformed into CompiledRecipes they must be added to a baker runtime. The baker.addRecipe(RecipeRecord.of(compiledRecipe)) API will do so and return an id that you can use to reference the added recipe later on. Note: Before doing this, baker requires you to add all related InteractionInstances to the runtime, this is because baker does validation to ensure that every recipe is runnable from the previously added InteractionInstances . Java val recipeId Future [ String ] = baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) Java CompletableFuture < String > recipeId = baker . addRecipe ( RecipeRecord . of ( compiledRecipe ));","title":"baker.addRecipe(RecipeRecord.of(compiledRecipe))"},{"location":"sections/reference/runtime/#bakergetallrecipes","text":"The baker at runtime can give you a map of all the currently available recipes that has been previously added to Baker. Scala import com.ing.baker.runtime.scaladsl.RecipeInformation import scala.concurrent.Future val allRecipes : Future [ Map [ String , RecipeInformation ]] = baker . getAllRecipes Java import com.ing.baker.runtime.javadsl.RecipeInformation ; import java.util.concurrent.CompletableFuture ; import java.util.Map ; CompletableFuture < Map < String , RecipeInformation >> allRecipe = baker . getAllRecipes ();","title":"baker.getAllRecipes()"},{"location":"sections/reference/runtime/#bakerbakerecipeid-recipeinstanceid","text":"Once the Baker runtime contains a CompiledRecipe and all the associated InteractionInstances then you can use the baker.bake(recipeId, recipeInstanceId) API to create a RecipeInstance that will contain the state of your process and execute any InteractionInstance as soon as all its required InteractionIngredients are available. Note: This API requires you to choose a recipeInstanceId , the API does not provide one for you, this is so that you can manage this reference as required. Note: in Java the api returns a CompletableFuture<BoxedUnit> , this is because the API is implemented in Scala, so Scala's Unit get translated to BoxedUnit , but you should you ignore it and consider it as good as Java's void , except it comes in a CompletableFuture that will help you handle async programming. Scala val program : Future [ Unit ] = for { _ <- baker . addInteractionInstance ( interactionInstances ) recipeId <- baker . addRecipe ( RecipeRecord . of ( compiledRecipe )) recipeInstanceId = \"my-id\" _ <- baker . bake ( recipeId , recipeInstanceId ) } yield () Java String recipeInstanceId = \"my-id\" ; CompletableFuture < BoxedUnit > result = baker . addInteractionInstace ( reserveItemsInstance ) . thenCompose ( ignore -> baker . addRecipe ( RecipeRecord . of ( compiledRecipe ))) . thenCompose ( recipeId -> baker . bake ( recipeId , recipeInstanceId ));","title":"baker.bake(recipeId, recipeInstanceId)"},{"location":"sections/reference/runtime/#eventinstancefromobject","text":"As part of our efforts to ease the creation of EventInstances , we added a function that uses Java and Scala reflection to create EventInstances from class objects. The name of the EventInstance will be taken from the name of the class (Java) or case class (Scala) (it must match the name of the Event at the Recipe ). And the argument names and types of the constructors will be translated to IngredientInstances with corresponding names and baker types. Notice that this function might throw an exception if the event is not correctly done (this is why in Scala the API is named \"unsafe\"). Scala import com.ing.baker.runtime.scaladsl.EventInstance case class OrderPlaced ( orderId : String , items : List [ String ]) val firstOrderPlaced : EventInstance = EventInstance . unsafeFrom ( OrderPlaced ( \"order-id\" , List ( \"item1\" , \"item2\" ))) Java import com.ing.baker.runtime.javadsl.EventInstance ; class OrderPlaced { String orderId ; List < String > items ; public OrderPlaced ( String orderId , List < String > items ) { this . orderId = orderId ; this . items = items ; } } EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( \"order-uuid\" , items ));","title":"EventInstance.from(object)"},{"location":"sections/reference/runtime/#bakerfireeventrecipeinstanceid-eventinstance","text":"After creation of a RecipeInstance , you use one of the variations of baker.fireEvent(recipeInstanceId, eventInstance) to fire your EventInstances and start/continue the process flow. There are several supported semantics for firing an event which depend on the moment you want to get notified and continue your asynchronous computation, these are the 4 different moments: When the event got accepted by the RecipeInstance but has not started cascading the execution of InteractionInstances . For this use the Baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance) API. This will return a Future[SensoryEventStatus] enum notifying of the outcome (the event might get rejected). When the event got accepted by the RecipeInstance and has finished cascading the execution of InteractionInstances up to the point that it requires more EventInstances ( SensoryEvents ) to continue, or the process has finished. For this use the Baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance) API. This will return a Future[EventResult] object containing a SensoryEventStatus , the Event names that got fired in consequence of this SensoryEvent , and the current available Ingredients output of the InteractionInstances that got executed as consequence of the SensoryEvent . You want to do something on both of the previously mentioned moments, then use the Baker.fireEvent(recipeInstanceId, eventInstance) API, which will return an EventResolutions object which contains both Future[SensoryEventStatus] and Future[EventResult] (or its CompletableFuture<A> equivalents in Java). As soon as an intermediate Event fires from one of the InteractionInstances that execute as consequence of the fired SensoryEvent . For this use the Baker.fireEventAndResolveOnEvent(recipeInstanceId, eventInstance, onEventName) API. This will return a similar Future[EventResult to the one returned by Baker.fireEventAndResolveWhenCompleted except the data will be up to the moment the onEventName was fired.","title":"baker.fireEvent(recipeInstanceId, eventInstance)"},{"location":"sections/reference/runtime/#correlationid","text":"Optionally you may provide a correlation id when firing a EventInstance . The purpose of this identifier is idempotent event delivery: when sending the same event correlation id multiple times, only the first will be processed. This can be applied to the OrderPlaced event for example. Scala val correlationOrderId = \"a unique order id\" for { statusA <- baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ) _ = assert ( statusA == Received ) statusB <- baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ) _ = assert ( statusB == AlreadyReceived ) } yield () Java String correlationOrderId = \"a unique order id\" ; SensoryEventStatus statusA = baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ); . join (); assert ( statusA == Received ); SensoryEventStatus statusB = baker . processEventAndResolveWhenReceived ( recipeInstanceId , orderPlacedEvent , correlationOrderId ); . join (); assert ( statusB == AlreadyReceived );","title":"correlationId"},{"location":"sections/reference/runtime/#sensoryeventstatus","text":"Status Description Received The event was received normally AlreadyReceived An event with the same correlation id was already received ProcessDeleted The process instance was deleted ReceivePeriodExpired The receive period for the process instance has passed FiringLimitMet The firing limit for the event was met","title":"SensoryEventStatus"},{"location":"sections/reference/runtime/#bakergetrecipeinstancestaterecipeinstanceid","text":"baker.getInteractionInstanceState(recipeInstanceId) will return an InteractionInstanceState object which contains all the event names with timestamps that have executed, and the current available provided ingredient data. Scala import com.ing.baker.runtime.scaladsl.RecipeInstanceState val state : Future [ RecipeInstanceState ] = baker . getRecipeInstanceState ( recipeInstanceId ) Java import com.ing.baker.runtime.javadsl.RecipeInstanceState ; CompletableFuture < RecipeInstanceState > state = baker . getRecipeInstanceState ( recipeInstanceId );","title":"baker.getRecipeInstanceState(recipeInstanceId)"},{"location":"sections/reference/runtime/#bakergetallinteractioninstancesmetadata","text":"Returns the recipeId, recipeInstanceId and creation timestamp of all running RecipeInstances . Note: Can potentially return a partial result when baker runs in cluster mode because not all shards might be reached within the given timeout. Note: Does not include deleted RecipeInstances .","title":"baker.getAllInteractionInstancesMetadata()"},{"location":"sections/reference/runtime/#bakergetvisualstaterecipeinstanceid-style","text":"Another method of fetching state is the visual representation of it. You can do that with the Baker.getVisualState(recipeInstanceId) API. This will return a GraphViz string like the visualization api that you can convert into an image. Here is a visualization of the state of another webshop example, one can clearly see that the process is flowing correctly without failures and that it is still waiting for the payment sensory event to be fired. Scala val state : Future [ String ] = baker . getVisualState ( recipeInstanceId ) Java CompletableFuture < String > state = baker . getVisualState ( recipeInstanceId );","title":"baker.getVisualState(recipeInstanceId, style)"},{"location":"sections/reference/runtime/#bakerregistereventlistenerrecipename-listenerfunction","text":"Registers a listener to all runtime events for this baker instance. Note that: - The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests Scala baker . registerEventListener (( recipeInstanceId : String , event : EventInstance ) => { println ( s\"Recipe instance : $recipeInstanceId processed event ${ event . name } \" ) }) Java BiConsumer < String , EventInstance > handler = ( String recipeInstanceId , EventInstance event ) -> System . out . println ( \"Recipe Instance \" + recipeInstanceId + \" processed event \" + event . name ()); baker . registerEventListener ( handler );","title":"baker.registerEventListener(recipeName, listenerFunction)"},{"location":"sections/reference/runtime/#bakerregisterbakereventlistenerlistenerfunction","text":"Registers a listener to all runtime BAKER events, these are events that notify what Baker is doing, like RecipeInstances received EventInstances or CompiledRecipes being added to baker. Note that: - The delivery guarantee is AT MOST ONCE . Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode. Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests Scala import com.ing.baker.runtime.scaladsl._ baker . registerBakerEventListener (( event : BakerEvent ) => { event match { case e : EventReceived => println ( e ) case e : EventRejected => println ( e ) case e : InteractionFailed => println ( e ) case e : InteractionStarted => println ( e ) case e : InteractionCompleted => println ( e ) case e : ProcessCreated => println ( e ) case e : RecipeAdded => println ( e ) } }) Java import com.ing.baker.runtime.javadsl.BakerEvent ; baker . registerBakerEventListener (( BakerEvent event ) -> System . out . println ( event ));","title":"baker.registerBakerEventListener(listenerFunction)"},{"location":"sections/reference/runtime/#bakerretryinteractionrecipeinstanceid-interactionname","text":"It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception (and the FailureStrategy of the Interaction of the Recipe was set to block) or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways. This one involves forcing another try, resulting either on a successful continued process, or again on a failed state, to check this you will need to request the state of the RecipeInstance again. Note: this behaviour can be automatically preconfigured by using the RetryWithIncrementalBackoff FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . retryInteraction ( recipeInstanceId , \"ReserveItems\" );","title":"baker.retryInteraction(recipeInstanceId, interactionName)"},{"location":"sections/reference/runtime/#bakerresolveinteractionrecipeinstanceid-interactionname-event","text":"It is possible that during the execution of a RecipeInstance it becomes blocked , this can happen either because it is directly blocked by an exception or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in two ways. This one involves resolving the interaction with a chosen EventInstance to replace the one that would have had been computed by the InteractionInstance . Note: this behaviour can be automatically preconfigured by using the FireEventAfterFailure(eventName) FailureStrategy on the Interaction of the Recipe Scala val program : Future [ Unit ] = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , ItemsReserved ( List ( \"item1\" ))) Java CompletableFuture < BoxedUnit > program = baker . resolveInteraction ( recipeInstanceId , \"ReserveItems\" , new ItemsReserved ( List ( \"item1\" )));","title":"baker.resolveInteraction(recipeInstanceId, interactionName, event)"},{"location":"sections/reference/runtime/#bakerstopretryinginteractionrecipeinstanceid-interactionname","text":"If an Interaction is configured with a RetryWithIncrementalBackoff FailureStrategy then it will not stop retrying until you call this API or a successful outcome happens from the InteractionInstance . Scala val program : Future [ Unit ] = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" ) Java CompletableFuture < BoxedUnit > program = baker . stopRetryingInteraction ( recipeInstanceId , \"ReserveItems\" );","title":"baker.stopRetryingInteraction(recipeInstanceId, interactionName)"},{"location":"sections/reference/stores/","text":"Event Stores and Cluster Configuration Baker keeps the state of your RecipeInstances using a technique called event sourcing, such technique still requires you to save data into a data store if you want to restore state or move it around. Baker's event sourcing uses Akka's Persistence , and even though you don't need to know how it works, we recommend understanding the implications of it, specially when it comes to configuring and choosing the underlying data store. The two main categories you have is local vs distributed, the former being used mainly for testing which require no extra configuration, and the latter for production grade clusters, more specifically if you are going to use Baker on cluster mode, you NEED a distributed data store for Baker to work as expected. We recommend the usage of Cassandra, since it is the store the team has tested and used on production, for such you need to use a plugin like this one. Configuration examples application.conf Local non-cluster include \"baker.conf\" akka.cluster.sharding.state-store-mode = persistence akka.actor.allow-java-serialization = off Cluster with distributed store include \"baker.conf\" service { actorSystemName = \"CheckoutService\" actorSystemName = ${?ACTOR_SYSTEM_NAME} clusterHost = \"127.0.0.1\" clusterHost = ${?CLUSTER_HOST} clusterPort = 2551 clusterPort = ${?CLUSTER_PORT} seedHost = \"127.0.0.1\" seedHost = ${?CLUSTER_SEED_HOST} seedPort = 2551 seedPort = ${?CLUSTER_SEED_PORT} } baker { actor { provider = \"cluster-sharded\" } cluster { nr-of-shards = 52 seed-nodes = [ \"akka.tcp://\"${service.actorSystemName}\"@\"${service.seedHost}\":\"${service.seedPort}] } } akka { actor { provider = \"cluster\" } persistence { # See https://doc.akka.io/docs/akka-persistence-cassandra/current/journal.html#configuration journal.plugin = \"cassandra-journal\" # See https://doc.akka.io/docs/akka-persistence-cassandra/current/snapshots.html#configuration snapshot-store.plugin = \"cassandra-snapshot-store\" } remote { log-remote-lifecycle-events = off netty.tcp { hostname = ${service.clusterHost} port = ${service.clusterPort} } } cluster { seed-nodes = [ \"akka.tcp://\"${service.actorSystemName}\"@\"${service.seedHost}\":\"${service.seedPort}] # auto downing is NOT safe for production deployments. # you may want to use it during development, read more about it in the akka docs. auto-down-unreachable-after = 10s } }","title":"Event Stores and Cluster Configuration"},{"location":"sections/reference/stores/#event-stores-and-cluster-configuration","text":"Baker keeps the state of your RecipeInstances using a technique called event sourcing, such technique still requires you to save data into a data store if you want to restore state or move it around. Baker's event sourcing uses Akka's Persistence , and even though you don't need to know how it works, we recommend understanding the implications of it, specially when it comes to configuring and choosing the underlying data store. The two main categories you have is local vs distributed, the former being used mainly for testing which require no extra configuration, and the latter for production grade clusters, more specifically if you are going to use Baker on cluster mode, you NEED a distributed data store for Baker to work as expected. We recommend the usage of Cassandra, since it is the store the team has tested and used on production, for such you need to use a plugin like this one.","title":"Event Stores and Cluster Configuration"},{"location":"sections/reference/stores/#configuration-examples","text":"application.conf Local non-cluster include \"baker.conf\" akka.cluster.sharding.state-store-mode = persistence akka.actor.allow-java-serialization = off Cluster with distributed store include \"baker.conf\" service { actorSystemName = \"CheckoutService\" actorSystemName = ${?ACTOR_SYSTEM_NAME} clusterHost = \"127.0.0.1\" clusterHost = ${?CLUSTER_HOST} clusterPort = 2551 clusterPort = ${?CLUSTER_PORT} seedHost = \"127.0.0.1\" seedHost = ${?CLUSTER_SEED_HOST} seedPort = 2551 seedPort = ${?CLUSTER_SEED_PORT} } baker { actor { provider = \"cluster-sharded\" } cluster { nr-of-shards = 52 seed-nodes = [ \"akka.tcp://\"${service.actorSystemName}\"@\"${service.seedHost}\":\"${service.seedPort}] } } akka { actor { provider = \"cluster\" } persistence { # See https://doc.akka.io/docs/akka-persistence-cassandra/current/journal.html#configuration journal.plugin = \"cassandra-journal\" # See https://doc.akka.io/docs/akka-persistence-cassandra/current/snapshots.html#configuration snapshot-store.plugin = \"cassandra-snapshot-store\" } remote { log-remote-lifecycle-events = off netty.tcp { hostname = ${service.clusterHost} port = ${service.clusterPort} } } cluster { seed-nodes = [ \"akka.tcp://\"${service.actorSystemName}\"@\"${service.seedHost}\":\"${service.seedPort}] # auto downing is NOT safe for production deployments. # you may want to use it during development, read more about it in the akka docs. auto-down-unreachable-after = 10s } }","title":"Configuration examples"},{"location":"sections/reference/visualization/","text":"Visualization A visualization is a visual graph representation of a Recipe and it is built from a compiled recipe. You can see an example of the output and of a rendered visualization here . Scala import com.ing.baker.il.CompiledRecipe import com.ing.baker.compiler.RecipeCompiler val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val visualization : String = compiled . getRecipeVisualization Java import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.compiler.RecipeCompiler ; CompiledRecipe recipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String visualization = recipe . getRecipeVisualization (); The aesthetics can be configured by passing a com.ing.baker.il.RecipeVisualStyle object to the recipe.getRecipeVisualization() method, that object has scalax.collection.io.dot._ objects that will change how your ingredients, events and interactions are rendered. The default configuration is: Scala case class RecipeVisualStyle ( rootAttributes : List [ DotAttr ] = List ( DotAttr ( \"pad\" , 0.2 ) ), commonNodeAttributes : List [ DotAttrStmt ] = List ( DotAttrStmt ( Elem . node , List ( DotAttr ( \"fontname\" , \"ING Me\" ), DotAttr ( \"fontsize\" , 22 ), DotAttr ( \"fontcolor\" , \"white\" ) ) ) ), ingredientAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"style\" , \"filled\" ), DotAttr ( \"color\" , \"\\\"#FF6200\\\"\" ) ), providedIngredientAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"style\" , \"filled\" ), DotAttr ( \"color\" , \"\\\"#3b823a\\\"\" ) ), missingIngredientAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"style\" , \"filled\" ), DotAttr ( \"color\" , \"\\\"#EE0000\\\"\" ), DotAttr ( \"penwidth\" , \"5.0\" ) ), eventAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#767676\\\"\" ), DotAttr ( \"margin\" , 0.3D ) ), sensoryEventAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#767676\\\"\" ), DotAttr ( \"fillcolor\" , \"\\\"#D5D5D5\\\"\" ), DotAttr ( \"fontcolor\" , \"black\" ), DotAttr ( \"penwidth\" , 2 ), DotAttr ( \"margin\" , 0.3D ) ), interactionAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"rect\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#525199\\\"\" ), DotAttr ( \"penwidth\" , 2 ), DotAttr ( \"margin\" , 0.5D ), ), eventFiredAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#3b823a\\\"\" ), DotAttr ( \"margin\" , 0.3D ) ), firedInteractionAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"rect\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#3b823a\\\"\" ), DotAttr ( \"penwidth\" , 2 ), DotAttr ( \"margin\" , 0.5D ), ), eventMissingAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"margin\" , 0.3D ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#EE0000\\\"\" ), DotAttr ( \"penwidth\" , \"5.0\" ) ), choiceAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"point\" ), DotAttr ( \"fillcolor\" , \"\\\"#D0D93C\\\"\" ), DotAttr ( \"width\" , 0.3 ), DotAttr ( \"height\" , 0.3 ) ), emptyEventAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"point\" ), DotAttr ( \"fillcolor\" , \"\\\"#D0D93C\\\"\" ), DotAttr ( \"width\" , 0.1 ), DotAttr ( \"height\" , 0.1 ) ), preconditionORAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"fillcolor\" , \"\\\"#D0D93C\\\"\" ), DotAttr ( \"fontcolor\" , \"black\" ), DotAttr ( \"label\" , \"OR\" ), DotAttr ( \"style\" , \"filled\" ) ), // this will be removed soon sieveAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"rect\" ), DotAttr ( \"margin\" , 0.5D ), DotAttr ( \"color\" , \"\\\"#7594d6\\\"\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"penwidth\" , 2 ) ) ) Recipe Instance State Visualizations Another type of visualization that can be done is the Baker.getVisualState(recipeInstanceId) API, this will generate the same GraphViz string but of the state of a currently running ProcessInstance , referenced by the input recipeInstanceId.","title":"Visualization"},{"location":"sections/reference/visualization/#visualization","text":"A visualization is a visual graph representation of a Recipe and it is built from a compiled recipe. You can see an example of the output and of a rendered visualization here . Scala import com.ing.baker.il.CompiledRecipe import com.ing.baker.compiler.RecipeCompiler val compiled = RecipeCompiler . compileRecipe ( WebshopRecipe . recipe ) val visualization : String = compiled . getRecipeVisualization Java import com.ing.baker.il.CompiledRecipe ; import com.ing.baker.compiler.RecipeCompiler ; CompiledRecipe recipe = RecipeCompiler . compileRecipe ( JWebshopRecipe . recipe ); String visualization = recipe . getRecipeVisualization (); The aesthetics can be configured by passing a com.ing.baker.il.RecipeVisualStyle object to the recipe.getRecipeVisualization() method, that object has scalax.collection.io.dot._ objects that will change how your ingredients, events and interactions are rendered. The default configuration is: Scala case class RecipeVisualStyle ( rootAttributes : List [ DotAttr ] = List ( DotAttr ( \"pad\" , 0.2 ) ), commonNodeAttributes : List [ DotAttrStmt ] = List ( DotAttrStmt ( Elem . node , List ( DotAttr ( \"fontname\" , \"ING Me\" ), DotAttr ( \"fontsize\" , 22 ), DotAttr ( \"fontcolor\" , \"white\" ) ) ) ), ingredientAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"style\" , \"filled\" ), DotAttr ( \"color\" , \"\\\"#FF6200\\\"\" ) ), providedIngredientAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"style\" , \"filled\" ), DotAttr ( \"color\" , \"\\\"#3b823a\\\"\" ) ), missingIngredientAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"style\" , \"filled\" ), DotAttr ( \"color\" , \"\\\"#EE0000\\\"\" ), DotAttr ( \"penwidth\" , \"5.0\" ) ), eventAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#767676\\\"\" ), DotAttr ( \"margin\" , 0.3D ) ), sensoryEventAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#767676\\\"\" ), DotAttr ( \"fillcolor\" , \"\\\"#D5D5D5\\\"\" ), DotAttr ( \"fontcolor\" , \"black\" ), DotAttr ( \"penwidth\" , 2 ), DotAttr ( \"margin\" , 0.3D ) ), interactionAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"rect\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#525199\\\"\" ), DotAttr ( \"penwidth\" , 2 ), DotAttr ( \"margin\" , 0.5D ), ), eventFiredAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#3b823a\\\"\" ), DotAttr ( \"margin\" , 0.3D ) ), firedInteractionAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"rect\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#3b823a\\\"\" ), DotAttr ( \"penwidth\" , 2 ), DotAttr ( \"margin\" , 0.5D ), ), eventMissingAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"diamond\" ), DotAttr ( \"margin\" , 0.3D ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"color\" , \"\\\"#EE0000\\\"\" ), DotAttr ( \"penwidth\" , \"5.0\" ) ), choiceAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"point\" ), DotAttr ( \"fillcolor\" , \"\\\"#D0D93C\\\"\" ), DotAttr ( \"width\" , 0.3 ), DotAttr ( \"height\" , 0.3 ) ), emptyEventAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"point\" ), DotAttr ( \"fillcolor\" , \"\\\"#D0D93C\\\"\" ), DotAttr ( \"width\" , 0.1 ), DotAttr ( \"height\" , 0.1 ) ), preconditionORAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"circle\" ), DotAttr ( \"fillcolor\" , \"\\\"#D0D93C\\\"\" ), DotAttr ( \"fontcolor\" , \"black\" ), DotAttr ( \"label\" , \"OR\" ), DotAttr ( \"style\" , \"filled\" ) ), // this will be removed soon sieveAttributes : List [ DotAttr ] = List ( DotAttr ( \"shape\" , \"rect\" ), DotAttr ( \"margin\" , 0.5D ), DotAttr ( \"color\" , \"\\\"#7594d6\\\"\" ), DotAttr ( \"style\" , \"rounded, filled\" ), DotAttr ( \"penwidth\" , 2 ) ) )","title":"Visualization"},{"location":"sections/reference/visualization/#recipe-instance-state-visualizations","text":"Another type of visualization that can be done is the Baker.getVisualState(recipeInstanceId) API, this will generate the same GraphViz string but of the state of a currently running ProcessInstance , referenced by the input recipeInstanceId.","title":"Recipe Instance State Visualizations"},{"location":"sections/versions/baker-2/","text":"Migration Guide v2 From 1.3.x to 2.0.0 This guide only describes how to migrate your existing application. Summary: ALL persisted data from baker 1.3.x IS COMPATIBLE and can be used with 2.0.x When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Some small code refactors are necessary (see below). For a full list new features see the changelog . Downtime required for clusters with state In 2.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 1.3.x ) and bring it up again ( 2.0.0 ). A rolling deploy IS NOT tested and NOT recommended. Removed Ingredient interface com.ing.baker.recipe.javadsl.Ingredient was removed. This was a tagging interface that was not used in the project. You can remove all references to this interface in your project. One thing to note is that Ingredient extended from scala.Serializable . If you depended on this behaviour just replace Ingredient by scala.Serializable . @ProvidesIngredient removed In 1.3.x you could directly provide an ingredient from an interaction. For example: import com.ing.baker.recipe.annotations.ProvidesIngredient ; interface GetEmail { @ProvidesIngredient ( \"email\" ) String apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } This feature has been removed. Internally this was already translated to an implicitly generated event: $interactionName + Successful . Now it is required that you do this expclitly to avoid confusion. The refactor is very straight forwfard: import com.ing.baker.recipe.annotations.FiresEvent ; interface GetEmail { public class GetEmailSuccessful { public final String email ; public ExampleInteractionSuccessful ( String email ) { this . email = email ; } } @FiresEvent ( oneOf = { GetEmailSuccessful . class } ) GetEmailSuccessful apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } If you use lombok annotations you can get rid of a lot of the boiler plate by using @Value on the event class. In scala it is recommended to use case classes.","title":"Migration Guide v2"},{"location":"sections/versions/baker-2/#migration-guide-v2","text":"","title":"Migration Guide v2"},{"location":"sections/versions/baker-2/#from-13x-to-200","text":"This guide only describes how to migrate your existing application. Summary: ALL persisted data from baker 1.3.x IS COMPATIBLE and can be used with 2.0.x When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Some small code refactors are necessary (see below). For a full list new features see the changelog .","title":"From 1.3.x to 2.0.0"},{"location":"sections/versions/baker-2/#downtime-required-for-clusters-with-state","text":"In 2.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 1.3.x ) and bring it up again ( 2.0.0 ). A rolling deploy IS NOT tested and NOT recommended.","title":"Downtime required for clusters with state"},{"location":"sections/versions/baker-2/#removed-ingredient-interface","text":"com.ing.baker.recipe.javadsl.Ingredient was removed. This was a tagging interface that was not used in the project. You can remove all references to this interface in your project. One thing to note is that Ingredient extended from scala.Serializable . If you depended on this behaviour just replace Ingredient by scala.Serializable .","title":"Removed Ingredient interface"},{"location":"sections/versions/baker-2/#providesingredient-removed","text":"In 1.3.x you could directly provide an ingredient from an interaction. For example: import com.ing.baker.recipe.annotations.ProvidesIngredient ; interface GetEmail { @ProvidesIngredient ( \"email\" ) String apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } This feature has been removed. Internally this was already translated to an implicitly generated event: $interactionName + Successful . Now it is required that you do this expclitly to avoid confusion. The refactor is very straight forwfard: import com.ing.baker.recipe.annotations.FiresEvent ; interface GetEmail { public class GetEmailSuccessful { public final String email ; public ExampleInteractionSuccessful ( String email ) { this . email = email ; } } @FiresEvent ( oneOf = { GetEmailSuccessful . class } ) GetEmailSuccessful apply ( @RequiresIngredient ( \"customer\" ) Customer customer ); } If you use lombok annotations you can get rid of a lot of the boiler plate by using @Value on the event class. In scala it is recommended to use case classes.","title":"@ProvidesIngredient removed"},{"location":"sections/versions/baker-3-release-notes/","text":"Release Notes v3 The theme of release 3 is the Baker runtime. We have two goals with this release. The first goal is to be clearer in what the Baker runtime does. We try to achieve this by having better naming and more truthful interface. The second goal is to simplify the internal logic of the runtime. This help when developing baker and has increased the performance of Baker. Clearer and more truthful runtime interface The interface of Baker has had a complete overhaul. Most changes are described below. Our documentation also has been improved considerably so please have a look into this if something is unclear. New approach to Java and Scala DSL for the runtime In the past the Baker runtime was created for Scala developers and returned Scala objects. For Java developers we create the JBaker which wrapped around the Baker and translated the objects. The problem with this approach was that the interfaces for Java and Scala developers was going out of sync. In this release we have created two separate packages for Java and Scala interfaces. The javadsl and scaladsl packages contain the same objects but created for those users in mind. These objects share a common parent to ensure the Java and Scala runtime DSLs are in sync. As user you just chooses the correct objects by having either the javadsl or scaladsl imported. No more blocking! Future and CompletableFuture One of the things that Baker was hiding from the user is that is did a lot of blocking operations. It was also unneeded to block since internally everything already supported using async operations. In this release we have adjusted almost all interfaces of Baker to return a Future (or CompletableFuture for Java). This way Baker does not block anymore and the user is in control. The user can now program with Baker in a more functional way by using these futures. If you as user do not want to you can wait for the result and its clear that the thread is blocked. Renames to runtime objects One of the things that was unclear is how the runtime objects map to the objects in the Recipe. To make this clearer we have renamed some of the runtime objects. They now map in the following fashion Specification Runtime Type Value Ingredient IngredientInstance Event EventInstance Interaction InteractionInstance Recipe RecipeInstance This means the following renames have been done Process -> RecipeInstance ProcessId -> RecipeInstanceId RuntimeEvent -> EventInstance InteractionImplementation/Implementation -> InteractionInstance This also translates to all methods on Baker. For example: addImplementation -> addInteractionInstance getProcessState -> getRecipeInstanceState Firing events into Baker The processEvent logic has been completely rewritten, it is now been renamed to fireEvent. See the fire event section for more details. EventInstance In the old versions you could give any object to the processEvent method and Baker would transform this to an Event. This made it sometimes unclear what Baker really accepts as a input for this method. In the new version of Baker you give a EventInstance to Baker. This is the internal object we where creating from the Object in the past. The EventInstance in turn can be created form an Object. The difference now is that its clear that Baker uses EventInstances internally. Another advantage is that you are now also free to create EventInstances any other way. Scala //From any Object val orderPlaced = EventInstance . unsafeFrom ( SimpleWebshopRecipeReflection . OrderPlaced ( orderId , items )) //Using constructor val orderPlace2 = EventInstance . apply ( \"OrderPlaced\" , Map ( \"orderId\" -> Converters . toValue ( orderId ), \"items\" -> Converters . toValue ( items ))) Java //From any Object EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( orderId , items )); //Using constructor EventInstance firstOrderPlaced2 = EventInstance . apply ( \"OrderPlaced\" , ImmutableMap . of ( \"orderId\" , Converters . toValue ( orderId ), \"items\" , Converters . toValue ( items ))); Decide on what to be notified on when firing the event Like in the old versions you can ask Baker to notify on specific moments. This can be when the event is received or when the processing is completed. New in this release is that you can now specify this when firing the event itself. The advantage is that Baker can optimize the resources it uses in those cases. This is done using the fireEventAndResolveWhenReceived and fireEventAndResolveWhenCompleted methods. Scala val result : Future [ SensoryEventStatus ] = baker . fireEventAndResolveWhenReceived ( recipeInstanceId , orderPlaced ) val result : Future [ SensoryEventResult ] = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade ) Java CompletableFuture < SensoryEventStatus > result = baker . fireEventAndResolveWhenReceived ( recipeInstanceId , paymentMade ); CompletableFuture < SensoryEventResult > result = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced ); The old way of firing a event where you get both the co Wait for a specific Event In this new release we have added a highly requested feature. YOu can now ask baker to notify you on a a specific event. You can use the fireEventAndResolveOnEvent method for this. The returned future will complete when a event with the given name is fired. Scala val result : Future [ SensoryEventResult ] = baker . fireEventAndResolveOnEvent ( recipeInstanceId , orderPlaced , \"eventName\" ) Java CompletableFuture < SensoryEventResult > result = baker . fireEventAndResolveOnEvent ( recipeInstanceId , firstOrderPlaced , \"eventName\" ); EventResult The fireEventAndResolveOnEvent and fireEventAndResolveWhenCompleted return an EventResult. This EventResult object contains the SensoryEventStatus, event names and created ingredients. The addition of the event names and ingredients can be very useful if you need to make a decision depending on the state. In these cases there is no need to inquire on Baker itself anymore. Scala case class SensoryEventResult ( sensoryEventStatus : SensoryEventStatus , eventNames : Seq [ String ], ingredients : Map [ String , Value ] ) extends com . ing . baker . runtime . common . SensoryEventResult with ScalaApi Java case class SensoryEventResult ( sensoryEventStatus : SensoryEventStatus , eventNames : java . util . List [ String ] , ingredients : java . util . Map [ String , Value ] ) extends com . ing . baker . runtime . common . SensoryEventResult with JavaApi { def getSensoryEventStatus : SensoryEventStatus = sensoryEventStatus def getEventName : java . util . List [ String ] = eventNames def getIngredients : java . util . Map [ String , Value ] = ingredients } New EventListener functions For the EventListener we have moved away from the annotation based approach. In this version you can add an EventListener function instead. See the event listener section for more details. Improved and simplified Runtime Better performance Due to simplifying and refactoring the runtime we see a big increase in the load a Baker instance can handle. For our created example project we saw the project could handle over 5 times the load when switching from version 2 to 3 of Baker. New journal for stateless processes For stateless processes we used to advise to use the in-memory-journal plugin. This journal kept all processes in-memory until the actors where cleaned. For a true stateless process this is unnecessary so we created a new journal. This one just dumps the event sourcing messages. This should lower the memory footprint of stateless users. How to configure: CONFIG # Custom journal plugin service.sink-journal { # Class name of the plugin. class = \"com.ing.baker.runtime.akka.journal.SinkJournalWriter\" # Dispatcher for the plugin actor. plugin-dispatcher = \"akka.actor.default-dispatcher\" } service.sink-snapshot-store { # Class name of the plugin. class = \"com.ing.baker.runtime.akka.journal.SinkSnapshotStore\" # Dispatcher for the plugin actor. plugin-dispatcher = \"akka.persistence.dispatchers.default-plugin-dispatcher\" } akka.persistence { journal.plugin = \"service.sink-journal\" snapshot-store.plugin = \"service.sink-snapshot-store\" } Support for async interactions It is now possible to create interactions that return their events in a Future or CompletableFuture. When using this Baker can close threads instead of blocking a thread. Which in turn again improves performance. The downside of using async interaction is that some validations cannot be done anymore due to type erasure. To use this in Scala you just return a Future of the result of your interaction. In Java you need to return a CompletableFuture of your result and add an AsyncInteraction annotation on top of your InteractionInstance. Deprecated/Removed EventListener The EventListener object used in the Java runtime has been deprecated. We advice users to move over the logic to the registerBakerEventListener that accepts functions instead. Sieves The Sieve concept has slowly been deprecated in the last releases. In version 2 there was already no difference between a sieve and an interaction. In this release we have removed sieves completely. UUID support In JBaker we supported using a UUID as a processId. In this release this has been removed completely and we accept Strings. This is again in line with being clearer what Baker does. Internally we were just transforming this to a String. Accesss to RuntimeEvents Version 2 would provided undocumented public interfaces returning RuntimeEvent instances. In version 3, the possibility to get Ingredients provided by a specific Event is gone. Users should not care where ingredients are provided from. This could be from an SensoryEvent or as output of a Event from an Interaction. This should not matter, only if the ingredient is available should matter. This allow users to flexibly recipes without impacting client code.","title":"Release Notes v3"},{"location":"sections/versions/baker-3-release-notes/#release-notes-v3","text":"The theme of release 3 is the Baker runtime. We have two goals with this release. The first goal is to be clearer in what the Baker runtime does. We try to achieve this by having better naming and more truthful interface. The second goal is to simplify the internal logic of the runtime. This help when developing baker and has increased the performance of Baker.","title":"Release Notes v3"},{"location":"sections/versions/baker-3-release-notes/#clearer-and-more-truthful-runtime-interface","text":"The interface of Baker has had a complete overhaul. Most changes are described below. Our documentation also has been improved considerably so please have a look into this if something is unclear.","title":"Clearer and more truthful runtime interface"},{"location":"sections/versions/baker-3-release-notes/#new-approach-to-java-and-scala-dsl-for-the-runtime","text":"In the past the Baker runtime was created for Scala developers and returned Scala objects. For Java developers we create the JBaker which wrapped around the Baker and translated the objects. The problem with this approach was that the interfaces for Java and Scala developers was going out of sync. In this release we have created two separate packages for Java and Scala interfaces. The javadsl and scaladsl packages contain the same objects but created for those users in mind. These objects share a common parent to ensure the Java and Scala runtime DSLs are in sync. As user you just chooses the correct objects by having either the javadsl or scaladsl imported.","title":"New approach to Java and Scala DSL for the runtime"},{"location":"sections/versions/baker-3-release-notes/#no-more-blocking-future-and-completablefuture","text":"One of the things that Baker was hiding from the user is that is did a lot of blocking operations. It was also unneeded to block since internally everything already supported using async operations. In this release we have adjusted almost all interfaces of Baker to return a Future (or CompletableFuture for Java). This way Baker does not block anymore and the user is in control. The user can now program with Baker in a more functional way by using these futures. If you as user do not want to you can wait for the result and its clear that the thread is blocked.","title":"No more blocking! Future and CompletableFuture"},{"location":"sections/versions/baker-3-release-notes/#renames-to-runtime-objects","text":"One of the things that was unclear is how the runtime objects map to the objects in the Recipe. To make this clearer we have renamed some of the runtime objects. They now map in the following fashion Specification Runtime Type Value Ingredient IngredientInstance Event EventInstance Interaction InteractionInstance Recipe RecipeInstance This means the following renames have been done Process -> RecipeInstance ProcessId -> RecipeInstanceId RuntimeEvent -> EventInstance InteractionImplementation/Implementation -> InteractionInstance This also translates to all methods on Baker. For example: addImplementation -> addInteractionInstance getProcessState -> getRecipeInstanceState","title":"Renames to runtime objects"},{"location":"sections/versions/baker-3-release-notes/#firing-events-into-baker","text":"The processEvent logic has been completely rewritten, it is now been renamed to fireEvent. See the fire event section for more details.","title":"Firing events into Baker"},{"location":"sections/versions/baker-3-release-notes/#eventinstance","text":"In the old versions you could give any object to the processEvent method and Baker would transform this to an Event. This made it sometimes unclear what Baker really accepts as a input for this method. In the new version of Baker you give a EventInstance to Baker. This is the internal object we where creating from the Object in the past. The EventInstance in turn can be created form an Object. The difference now is that its clear that Baker uses EventInstances internally. Another advantage is that you are now also free to create EventInstances any other way. Scala //From any Object val orderPlaced = EventInstance . unsafeFrom ( SimpleWebshopRecipeReflection . OrderPlaced ( orderId , items )) //Using constructor val orderPlace2 = EventInstance . apply ( \"OrderPlaced\" , Map ( \"orderId\" -> Converters . toValue ( orderId ), \"items\" -> Converters . toValue ( items ))) Java //From any Object EventInstance firstOrderPlaced = EventInstance . from ( new JWebshopRecipe . OrderPlaced ( orderId , items )); //Using constructor EventInstance firstOrderPlaced2 = EventInstance . apply ( \"OrderPlaced\" , ImmutableMap . of ( \"orderId\" , Converters . toValue ( orderId ), \"items\" , Converters . toValue ( items )));","title":"EventInstance"},{"location":"sections/versions/baker-3-release-notes/#decide-on-what-to-be-notified-on-when-firing-the-event","text":"Like in the old versions you can ask Baker to notify on specific moments. This can be when the event is received or when the processing is completed. New in this release is that you can now specify this when firing the event itself. The advantage is that Baker can optimize the resources it uses in those cases. This is done using the fireEventAndResolveWhenReceived and fireEventAndResolveWhenCompleted methods. Scala val result : Future [ SensoryEventStatus ] = baker . fireEventAndResolveWhenReceived ( recipeInstanceId , orderPlaced ) val result : Future [ SensoryEventResult ] = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , paymentMade ) Java CompletableFuture < SensoryEventStatus > result = baker . fireEventAndResolveWhenReceived ( recipeInstanceId , paymentMade ); CompletableFuture < SensoryEventResult > result = baker . fireEventAndResolveWhenCompleted ( recipeInstanceId , firstOrderPlaced ); The old way of firing a event where you get both the co","title":"Decide on what to be notified on when firing the event"},{"location":"sections/versions/baker-3-release-notes/#wait-for-a-specific-event","text":"In this new release we have added a highly requested feature. YOu can now ask baker to notify you on a a specific event. You can use the fireEventAndResolveOnEvent method for this. The returned future will complete when a event with the given name is fired. Scala val result : Future [ SensoryEventResult ] = baker . fireEventAndResolveOnEvent ( recipeInstanceId , orderPlaced , \"eventName\" ) Java CompletableFuture < SensoryEventResult > result = baker . fireEventAndResolveOnEvent ( recipeInstanceId , firstOrderPlaced , \"eventName\" );","title":"Wait for a specific Event"},{"location":"sections/versions/baker-3-release-notes/#eventresult","text":"The fireEventAndResolveOnEvent and fireEventAndResolveWhenCompleted return an EventResult. This EventResult object contains the SensoryEventStatus, event names and created ingredients. The addition of the event names and ingredients can be very useful if you need to make a decision depending on the state. In these cases there is no need to inquire on Baker itself anymore. Scala case class SensoryEventResult ( sensoryEventStatus : SensoryEventStatus , eventNames : Seq [ String ], ingredients : Map [ String , Value ] ) extends com . ing . baker . runtime . common . SensoryEventResult with ScalaApi Java case class SensoryEventResult ( sensoryEventStatus : SensoryEventStatus , eventNames : java . util . List [ String ] , ingredients : java . util . Map [ String , Value ] ) extends com . ing . baker . runtime . common . SensoryEventResult with JavaApi { def getSensoryEventStatus : SensoryEventStatus = sensoryEventStatus def getEventName : java . util . List [ String ] = eventNames def getIngredients : java . util . Map [ String , Value ] = ingredients }","title":"EventResult"},{"location":"sections/versions/baker-3-release-notes/#new-eventlistener-functions","text":"For the EventListener we have moved away from the annotation based approach. In this version you can add an EventListener function instead. See the event listener section for more details.","title":"New EventListener functions"},{"location":"sections/versions/baker-3-release-notes/#improved-and-simplified-runtime","text":"","title":"Improved and simplified Runtime"},{"location":"sections/versions/baker-3-release-notes/#better-performance","text":"Due to simplifying and refactoring the runtime we see a big increase in the load a Baker instance can handle. For our created example project we saw the project could handle over 5 times the load when switching from version 2 to 3 of Baker.","title":"Better performance"},{"location":"sections/versions/baker-3-release-notes/#new-journal-for-stateless-processes","text":"For stateless processes we used to advise to use the in-memory-journal plugin. This journal kept all processes in-memory until the actors where cleaned. For a true stateless process this is unnecessary so we created a new journal. This one just dumps the event sourcing messages. This should lower the memory footprint of stateless users. How to configure: CONFIG # Custom journal plugin service.sink-journal { # Class name of the plugin. class = \"com.ing.baker.runtime.akka.journal.SinkJournalWriter\" # Dispatcher for the plugin actor. plugin-dispatcher = \"akka.actor.default-dispatcher\" } service.sink-snapshot-store { # Class name of the plugin. class = \"com.ing.baker.runtime.akka.journal.SinkSnapshotStore\" # Dispatcher for the plugin actor. plugin-dispatcher = \"akka.persistence.dispatchers.default-plugin-dispatcher\" } akka.persistence { journal.plugin = \"service.sink-journal\" snapshot-store.plugin = \"service.sink-snapshot-store\" }","title":"New journal for stateless processes"},{"location":"sections/versions/baker-3-release-notes/#support-for-async-interactions","text":"It is now possible to create interactions that return their events in a Future or CompletableFuture. When using this Baker can close threads instead of blocking a thread. Which in turn again improves performance. The downside of using async interaction is that some validations cannot be done anymore due to type erasure. To use this in Scala you just return a Future of the result of your interaction. In Java you need to return a CompletableFuture of your result and add an AsyncInteraction annotation on top of your InteractionInstance.","title":"Support for async interactions"},{"location":"sections/versions/baker-3-release-notes/#deprecatedremoved","text":"","title":"Deprecated/Removed"},{"location":"sections/versions/baker-3-release-notes/#eventlistener","text":"The EventListener object used in the Java runtime has been deprecated. We advice users to move over the logic to the registerBakerEventListener that accepts functions instead.","title":"EventListener"},{"location":"sections/versions/baker-3-release-notes/#sieves","text":"The Sieve concept has slowly been deprecated in the last releases. In version 2 there was already no difference between a sieve and an interaction. In this release we have removed sieves completely.","title":"Sieves"},{"location":"sections/versions/baker-3-release-notes/#uuid-support","text":"In JBaker we supported using a UUID as a processId. In this release this has been removed completely and we accept Strings. This is again in line with being clearer what Baker does. Internally we were just transforming this to a String.","title":"UUID support"},{"location":"sections/versions/baker-3-release-notes/#accesss-to-runtimeevents","text":"Version 2 would provided undocumented public interfaces returning RuntimeEvent instances. In version 3, the possibility to get Ingredients provided by a specific Event is gone. Users should not care where ingredients are provided from. This could be from an SensoryEvent or as output of a Event from an Interaction. This should not matter, only if the ingredient is available should matter. This allow users to flexibly recipes without impacting client code.","title":"Accesss to RuntimeEvents"},{"location":"sections/versions/baker-3/","text":"Migration Guide v3 From 2.X.X to 3.0.0 This guide only describes how to migrate your existing application. For a full list new features see the release notes . Summary: ALL persisted data from older baker versions IS COMPATIBLE and can be used with 3.0.0 When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Code changes are needed to comply to the new Baker interface No code changes needed to the Recipe (except the removal of the sieve concept) Downtime required for clusters with state In 3.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 2.x.x ) and bring it up again ( 3.0.0 ). A rolling deploy is tested but is NOT recommended. During the rolling deploy messages regarding handling events will fail. It is safer to bring the complete cluster down. Renames/package changes com.ing.baker.runtime.core -> com.ing.baker.runtime.javadsl/scaladsl/common (depends per object) com.ing.baker.runtime.java_api -> com.ing.baker.runtime.javadsl processId -> recipeInstanceId getProcessId -> GetRecipeInstanceId RuntimeEvent -> EventInstance ProcessState -> RecipeInstanceState Future and CompletableFuture The new Java and Scala interfaces now almost always return a Future or CompletableFuture. It is now up to the user to handle waiting for the completion of this future. This can either be by blocking directly or by 'correctly' programming with these Futures. We REALLY advise to invest in programming in a non blocking fashion! Scala //Blocking val futureStatus : Future [ SensoryEventStatus ] = baker . fireEventAndResolveWhenReceived ( orderId , event ) val status : SensoryEventStatus = Await . result ( futureStatus , 10 seconds ) //Non Blocking val futureStatus : Future [ SensoryEventStatus ] = baker . fireEventAndResolveWhenReceived ( orderId , event ) futureStatus . map ( sensoryEventStatus => { //Code to handle status }) Java //Blocking CompletableFuture < SensoryEventStatus > futureStatus = baker . fireEventAndResolveWhenReceived ( uuid . toString (), EventInstance . from ( new ExampleEvent ())); SensoryEventStatus sensoryEventStatus = futureStatus . get (); //Non blocking CompletableFuture < SensoryEventStatus > futureStatus = baker . fireEventAndResolveWhenReceived ( uuid . toString (), eventInstance )); futureStatus . thenApply ( sensoryEventStatus -> { //Code to handle status }); Any Exceptions that used to be thrown by Baker are now encapsulated in the Future/CompletableFuture. For the CompletableFuture the original exception is wrapped in the ExecutionException. This is how CompletableFuture work and there is no way around it. Java //Blocking try { baker . fireEventAndResolveWhenCompleted ( processId , EventInstance . from ( new ExampleEventClass ())). get (); } catch ( ExecutionException e ) { if ( e . getCause () instanceof BakerException . NoSuchProcessException ) { //Code to handle NoSuchProcessException } //Code to handle other Exceptions } //Non blocking baker . fireEventAndResolveWhenCompleted ( processId , EventInstance . from ( new ExampleEventClass ())) . exceptionally ( exception -> { if ( exception . getCause () instanceof BakerException . NoSuchProcessException ) { //Decide on what to return on NoSuchProcessException } //Decide on what to return on other Exceptions }); Creating a Baker instance A Baker instance is now created not with a constructor but via a static method. For Java the JBaker is gone and you now create a Baker under the javadsl package. Scala import com.ing.baker.runtime.scaladsl. *; ...... val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val config : Config = ConfigFactory . load () val baker = Baker . akka ( config , actorSystem ); Java import com.ing.baker.runtime.javadsl.* ; ...... ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Config config = ConfigFactory . load (); Baker baker = Baker . akka ( config , actorSystem ); See the runtime reference for more details Adding Interactions into Baker When adding InteractionInstances formerly known as InteractionImplementations to Baker you now need to give a real InteractionInstance object. Scala val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) baker . addInteractionInstance ( reserveItemsInstance ) Java InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItemsInstance ()); baker . addInteractionInstance ( reserveItemsInstance ) Firing events The processEvent has been completely rewritten and is now named FireEvent. See the release note or fire event section for more details Small changes dropped .withSieves on the recipe, add these with .withInteractionInstances removed support in the interface for UUID, for interaction interfaces a UUID is still supported for backwards compatability reasons. About Artery for Akka remoting Akka has released a new remoting protocol called Artery This is very interesting for Baker users that have Akka cluster. We have successfully migrated to this from the old remoting and see stability and performance gains. Dependency We have noticed that when using Baker in a maven project the dependencies are not always take over correctly. If you have the following dependencies in your project please upgrade them: * org.typelevel.cats-core_2.12 1.5.0 * org.typelevel.cats-effect_2.12 1.2.0 * All Akka dependencies to 2.5.22 (should work with other 2.5.X versions but 2.5.22 is the one we tested).","title":"Migration Guide v3"},{"location":"sections/versions/baker-3/#migration-guide-v3","text":"","title":"Migration Guide v3"},{"location":"sections/versions/baker-3/#from-2xx-to-300","text":"This guide only describes how to migrate your existing application. For a full list new features see the release notes . Summary: ALL persisted data from older baker versions IS COMPATIBLE and can be used with 3.0.0 When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol. Code changes are needed to comply to the new Baker interface No code changes needed to the Recipe (except the removal of the sieve concept)","title":"From 2.X.X to 3.0.0"},{"location":"sections/versions/baker-3/#downtime-required-for-clusters-with-state","text":"In 3.0.0 some binary incompatible changes where made in the message protocol. This requires you to bring down the entire cluster ( 2.x.x ) and bring it up again ( 3.0.0 ). A rolling deploy is tested but is NOT recommended. During the rolling deploy messages regarding handling events will fail. It is safer to bring the complete cluster down.","title":"Downtime required for clusters with state"},{"location":"sections/versions/baker-3/#renamespackage-changes","text":"com.ing.baker.runtime.core -> com.ing.baker.runtime.javadsl/scaladsl/common (depends per object) com.ing.baker.runtime.java_api -> com.ing.baker.runtime.javadsl processId -> recipeInstanceId getProcessId -> GetRecipeInstanceId RuntimeEvent -> EventInstance ProcessState -> RecipeInstanceState","title":"Renames/package changes"},{"location":"sections/versions/baker-3/#future-and-completablefuture","text":"The new Java and Scala interfaces now almost always return a Future or CompletableFuture. It is now up to the user to handle waiting for the completion of this future. This can either be by blocking directly or by 'correctly' programming with these Futures. We REALLY advise to invest in programming in a non blocking fashion! Scala //Blocking val futureStatus : Future [ SensoryEventStatus ] = baker . fireEventAndResolveWhenReceived ( orderId , event ) val status : SensoryEventStatus = Await . result ( futureStatus , 10 seconds ) //Non Blocking val futureStatus : Future [ SensoryEventStatus ] = baker . fireEventAndResolveWhenReceived ( orderId , event ) futureStatus . map ( sensoryEventStatus => { //Code to handle status }) Java //Blocking CompletableFuture < SensoryEventStatus > futureStatus = baker . fireEventAndResolveWhenReceived ( uuid . toString (), EventInstance . from ( new ExampleEvent ())); SensoryEventStatus sensoryEventStatus = futureStatus . get (); //Non blocking CompletableFuture < SensoryEventStatus > futureStatus = baker . fireEventAndResolveWhenReceived ( uuid . toString (), eventInstance )); futureStatus . thenApply ( sensoryEventStatus -> { //Code to handle status }); Any Exceptions that used to be thrown by Baker are now encapsulated in the Future/CompletableFuture. For the CompletableFuture the original exception is wrapped in the ExecutionException. This is how CompletableFuture work and there is no way around it. Java //Blocking try { baker . fireEventAndResolveWhenCompleted ( processId , EventInstance . from ( new ExampleEventClass ())). get (); } catch ( ExecutionException e ) { if ( e . getCause () instanceof BakerException . NoSuchProcessException ) { //Code to handle NoSuchProcessException } //Code to handle other Exceptions } //Non blocking baker . fireEventAndResolveWhenCompleted ( processId , EventInstance . from ( new ExampleEventClass ())) . exceptionally ( exception -> { if ( exception . getCause () instanceof BakerException . NoSuchProcessException ) { //Decide on what to return on NoSuchProcessException } //Decide on what to return on other Exceptions });","title":"Future and CompletableFuture"},{"location":"sections/versions/baker-3/#creating-a-baker-instance","text":"A Baker instance is now created not with a constructor but via a static method. For Java the JBaker is gone and you now create a Baker under the javadsl package. Scala import com.ing.baker.runtime.scaladsl. *; ...... val actorSystem : ActorSystem = ActorSystem ( \"WebshopSystem\" ) val config : Config = ConfigFactory . load () val baker = Baker . akka ( config , actorSystem ); Java import com.ing.baker.runtime.javadsl.* ; ...... ActorSystem actorSystem = ActorSystem . create ( \"WebshopSystem\" ); Config config = ConfigFactory . load (); Baker baker = Baker . akka ( config , actorSystem ); See the runtime reference for more details","title":"Creating a Baker instance"},{"location":"sections/versions/baker-3/#adding-interactions-into-baker","text":"When adding InteractionInstances formerly known as InteractionImplementations to Baker you now need to give a real InteractionInstance object. Scala val reserveItemsInstance : InteractionInstance = InteractionInstance . unsafeFrom ( new ReserveItemsInstance ) baker . addInteractionInstance ( reserveItemsInstance ) Java InteractionInstance reserveItemsInstance = InteractionInstance . from ( new ReserveItemsInstance ()); baker . addInteractionInstance ( reserveItemsInstance )","title":"Adding Interactions into Baker"},{"location":"sections/versions/baker-3/#firing-events","text":"The processEvent has been completely rewritten and is now named FireEvent. See the release note or fire event section for more details","title":"Firing events"},{"location":"sections/versions/baker-3/#small-changes","text":"dropped .withSieves on the recipe, add these with .withInteractionInstances removed support in the interface for UUID, for interaction interfaces a UUID is still supported for backwards compatability reasons.","title":"Small changes"},{"location":"sections/versions/baker-3/#about-artery-for-akka-remoting","text":"Akka has released a new remoting protocol called Artery This is very interesting for Baker users that have Akka cluster. We have successfully migrated to this from the old remoting and see stability and performance gains.","title":"About Artery for Akka remoting"},{"location":"sections/versions/baker-3/#dependency","text":"We have noticed that when using Baker in a maven project the dependencies are not always take over correctly. If you have the following dependencies in your project please upgrade them: * org.typelevel.cats-core_2.12 1.5.0 * org.typelevel.cats-effect_2.12 1.2.0 * All Akka dependencies to 2.5.22 (should work with other 2.5.X versions but 2.5.22 is the one we tested).","title":"Dependency"}]}