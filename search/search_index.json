{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Baker","text":"<p>Baker is a library that provides a simple and intuitive way to orchestrate microservice-based process flows.</p> <p>You declare your orchestration logic as a recipe using the Java, Kotlin, or Scala DSL. A recipe consists of <code>interactions</code> (system calls), <code>ingredients</code> (data), and <code>events</code> (things that have happened in your process).</p>"},{"location":"#why-baker","title":"Why Baker","text":"<p>When working with microservice architectures, you encounter various challenges related to distributed systems. Things like communication models, consistency management, failure handling, scaling approaches, and more. Baker simplifies the development process by offering out-of-the-box solutions with its clustered runtime. Baker nodes can create and  distribute instances of recipes, handle failures in interactions using different strategies, restore the state of  long-lived processes, and provide additional functionalities to streamline microservice development.</p> Service composition <p>Baker allows you to compose complex business processes by combining multiple microservices. It acts as a centralized control mechanism to define the sequence and dependencies between services. Facilitating the execution of orchestrated processes. Enabling you to build more robust and sophisticated applications that span multiple services.</p> Decouple business logic from service technologies <p>Baker forces you to separate business logic from implementation details. Your business logic is expressed as a recipe via the Java, Kotlin, or Scala DSL. The implementation details are contained in the interaction implementations.</p> Retry mechanism <p>Baker includes a built-in retry mechanism. When a failure occurs in a microservice, Baker can automatically retry  the failed operation. Retrying the operation can help overcome transient errors or temporary network issues. Baker  can be configured with retry policies, including parameters such as the number of retries, delay between retries,  and exponential backoff strategies.</p> Visualize your business process <p>Bakers ability to visualize recipes provides a powerful communication tool that helps product owners, architects, and  engineers to have a common understanding of the business process. This feature allows you to easily share your  recipe with others, enabling collaboration and feedback.</p>"},{"location":"#new-to-baker","title":"New to Baker?","text":"<p>A good first step is to read more about Baker's core concepts. Afterward, you can follow this quick tutorial to build your first Baker process.</p>"},{"location":"archive/","title":"Index","text":""},{"location":"archive/#introduction","title":"Introduction","text":"<p>Baker is a library that reduces the effort to orchestrate (micro)service-based process flows.</p> <p>Developers declare the orchestration logic in a Recipe (process blueprint).</p> <p>A Recipe is made out of:</p> <ul> <li>Interactions (functions)</li> <li>Ingredients (data)</li> <li>Events</li> </ul> <p>More about these concepts here.</p>"},{"location":"archive/#overview","title":"Overview","text":"<p>Baker allows you to:</p> <ul> <li>Declaritavely design your processes using a recipe DSL.</li> <li>Visualize your recipe allowing product owners, architects and developers to talk the same language.</li> <li>Manage your recipes using the baker runtime.</li> <li>Create process instances of your recipes.</li> <li>Fire sensory events.</li> <li>Inquire the state of your process instances.</li> </ul>"},{"location":"archive/#visual-representation","title":"Visual representation","text":"<p>Below an example of a simple web shop recipe:</p> <p></p>"},{"location":"archive/baker-runtime/","title":"Baker Runtime","text":"<p>With the Recipe DSL you can create a description of your recipe.</p> <p>This does not yet constitute a runnable process. It is just a description.</p> <p>To execute &amp; manage your recipes you require the Baker Runtime.</p>"},{"location":"archive/baker-runtime/#starting-the-baker-runtime","title":"Starting the baker runtime","text":"<p>Creating a baker runtime is as easy as calling the empty constructor.</p> ScalaJava <pre><code>// Create a Baker Runtime\nval baker = new Baker();\n</code></pre> <pre><code>// Create a Baker Runtime\nJBaker baker = new JBaker();\n</code></pre> <p>Baker is build on top of akka.</p> <p>It requires an <code>ActorSystem</code> to start. In the previous example the actor system is not provided. In that case baker will create an actor system for you.</p> <p>If you already have an actor system then you can give it to Baker.</p> ScalaJava <pre><code>val actorSystem = ActorSystem();\n\nBaker baker = new Baker(actorSystem);\n</code></pre> <pre><code>ActorSystem actorSystem = ActorSystem.create();\n\nJBaker baker = new JBaker(actorSystem);\n</code></pre>"},{"location":"archive/baker-runtime/#adding-interaction-implementations","title":"Adding interaction implementations","text":"<p>Before you can add a recipe all the interactions for that recipe MUST have an implemention in Baker.</p> <p>You can add them like this:</p> ScalaJava <pre><code>val validateOrderImpl = new ValidateOrderImpl()\n\nbaker.addInteractionInstance(validateOrderImpl)\n</code></pre> <pre><code>ValidateOrderImpl validateOrderImpl = new ValidateOrderImpl();\n\nbaker.addInteractionInstance(validateOrderImpl);\n</code></pre>"},{"location":"archive/baker-runtime/#compiling-your-recipe","title":"Compiling your Recipe","text":"<p>A recipe is writen in a <code>DSL</code>. This is just a declarative description of your process.</p> <p>In order to execute it we need to compile it. This connects all the pieces into a graph (more precisly a petri net).</p> <p>For this purpose there is the <code>RecipeCompiler</code>.</p> ScalaJava <pre><code>val compiledRecipe: CompiledRecipe = RecipeCompiler.compileRecipe(recipe)\n</code></pre> <pre><code>CompiledRecipe compiledRecipe = RecipeCompiler.compileRecipe(recipe);\n</code></pre> <p>Did you know?!</p> <p>You can use a compiled recipe to create a visual representation. See the visualization page how to create a visual graph.</p>"},{"location":"archive/baker-runtime/#adding-your-compiled-recipe","title":"Adding your Compiled Recipe","text":"<p>Once you have compiled your recipe you can add it to Baker.</p> ScalaJava <pre><code>baker.addRecipe(RecipeRecord.of(compiledRecipe))\n</code></pre> <pre><code>baker.addRecipe(RecipeRecord.of(compiledRecipe));\n</code></pre>"},{"location":"archive/baker-runtime/#putting-it-all-together","title":"Putting it all together","text":"<p>Combining all these steps gives us the following:</p> <pre><code>// Implementations, probably defined in other files\nValidateOrderImpl validateOrderImpl = new ValidateOrderImpl();\nManufactureGoodsImpl manufactureGoodsImpl = new ManufactureGoodsImpl();\n\n// Compiling the Recipe\nCompiledRecipe compiledRecipe = RecipeCompiler.compileRecipe(recipe);\n\n// Creating a Baker Runtime\nJBaker baker = new JBaker();\n\n// Add the Implementations\nbaker.addInteractionInstances(validateOrderImpl, manufactureGoodsImpl);\n\n// Add the Compiled Recipe\nString recipeId = baker.addRecipe(RecipeRecord.of(compiledRecipe));\n</code></pre> <p>Baker is now ready to create an instance for the recipe and execute it.</p>"},{"location":"archive/concepts/","title":"Concepts","text":"<p>Baker introduces interactions, ingredients, and events as a model of abstracting.</p> <p>With these three components we can create recipes (process blue prints)</p>"},{"location":"archive/concepts/#ingredient","title":"Ingredient","text":"<p>Ingredients are pure data.</p> <p>This data is immutable, can not be changed after entering the process.</p> <p>There is no hi\u00ebrarchy in this data. (<code>Animal -&gt; Dog -&gt; Labrador</code> is not possible to express)</p> <p>Examples:</p> <ul> <li>an IBAN</li> <li>a track and trace code</li> <li>a list of phone numbers</li> <li>a customer information object with name, email, etc ...</li> </ul> <p>An ingredient is defined by a name and type.</p> <p>The name points to the intended meaning of the data. (\"customerData\", \"orderNumber\", ...)</p> <p>The type sets limits on the form of data that is accepted. (a number, a list of strings, ...)</p> <p>This type is expressed by the baker type system.</p>"},{"location":"archive/concepts/#interaction","title":"Interaction","text":"<p>An interaction is analagous to a function.</p> <p>It requires input (ingredients) and provides output (events).</p> <p>Within this contract it may do anything. For example:</p> <ul> <li>query an external system</li> <li>put a message on a bus</li> <li>generate a document or image</li> <li>extract or compose ingredients into others</li> </ul> <p>When finished, an interaction provides an event as its output.</p>"},{"location":"archive/concepts/#interaction-failure","title":"Interaction failure","text":"<p>An interaction may fail to fulfill its intended purpose.</p> <p>We distinquish 2 types of failures.</p> <ol> <li> <p>A technical failure is one that could be retried and succeed. For example:</p> <ul> <li>Time outs because of unreliable network, packet loss</li> <li>External system is temporarily down or unresponsive</li> <li>External system returned a malformed/unexpected response</li> </ul> <p>These failures are unexpected and are are modeled by throwing an exception from the interaction.</p> </li> <li> <p>A functional failure is one that cannot be retried. For example:</p> <ul> <li>The customer is too young for the request.</li> <li>Not enough credit to perform the transfer.</li> </ul> <p>These failures are expected possible outcomes of the interaction.</p> <p>They are modelled by returning an event from the interaction.</p> </li> </ol>"},{"location":"archive/concepts/#failure-mitigation","title":"Failure mitigation","text":"<p>In case of technical failures, baker offers 2 mitigation strategies:</p> <ol> <li> <p>Retry with incremental backoff</p> <p>This retries the interaction with some configurable parameters:</p> <ul> <li><code>initialTimeout</code>: The initial delay for the first retry.</li> <li><code>backoffFactor</code>: The backoff factor.</li> <li><code>maximumInterval</code>: The maximum interval between retries.</li> </ul> </li> <li> <p>Continue with an event.</p> <p>This is analagous to a try/catch in java code. The exception is logged but the process continues with a specified event.</p> </li> </ol> <p>When no failure strategy is defined for an interaction by default the interaction is blocked.</p>"},{"location":"archive/concepts/#event","title":"Event","text":"<p>An event has a name and can (optionally) provide ingredients.</p> <p>The purpose of events is therefor twofold.</p> <ol> <li> <p>It signifies something of interest happened for a process instance.</p> <p>Example, \"the customer placed the order\", \"terms and conditions were accepted\"</p> </li> <li> <p>The event may provide ingredients required to continue the process.</p> <p>Example, \"OrderPlaced\" -&gt; <code>&lt;list of products&gt;</code></p> </li> </ol> <p>We distinquish 2 types of events.</p> <ol> <li> <p>Sensory events (external)</p> <p>These events are provided from outside of the process.</p> </li> <li> <p>Interaction output (internal)</p> <p>These events are a result of an interaction being executed.</p> </li> </ol>"},{"location":"archive/concepts/#recipe","title":"Recipe","text":"<p>Events, Interactions and Ingredients can be composed into recipes.</p> <p>Recipes are analagous to process blueprints.</p> <p>Baker provides a Recipe DSL in which you can declaritively describe your recipe.</p> <p>A small example: <pre><code>new Recipe(\"webshop\")\n    .withSensoryEvents(\n        OrderPlaced.class,\n        CustomerInfoReceived.class\n    .withInteractions(\n        of(ValidateOrder.class),\n        of(ManufactureGoods.class));\n</code></pre></p> <p>The main take away is that when declaring your recipe you do not have to think about order.</p> <p>Everything is automatically linked by the data requirements of the interactions.</p>"},{"location":"archive/dictionary/","title":"Dictionary","text":"<p>Here we define some common used lanuage that is used in this documentation.</p> Name Description Recipe A process blue print Recipe id A unique identifier for a Recipe which is computed (a hash). Process instance A running instance of a Recipe Process id A unique identifier for a process instance which is chosen by the user. Sensory event An event given to baker for a process instance"},{"location":"archive/event-listener/","title":"Event Listener","text":"<p>Often it may be of interest to be notified of events that occur while operating Baker.</p> <p>There are 2 types of events that can be subscribed to.</p> <ol> <li>Events defined in your recipe that occur in the context of a process instance.</li> <li>Technical / internal events that occur within the baker runtime.</li> </ol>"},{"location":"archive/event-listener/#important-limitations","title":"Important limitations","text":"<ol> <li> <p>Event delivery is asynchronous, NO order guarantee is given</p> <p>All events do come with time stamps.</p> </li> <li> <p>Event delivery is AT MOST ONCE</p> <p>In case of ungraceful shutdown, you may miss events.</p> </li> </ol> <p>Because of these limitations it is not recommended to use these listeners for primary business logic.</p>"},{"location":"archive/event-listener/#process-instance-events","title":"Process instance events","text":"<p>You might be interested which Events are raised for process instances of a recipe.</p> <p>For this purpose there is an EventListener interface.</p> <p>You may implement this interface and register it to Baker.</p> ScalaJava <pre><code>val listener: EventListener = new EventListener {\n   override def processEvent(recipeInstanceId: String, event: RuntimeEvent) = ???\n}\n\nval baker: Baker = ??? // initialize baker\n\nbaker.registerEventListener(listener);\n</code></pre> <pre><code>EventListener listener = new EventListener() {\n   @Override\n   public void processEvent(String recipeInstanceId, RuntimeEvent event) {\n      //\n   }\n}\n\nJBaker baker = null; // initialize baker\n\nbaker.registerEventListener(listener);\n</code></pre>"},{"location":"archive/event-listener/#internal-events","title":"Internal events","text":"<p>For the purpose of logging, tracing, etc.. is is possible to register to internal events that happen inside Baker.</p>"},{"location":"archive/event-listener/#list-of-events","title":"List of events","text":"Class Description ProcessCreated A process instance was created EventReceived A sensory event for a process instance was received EventRejected A sensory event for a process instance was rejected InteractionStarted An interaction started executing InteractionCompleted An interaction completed executing InteractionFailed An interaction failed during execution RecipeAdded A Recipe was added"},{"location":"archive/event-listener/#subscription-mechanism","title":"Subscription mechanism","text":"<p>You can subscribe to these events by registering a listener to baker.</p> <p>In scala partial functions are used.</p> <p>In java you can register objects that have methods annotated with <code>@Subscribe</code>.</p> <p>In case you are interested in ALL events you can register to the general BakerEvent.</p> <p>In the example below a listener is registered that is only interested in <code>EventReceived</code>:</p> ScalaJava <pre><code>import com.ing.baker.runtime.core.events._\n\nval baker: com.ing.baker.runtime.scaladsl.Baker = ??? // initialize baker\n\nbaker.registerListenerPF {\n\n    case e: EventReceived =&gt; // ...\n}\n</code></pre> <pre><code>import com.ing.baker.runtime.core.events.*;\n\nclass Subscriber {\n\n   @Subscribe\n   public void receiveEventReceived(EventReceived event) {\n      // ...\n   }\n}\n\ncom.ing.baker.runtime.javadsl.JBaker baker = null; // initialize baker\n\nbaker.registerEventListener(new Subscriber());\n</code></pre>"},{"location":"archive/execution-semantics/","title":"Execution Semantics","text":""},{"location":"archive/execution-semantics/#execution-loop","title":"Execution loop","text":"<p>This is a short description of the execution loop of a process instance</p> <ol> <li> <p>A <code>EventInstance</code> is raised and provides <code>IngredientInstances</code>.</p> <p>Either given to baker as a \"SensoryEvent\" (nickname for <code>EventInstances</code> that you fire using Baker APIs)  or by an <code>InteractionInstance</code>.</p> </li> <li> <p>A check is done to find the <code>Interactions</code> that have all their input <code>IngredientInstances</code> provided and those are executed.</p> </li> <li>An <code>InteractionInstance</code> completes its execution and outputs an <code>EventInstances</code> which provides more <code>IngredientInstances</code>     for the next <code>InteractionInstnaces</code> (repeating step 1).</li> </ol>"},{"location":"archive/execution-semantics/#notes","title":"Notes","text":"<ul> <li>A sensory event may be provided 1 or more times depending on its firing limit.</li> <li>When ingredients are provided multiple times, the latest value overrides the previous.</li> <li>An interaction fires when all it's ingredients and required events are provided.     This may happen 1 or more times depending on the maximum interaction count.</li> </ul> <p>To know more you will first need to understand the how a petri net works.</p> <p>Below is an explanation of how a recipe relates to a petri net.</p>"},{"location":"archive/execution-semantics/#in-depth","title":"In depth","text":"<p>A recipe can be represented (and visualized) as a graph.</p> <p>This graph is actually a higher level representation of a petri net (which is also a graph).</p> <p>The execution of a process instance is based around the state of a petri net.</p> <p>The recipe compiler takes a recipe and creates a petri net from it.</p> <p>Generally the petri net graph is more complicated with extra layers of wiring nodes.</p>"},{"location":"archive/execution-semantics/#translation-rules","title":"Translation rules","text":"<p>The compiler has some rules about translating recipe parts to <code>transitions</code> and <code>places</code> in the petri net.</p>"},{"location":"archive/execution-semantics/#ingredient-used-by-multiple-interactions","title":"Ingredient used by multiple interactions","text":"<p>Often an ingredient will be used by multiple interactions in a recipe.</p> <p>Because tokens can only be consumed by 1 transition we have to add a layer to duplicate the token for all transitions.</p> <p></p>"},{"location":"archive/execution-semantics/#interaction-with-precondition-and","title":"Interaction with precondition (AND)","text":"<p>By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction.</p> <p></p>"},{"location":"archive/execution-semantics/#interaction-with-precodition-or","title":"Interaction with precodition (OR)","text":"<p>Events that are grouped in an OR combinator for an interaction output a token to the same place, therefor when one of  them fires the condition for the transition to fire is met.</p> <p></p>"},{"location":"archive/execution-semantics/#sensory-event-with-firing-limit","title":"Sensory event with firing limit","text":"<p>When specifying a sensory event with a firing limit of <code>n</code> we generate a in-adjacent place with <code>n</code> tokens in the initial marking.</p> <p></p>"},{"location":"archive/feature-comparison/","title":"Feature comparison","text":"<p>This is a comparison of Baker with similar solutions. Feedback and contributions to solutions not listed are most welcome.</p> Feature Baker Camunda Pega Netflix Conductor Uber Cadence Apache Airflow Owned By ING Camunda PEGA Systems Netflix Uber Community Primary Purpose Orchestration of (micro-)services Process Automation Workflow or case management Orchestration of (micro-)services Orchestration of long-running business logic Workflow of big-data pipelines Typical Use Straight Through Processing (STP) Business Processes with Decision Making Business Processes with Decision Making STP STP Big data Skill-set required Java or Scala Java, Business Process Modelling Notation (BPMN) Pega-specific JSON Java Python, Bash Execution Model Petri-net BPMN for workflows, Decision Model and Notation (DMN) for business rules Don\u2019t know Queueing Theory Queueing Theory Graph Theory In-memory processing Yes Yes No Yes No No Data Persistence Event sourcing with Cassandra Relational DB via JDBC Relational Dedicated Storage (Dynomite) Cassandra N/A Process Visualization Graphviz Based on BPMN Based on BPMN Dedicated UI No Dedicated UI License Model Open-source Community Platform is open-source Pay per Case Open-source Open-source Open-source Rich UI No Yes Yes Yes No Yes"},{"location":"archive/getting-started/","title":"Getting started","text":""},{"location":"archive/getting-started/#project-setup","title":"Project setup","text":"<p>Baker is released to maven central.</p> <p>You can add following dependencies to your <code>maven</code> or <code>sbt</code> project to start using it:</p> SbtMaven <pre><code>dependencies += \"com.ing.baker\" %% \"baker-recipe-dsl\" % \"2.0.3\"\ndependencies += \"com.ing.baker\" %% \"baker-compiler\" % \"2.0.3\"\ndependencies += \"com.ing.baker\" %% \"baker-runtime\" % \"2.0.3\"\n</code></pre> <pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n   &lt;artifactId&gt;baker-recipe-dsl_2.12&lt;/artifactId&gt;\n   &lt;version&gt;2.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n   &lt;artifactId&gt;baker-compiler_2.12&lt;/artifactId&gt;\n   &lt;version&gt;2.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n   &lt;artifactId&gt;baker-runtime_2.12&lt;/artifactId&gt;\n   &lt;version&gt;2.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This includes ALL baker modules to your project. If you only need partial functionality you can pick and choose the modules you need.</p>"},{"location":"archive/getting-started/#modules","title":"Modules","text":"<p>An explanation of the baker modules.</p> Module Description recipe-dsl DSL to describe your recipes (process blueprints) declaritively runtime Runtime based on Akka to manage and execute your recipes compiler Compiles your recipe description into a model that the runtime can execute intermediate-language Recipe and Petri-net model that the runtime can execute <p>This is the dependency graph between the modules.</p> <p></p>"},{"location":"archive/getting-started/#continuing-from-here","title":"Continuing from here","text":"<p>After adding the dependencies you can continue to:</p> <ul> <li>Familiarize yourself with the concepts.</li> <li>Immediately start writing your recipes.</li> </ul>"},{"location":"archive/interactions/","title":"Interactions","text":""},{"location":"archive/interactions/#defining","title":"Defining","text":"<p>You define an interaction with a java interface. An example:</p> <pre><code>package com.example;\n\nimport com.ing.baker.recipe.annotations.*;\nimport javax.inject.Named;\n\npublic interface ValidateOrder {\n\n    interface Outcome { }\n\n    class Failed extends Outcome { }\n\n    class Valid extends Outcome { }\n\n    @FiresEvent(oneOf = {Failed.class, Valid.class})\n    Outcome apply(@recipeInstanceId String recipeInstanceId,\n                  @Named(\"order\") String key);\n}\n</code></pre> <p>To be used as an interaction the interface requires an <code>apply</code> method with some restrictions.</p> <ul> <li> <p>The method must be annotated with <code>`@FiresEvent</code></p> </li> <li> <p>ALL arguments must be annotated:</p> <p><code>@Named</code> or <code>@RequiresIngredient</code> are used for ingredient data that the interaction requires, the name must be specfied.</p> <p><code>@recipeInstanceId</code> is used for injecting the process id.</p> </li> <li> <p>The output classes have the same restrictions as sensory events.</p> </li> </ul>"},{"location":"archive/interactions/#implementation","title":"Implementation","text":"<p>Implementation is just implementing the interface. Nothing to explain here.</p>"},{"location":"archive/migration-guide/","title":"Migration Guide","text":""},{"location":"archive/migration-guide/#from-13x-to-200","title":"From 1.3.x to 2.0.0","text":"<p>This guide only describes how to migrate your existing application.</p> <p>Summary:</p> <ul> <li>ALL persisted data from baker <code>1.3.x</code> IS COMPATIBLE and can be used with <code>2.0.x</code></li> <li>When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol.</li> <li>Some small code refactors are necessary (see below).</li> </ul> <p>For a full list new features see the changelog.</p>"},{"location":"archive/migration-guide/#downtime-required-for-clusters-with-state","title":"Downtime required for clusters with state","text":"<p>In <code>2.0.0</code> some binary incompatible changes where made in the message protocol.</p> <p>This requires you to bring down the entire cluster (<code>1.3.x</code>) and bring it up again (<code>2.0.0</code>).</p> <p>A rolling deploy IS NOT tested and NOT recommended.</p>"},{"location":"archive/migration-guide/#removed-ingredient-interface","title":"Removed Ingredient interface","text":"<p><code>com.ing.baker.recipe.javadsl.Ingredient</code> was removed.</p> <p>This was a tagging interface that was not used in the project.</p> <p>You can remove all references to this interface in your project.</p> <p>One thing to note is that <code>Ingredient</code> extended from <code>scala.Serializable</code>.</p> <p>If you depended on this behaviour just replace <code>Ingredient</code> by <code>scala.Serializable</code>.</p>"},{"location":"archive/migration-guide/#providesingredient-removed","title":"@ProvidesIngredient removed","text":"<p>In <code>1.3.x</code> you could directly provide an ingredient from an interaction. For example:</p> <pre><code>import com.ing.baker.recipe.annotations.ProvidesIngredient;\n\ninterface GetEmail {\n\n  @ProvidesIngredient(\"email\")\n  String apply(@RequiresIngredient(\"customer\") Customer customer);\n}\n</code></pre> <p>This feature has been removed. Internally this was already translated to an implicitly generated event: <code>$interactionName + Successful</code>.</p> <p>Now it is required that you do this expclitly to avoid confusion.</p> <p>The refactor is very straight forwfard:</p> <pre><code>import com.ing.baker.recipe.annotations.FiresEvent;\n\ninterface GetEmail {\n\n  public class GetEmailSuccessful {\n    public final String email;\n    public ExampleInteractionSuccessful(String email) {\n      this.email = email;\n    }\n  }\n\n  @FiresEvent(oneOf = { GetEmailSuccessful.class } )\n  GetEmailSuccessful apply(@RequiresIngredient(\"customer\") Customer customer);\n}\n</code></pre> <p>If you use lombok annotations you can get rid of a lot of the boiler plate by using <code>@Value</code> on the event class.</p> <p>In <code>scala</code> it is recommended to use case classes.</p>"},{"location":"archive/process-execution/","title":"Process Execution","text":""},{"location":"archive/process-execution/#recap","title":"Recap","text":"<p>On the runtime page we discussed how you could initialize Baker and add your recipe to it.</p> <p>Lets summarize what we have done so far.</p> ScalaJava <pre><code>// To execute a recipe you will need a Baker instance\n// This should be the same instance as you used to register your Recipe\nval baker: Baker = ???\n\n// The recipe id was given to us when we add our Recipe to Baker\nval recipeId: String = ???\n</code></pre> <pre><code>// To execute a recipe you will need a Baker instance\n// This should be the same instance as you used to register your Recipe\nJBaker baker = null; //\n\n// The recipe id was given to us when we add our Recipe to Baker\nString recipeId = \"...\";\n</code></pre>"},{"location":"archive/process-execution/#create-a-process-instance","title":"Create a process instance","text":"<p>Given a valid recipe id we can now execute a Recipe.</p> <p>Or in other words we can create a process instance.</p> ScalaJava <pre><code>// Assuming you have a compiled recipe\nval recipe: CompiledRecipe = ???\n\n// A unique identifier ment to distinguish this process from other process instances\nval recipeInstanceId = \"a-unique-process-id\"\n\n// Tell Baker that we want to create a new process for a certain recipe.\nbaker.bake(recipe.recipeId, recipeInstanceId)\n</code></pre> <pre><code>// Assuming you have a compiled recipe\nCompiledRecipe recipe = null; //\n\n// A unique identifier ment to distinguish this process from other process instances\nString recipeInstanceId = \"a-unique-process-id\";\n\n// Tell Baker that we want to create a new process for a certain recipe.\nbaker.bake(recipe.recipeId(), recipeInstanceId);\n</code></pre>"},{"location":"archive/process-execution/#providing-a-sensory-event","title":"Providing a sensory event","text":"<p>In our webshop example the first events that can happen are <code>OrderPlaced</code>, <code>PaymentMade</code> and <code>CustomerInfoReceived</code>.</p> <p>These are so called sensory events since they are not the result of an interaction but must be provided by the user of Baker.</p> ScalaJava <pre><code>// The CustomerInfoReceived and OrderPlaced events require some data (Ingredients)\nval customerInfo = CustomerInfo(\"John\", \"Elm. Street\", \"johndoe@example.com\")\nval order = \"123\";\n\n// Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events.\nbaker.processEvent(recipeInstanceId, CustomerInfoRecived(customerInfo))\nbaker.processEvent(recipeInstanceId, OrderPlaced(order))\n</code></pre> <pre><code>// The CustomerInfoReceived and OrderPlaced events require some data (Ingredients)\nCustomerInfo customerInfo = new CustomerInfo(\"John\", \"Elm. Street\", \"johndoe@example.com\");\nString order = \"123\";\n\n// Lets produce the `OrderPlaced` and `CustomerInfoReceived` sensory Events.\nbaker.processEvent(recipeInstanceId, new CustomerInfoReceived(customerInfo));\nbaker.processEvent(recipeInstanceId, new OrderPlaced(order));\n</code></pre> <p>When receiving events Baker will check which Interactions have all the required Ingredients and Events met.</p> <p>It will execute those interactions.</p> <p>Those interactions will raise more events.</p> <p>For more information about the exact execution sementics see here.</p>"},{"location":"archive/process-execution/#correlation-id","title":"Correlation id","text":"<p>Optionally you may provide a <code>correlation id</code> with an event. The purpose of this identifier is idempotent event delivery.</p> <p>When sending the same event correlation id multiple times, only the first will be processed.</p> <p>This can be applied to the <code>OrderPlaced</code> event for example.</p> ScalaJava <pre><code>val orderId = \"a unique order id\"\n\nval statusA: SensoryEventStatus = baker.processEvent(recipeInstanceId, new OrderPlaced(order), orderId)\nval statusB: SensoryEventStatus = baker.processEvent(recipeInstanceId, new OrderPlaced(order), orderId)\n\n// statusA == Received\n// statusB == AlreadyReceived\n</code></pre> <pre><code>String orderId = \"a unique order id\";\n\nSensoryEventStatus statusA = baker.processEvent(recipeInstanceId, new OrderPlaced(order), orderId);\nSensoryEventStatus statusB = baker.processEvent(recipeInstanceId, new OrderPlaced(order), orderId);\n\n// statusA == Received\n// statusB == AlreadyReceived\n</code></pre>"},{"location":"archive/process-execution/#sensory-event-status","title":"Sensory event status","text":"<p>In response to receiving a sensory event Baker returns a status code indicating how it processed it.</p> Status Description <code>Received</code> The event was received normally <code>AlreadyReceived</code> An event with the same correlation id was already received <code>ProcessDeleted</code> The process instance was deleted <code>ReceivePeriodExpired</code> The receive period for the process instance has passed <code>FiringLimitMet</code> The firing limit for the event was met"},{"location":"archive/process-execution/#incident-resolving","title":"Incident resolving","text":"<p>It is possible that during execution a process instance becomes blocked.</p> <p>This can happen either because it is directly blocked by a exception or that the retry strategy was exhuasted.</p> <p>At this point it is possible to resolve the blocked interaction in 2 ways.</p>"},{"location":"archive/process-execution/#1-force-retry","title":"1. Force retry","text":"<p>For example, the retry strategy for \"SendInvoice\" was exhausted after a few hours or retrying.</p> <p>However, we checked and know the \"invoice\" service is up again and want to continue to process for our customer.</p> ScalaJava <pre><code>baker.retryInteraction(recipeInstanceId, \"SendInvoice\")\n</code></pre> <pre><code>baker.retryInteraction(recipeInstanceId, \"SendInvoice\");\n</code></pre>"},{"location":"archive/process-execution/#2-specify-the-interaction-output","title":"2. Specify the interaction output","text":"<p>For example, the \"ShipGoods\" backend service is not idempotent and failed with an exception. It is not retried but blocked.</p> <p>However, we checked and know the goods were actually shipped and want to continue the process for our customer.</p> ScalaJava <pre><code>baker.resolveInteraction(recipeInstanceId, \"ShipGoods\", GoodsShipped(\"some goods\"))\n</code></pre> <pre><code>baker.resolveInteraction(recipeInstanceId, \"ShipGoods\", new GoodsShipped(\"some goods\"));\n</code></pre> <p>Note that the event provided SHOULD NOT include any event or ingredient renames specified for the interaction.</p>"},{"location":"archive/process-execution/#state-inquiry","title":"State inquiry","text":"<p>During runtime it is often useful to inquire on the state of a process instance.</p>"},{"location":"archive/process-execution/#visualize-process-instance-state","title":"Visualize process instance state","text":"<p>We can use the visualizer to see what Baker has done with the given events.</p> ScalaJava <pre><code>val dotRepresentation: String = baker.getVisualState(recipeInstanceId)\n</code></pre> <pre><code>String dotRepresentation = baker.getVisualState(recipeInstanceId);\n</code></pre> <p>Did you know?!</p> <p>You can ask baker for a visual representation of a certain process. That way you can see which Events were provided and which Interaction were run. See the visualization page how to create a visual graph.</p> <p></p> <p>The image shows us that the <code>ValidateOrder</code> Interaction is colored green which means that the Interaction has been exucuted. Baker was able to exeucte the Interaction because all required Events and Ingredients where provided. The <code>ValidateOrder</code> Interaction in turn produced the <code>Valid</code> event.</p> <p>We can also see that the <code>ManufactureGoods</code> Interaction is still purple, meaning that it has not been executed. This is correct because <code>ManufactureGoods</code> requires an additional event called <code>PaymentMade</code>.</p>"},{"location":"archive/process-execution/#events","title":"Events","text":"<p>We can ask Baker for a list of all the events for our process.</p> <p>Using this list we can check if the <code>InvoiceWasSend</code> event was produced.</p> ScalaJava <pre><code>// Get all events that have happend for this process instance\nval events: Seq[RuntimeEvent] = baker.getEvents(recipeInstanceId)\nif (events.exists(_.name == \"InvoiceWasSend\"))\n    // Yes the invoice was send!\n</code></pre> <pre><code>// Get all events that have happend for this process instance\nEventList events = baker.getEvents(recipeInstanceId);\nif (events.hasEventOccurred(InvoiceWasSend.class))\n    // Yes the invoice was send!\n</code></pre>"},{"location":"archive/process-execution/#ingredients","title":"Ingredients","text":"<p>Sometimes it is useful to know what the ingredient values are accumulated for a process instance.</p> <p>For example, you might want to know the value of the <code>trackingId</code>.</p> ScalaJava <pre><code>// Get all ingredients that are accumulated for a process instance\nval ingredients: Map[String, Value] = baker.getIngredients(recipeInstanceId)\n\nval trackingId: String = ingredients(\"trackingId\").as[String]\n</code></pre> <pre><code>// Get all ingredients that are accumulated for a process instance\nMap&lt;String, Value&gt; ingredients = baker.getIngredients(recipeInstanceId);\n\nString trackingId = ingredients.get(\"trackingId\").as(String.class);\n</code></pre>"},{"location":"archive/recipe-dsl/","title":"Recipe DSL","text":"<p>The recipe DSL allows you to declaritively describe your process.</p> <p>Let's start with the web shop recipe as an example.</p> <p>The complete code example can be found here.</p> <pre><code>final Recipe webshopRecipe = new Recipe(\"webshop\")\n    .withSensoryEvents(\n        OrderPlaced.class,\n        CustomerInfoReceived.class,\n        PaymentMade.class)\n    .withInteractions(\n        of(ValidateOrder.class),\n        of(ManufactureGoods.class)\n            .withRequiredEvents(PaymentMade.class, ValidateOrder.Valid.class),\n        of(SendInvoice.class)\n            .withRequiredEvents(ShipGoods.GoodsShipped.class),\n        of(ShipGoods.class))\n    .withDefaultFailureStrategy(\n        new RetryWithIncrementalBackoffBuilder()\n            .withInitialDelay(Duration.ofMillis(100))\n            .withDeadline(Duration.ofHours(24))\n            .withMaxTimeBetweenRetries(Duration.ofMinutes(10))\n            .build());\n</code></pre>"},{"location":"archive/recipe-dsl/#sensory-events","title":"Sensory events","text":"<p>Events are simple <code>POJO</code> classes. For example:</p> ScalaJava <pre><code>case class CustomerInfoReceived(customerInfo: CustomerInfo)\n</code></pre> <pre><code>public class CustomerInfoReceived {\n    public final CustomerInfo customerInfo;\n\n    public CustomerInfoReceived(CustomerInfo customerInfo) {\n        this.customerInfo = customerInfo;\n    }\n}\n</code></pre> <p>The field types of the <code>POJO</code> class must be compatible with the Baker type system.</p> <p>See the supported types for more information.</p> <p>The names of the fields are obtained using java reflection.</p> <p>They can be added using the <code>.withSensoryEvents(..)</code> method.</p>"},{"location":"archive/recipe-dsl/#firing-limit","title":"Firing limit","text":"<p>A firing limit is a limit on the number of times a sensory event may be received by a process instance.</p> <p>By default sensory events have a firing limit of <code>1</code> per process instance.</p> <p>This means the event will be rejected with status <code>FiringLimitMet</code> after the first time it is received.</p> <p>If you want to send an event more then once you may add it like this:</p> <pre><code>   .withSensoryEventsNoFiringLimit(CustomerInfoReceived.class)\n</code></pre> <p>In this example the <code>CustomerInfoReceived</code> can now be received multiple times by a process instance.</p>"},{"location":"archive/recipe-dsl/#interactions","title":"Interactions","text":"<p>Interactions are interfaces with some requirements. See here how to define them.</p> <p>You can include interactions in your recipe using the static <code>of(..)</code> method.</p> <pre><code>import static com.ing.baker.recipe.javadsl.InteractionDescriptor.of;\n\nfinal Recipe webshopRecipe = new Recipe(\"webshop\")\n    .withInteractions(\n        of(ValidateOrder.class)\n    )\n</code></pre> <p>There are a number of options to tailor an interaction for your recipe.</p>"},{"location":"archive/recipe-dsl/#maximum-interaction-count","title":"Maximum interaction count","text":"<p>By default there is no limit on the number of times an Interaction may fire.</p> <p>Sometimes you may want to set a limit.</p> <p>For example, to ensure the goods are shipped only once.</p> <pre><code>    .withInteractions(\n        of(ShipGoods.class).withMaximumInteractionCount(1)\n     )\n</code></pre>"},{"location":"archive/recipe-dsl/#predefining-ingredients","title":"Predefining ingredients","text":"<p>An interaction normally requires all its input ingredients to be provided from Events.</p> <p>Sometimes however it is useful to predefine (or hard code) the value of an ingredient.</p> <p>For example:</p> <ul> <li>An email template</li> <li>An application/requester id when calling an external system</li> </ul> <p>This can be done by:</p> <pre><code>  .withInteractions(\n    of(SendEmail.class)\n      .withPredefinedIngredient(\"emailTemplate\", \"Welcome to ING!\")\n  )\n</code></pre> <p>Note that predefined ingredients are always available and do not have to be provided by an event for each interaction call.</p> <p>Each time all remaining ingredients are provided, the interaction will fire.</p> <p>You can not predefine ALL input ingredients of an interaction.</p>"},{"location":"archive/recipe-dsl/#event-renames","title":"Event renames","text":"<p>Sometimes it useful to rename an interaction event and/or its ingredients to fit better in the context of your recipe.</p> <p>For example, to rename the <code>GoodsManufactured</code> event and its ingredient.</p> <pre><code>  .withInteractions(\n    of(ManufactureGoods.class)\n      .withEventTransformation(\n        GoodsManufactured.class, \"ManufacturingDone\",\n        ImmutableMap.of(\"goods\", \"manufacturedGoods\")\n      )\n    )\n  )\n</code></pre>"},{"location":"archive/recipe-dsl/#event-requirements","title":"Event requirements","text":"<p>As mentioned before, the DSL is declarative, you do not have to think about order. This is implicit in the data requirements of the interactions.</p> <p>However, sometimes data requirements are not enough.</p> <p>For example, you might want to be sure to only send an invoice (<code>SendInvoice</code>) AFTER the goods where shipped (<code>GoodsShipped</code>).</p> <pre><code>    of(SendInvoice.class)\n        .withRequiredEvents(ShipGoods.GoodsShipped.class)\n</code></pre> <p>In this case the <code>GoodsShipped</code> event MUST happen before the interaction may execute.</p> <p>You can specify multiple events in a single clause. These are bundled with an <code>AND</code> condition, meaning ALL events in the clause are required.</p> <p>You can also require a single event from a number of options.</p> <pre><code>    of(SendInvoice.class)\n        .withRequiredOneOfEvents(EventA.class, EventB.class)\n</code></pre> <p>In this case the interaction may fire if either <code>EventA</code> OR <code>EventB</code> has occured.</p>"},{"location":"archive/recipe-dsl/#interaction-failure-strategy","title":"Interaction Failure strategy","text":"<p>When an interaction throws an exception there are a number of mitigation strategies:</p>"},{"location":"archive/recipe-dsl/#block-interaction","title":"Block interaction","text":"<p>This is the DEFAULT strategy if no other is defined and no default strategy is defined.</p> <p>This option is suitable for non idempotent interactions that cannot be retried.</p> <p>When an exception is thrown from the interaction the interaction is blocked.</p> <p>This means that the interaction cannot execute again automatically.</p> <p>It requires manual intervening to continue the process from then on.</p>"},{"location":"archive/recipe-dsl/#fire-event","title":"Fire event","text":"<p>This option is analagous to a <code>try { } catch { }</code> in code. When an exception is raised from the interaction you specify an event to fire. So instead of failing the process continues.</p> <p>Example:</p> <pre><code>  .withInteractions(\n    of(ValidateOrder.class)\n    .withInteractionFailureStrategy(\n       InteractionFailureStrategy.FireEvent(\"ValidateOrderFailed\")\n     )\n   )\n</code></pre>"},{"location":"archive/recipe-dsl/#retry-with-incremental-backoff","title":"Retry with incremental backoff","text":"<p>Incremental backoff allows you to configure a retry mechanism that takes longer for each retry. The idea here is that you quickly retry at first but slower over time. To not overload your system but give it time to recover.</p> <pre><code>  .withInteractions(\n    of(ValidateOrder.class)\n      .withFailureStrategy(new RetryWithIncrementalBackoffBuilder()\n        .withInitialDelay(Duration.ofMillis(100))\n        .withBackoffFactor(2.0)\n        .withMaxTimeBetweenRetries(Duration.ofSeconds(100))\n        .withDeadline(Duration.ofHours(24))\n        .build())\n  )\n</code></pre> <p>What do these parameters mean?</p> name meaning <code>initialDelay</code> The delay for the first retry. <code>backoffFactor</code> The backoff factor for the delay (optional, <code>default = 2</code>) <code>maxTimeBetweenRetries</code> The maximum interval between retries. <code>deadLine</code> The maximum total amount of time spend delaying. <p>For our example this results in the following delay pattern:</p> <p><code>100 millis</code> -&gt; <code>200 millis</code> -&gt; <code>400 millis</code> -&gt; <code>...</code> -&gt;  <code>100 seconds</code> -&gt; <code>100 seconds</code></p> <p>Which can be visualized like this:</p> <p></p> <p>Note that these delays do not include interaction execution time.</p> <p>For example, if the first retry execution takes <code>5</code> seconds (and fails again) then the second retry will be triggered after (from the start):</p> <p><code>(100 millis + 5 seconds + 200 millis) = 5.3 seconds</code></p> <p>This also means that the <code>24 hour</code> deadline does not include interaction execution time. It is advisable to take this into account when coming up with this number.</p> <p>Retry exhaustion</p> <p>It can happen that after some time, when an interaction keeps failing, that the retry is exhausted.</p> <p>When this happens 2 things may happen.</p> <p>Either the interaction becomes [blocked(#blocked-interaction).</p> <p>Or if you configure so, the process continues with a predefined event:</p> <pre><code>.withFailureStrategy(new RetryWithIncrementalBackoffBuilder()\n  .withFireRetryExhaustedEvent(SomeEvent.class))\n</code></pre> <p>Note that this event class requires an empty constructor to be present and cannot provide ingredients.</p>"},{"location":"archive/recipe-dsl/#default-failure-strategy","title":"Default failure strategy","text":"<p>You can also define a default failure strategy on the recipe level.</p> <p>This then serves as a fallback if none is defined for an interaction.</p> <p>For example:</p> <pre><code>final Recipe webshopRecipe = new Recipe(\"webshop\")\n    .withDefaultFailureStrategy(\n        new RetryWithIncrementalBackoffBuilder()\n            .withInitialDelay(Duration.ofMillis(100))\n            .withDeadline(Duration.ofHours(24))\n            .withMaxTimeBetweenRetries(Duration.ofMinutes(10))\n            .build());\n</code></pre>"},{"location":"archive/recipe-visualization/","title":"Recipe Visualization","text":"<p>Here we explain how to create a visual representation of your recipe like this one</p>"},{"location":"archive/recipe-visualization/#generate-a-dot-representation","title":"Generate a .dot representation","text":"<p>Baker can turn a recipe into a .dot representation. <code>.dot</code> is a notation for representing graphs.</p> ScalaJava <pre><code>val recipe = RecipeCompiler.compileRecipe(Examples.webshop.webShopRecipe)\n\nprintln(recipe.getRecipeVisualization)\n</code></pre> <pre><code>final CompiledRecipe recipe = RecipeCompiler.compileRecipe(Examples.webshop.webShopRecipe);\n\nSystem.out.println(recipe.getRecipeVisualization());\n</code></pre> <p>This should output something like this:</p> <pre><code>digraph d {\n  A [label=\"Hello\"]\n  B [label=\"World\"]\n  C [label=\"Everyone\"]\n  A -&gt; { B C }\n}\n</code></pre>"},{"location":"archive/recipe-visualization/#visualize","title":"Visualize","text":"<p>Once you have a <code>.dot</code> representation there are a few methods to visualize this.</p>"},{"location":"archive/recipe-visualization/#online","title":"Online","text":"<p>You can copy the <code>.dot</code> string and use webgraphviz.com.</p>"},{"location":"archive/recipe-visualization/#local","title":"Local","text":"<p>To generate an image locally you require the <code>graphviz</code> tool. See graphviz.org on how to install it. On mac you can use <code>brew</code>.</p> <pre><code>brew install graphviz\n</code></pre> <p>Once installed the <code>dot</code> command can be used to create an SVG by running:</p> <pre><code>dot -v -Tsvg -O graph.dot\n</code></pre>"},{"location":"archive/recipe-visualization/#in-application","title":"In application","text":"<p>Alternatively you can use graphviz-java to generate the SVG in your code:</p> ScalaJava <pre><code>import guru.nidi.graphviz.engine.{Format, Graphviz}\nimport guru.nidi.graphviz.parse.Parser\n\nval graph = Parser.read(recipe.getRecipeVisualization)\nGraphviz.fromGraph(graph).render(Format.SVG).toString\n</code></pre> <pre><code>import guru.nidi.graphviz.engine.Format;\nimport guru.nidi.graphviz.engine.Graphviz;\nimport guru.nidi.graphviz.parse.Parser;\nimport guru.nidi.graphviz.model.MutableGraph;\n\nMutableGraph graph = Parser.read(recipe.getRecipeVisualization);\nGraphviz.fromGraph(graph).render(Format.SVG).toString;\n</code></pre>"},{"location":"archive/recipe-visualization/#style-customization","title":"Style customization","text":"<p>It is possible to define a custom visual style for your recipes.</p> <p>To do so you need to add some configuration in your <code>application.conf</code>:</p> <pre><code>baker.visualization {\n  style = \"custom\"\n  styles.custom = {\n     // place your style attributes here\n  }\n}\n</code></pre> <p>Please see the <code>default</code> theme in the reference.conf as an example.</p> <p>For an overview on what is possible to configure check out the graphviz documentation.</p> <p>It is not possible to alter the <code>shape</code> attribute, it is hard coded (fixed) for all elements in the graph.</p> <p>This is done to garuantee a common visual language for all recipes.</p>"},{"location":"archive/split-brain-resolver/","title":"Split Brain Resolver","text":""},{"location":"archive/split-brain-resolver/#description","title":"Description","text":"<p>Note: This feature is applicable to clustered baker configuration. If your Baker application is using local actors, thus not using Akka cluster, a Split Brain Resolver is not needed.</p> <p>Baker library, when configured to be a cluster, runs in an Akka cluster to distribute the baker processes over multiple nodes. Running a cluster with multiple nodes with shared state has some difficulties to tackle in some network failure scenarios, like network partitions.</p> <p>When there's a network partition in a cluster, the nodes at the different sides of the partition cannot receive messages from each other and eventually diverge their states unless it is a network hick-up. When this happens, you need a mechanism to prevent state inconsistency, i.e. by stopping nodes at one side of the partition, so the nodes at the surviving side still run with consistent states.</p> <p>A Split Brain Resolver algorithm for Akka prevents inconsistent states during network partitions, or huge network delays, or non-responding cluster members.</p> <p>Baker Split Brain Resolver is a general purpose implementation for Akka which could be configured for a Baker cluster as well as for another Akka cluster without bBker.</p>"},{"location":"archive/split-brain-resolver/#strategies","title":"Strategies","text":"<p>The current version of the Split Brain Resolver algorithm supports only the <code>Majority</code> strategy which makes the majority of the nodes survive and downs (terminates) the nodes at the minority side of the network partition. In case of the number of nodes on each side of the network partition are equal, the side with the oldest Akka node survives. By deciding to down one side, you do not end up with twi Akka clusters during the network partition.</p> <p>There could be other strategies implemented later, for now the <code>Majority</code> strategy works for most of the use cases. You can read about other possible strategies supported by the commercial Lightbend Split Brain Resolver here.</p> <p><code>Majority</code> strategy is configured by default, so you do not need extra configuration for this.</p>"},{"location":"archive/split-brain-resolver/#how-to-use","title":"How to use","text":"<p>In order to use Baker <code>SplitBrainResolver</code>, first of all, you need to add baker-split-brain-resolver dependency to your project. See example below:</p> SbtMaven <pre><code>libraryDependencies += \"com.ing.baker\" %% \"baker-split-brain-resolver\" % \"2.0.3\"\n</code></pre> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n  &lt;artifactId&gt;baker-split-brain-resolver_2.12&lt;/artifactId&gt;\n  &lt;version&gt;2.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Then the algorithm needs to be configured as the Akka downing provider and the <code>stable-after</code> config needs to set to some duration depending on your cluster size.</p> <p><code>stable-after</code> config is needed to decide on how quickly to react on the Akka cluster state changes. Very short durations may allow quicker 'downing' decisions for unreachable nodes, but may also cause to down some nodes unnecessarily too early. Please see the suggested values for this in the documentation of the commercial Lightbend Split Brain Resolver.</p> <p>One other Akka cluster configuration suggested keep in sync with <code>stable-after</code> is the <code>akka.cluster.down-removal-margin</code> config. The suggested values and more information on this config can be found in the Cluster Singleton and Cluster Sharding section of the commercial Lightbend Split Brain Resolver.</p> <p>Example config for a Baker cluster having less than 10 nodes is the following:</p> <pre><code>akka.cluster.down-removal-margin = 7 seconds\nakka.cluster.downing-provider-class = com.ing.baker.runtime.core.actor.downing.SplitBrainResolver\n\nbaker-split-brain-resolver {\n  stable-after = 7 seconds\n}\n</code></pre>"},{"location":"archive/type-system/","title":"Type system","text":"<p>The purpose of the type system is express the form of ingredients in baker.</p>"},{"location":"archive/type-system/#why-not-use-the-java-type-system","title":"Why not use the java type system?","text":"<ol> <li> <p>To garuantee that all data can be read back from persistent storage.</p> <p>This is for the benefit of being able to write generic analysis/data-mining tools on the persisted events.</p> </li> <li> <p>To run Baker As A Service, receiving new recipes at runtime.</p> <p>Unless opting for OSGi or similar, you cannot load new class definitions. This makes it very impractical or impossible to depend on java classes.</p> </li> </ol> <p>The main concepts in this type system are Types and Values.</p> <p>An important difference from type systems in programming languages is that Values do not have an explicit inherint type associated with them.</p> <p>You can argue whether you can call this a type system at all. Perhaps a schema system is more accurate.</p>"},{"location":"archive/type-system/#types","title":"Types","text":""},{"location":"archive/type-system/#primitives","title":"Primitives","text":"Type Java parallel Description <code>Bool</code> <code>boolean</code> single bit, <code>true</code> or <code>false</code>, <code>1</code> or <code>0</code> <code>Char</code> <code>char</code> Unsigned <code>16</code> bit integer <code>Byte</code> <code>byte</code> Signed <code>8</code> bit integer <code>Int16</code> <code>short</code> Signed <code>16</code> bit integer <code>Int32</code> <code>int</code> Signed <code>32</code> bit integer <code>Int64</code> <code>long</code> Signed <code>64</code> bit integer <code>IntBig</code> <code>BigInteger</code> Integer of arbitrary size <code>Float32</code> <code>float</code> Signed <code>32</code> bit floating point <code>Float64</code> <code>double</code> Signed <code>64</code> bit floating point <code>FloatBig</code> <code>BigDecimal</code> Floating point of arbitrary size <code>Date</code> <code>long</code> A UTC date in the ISO-8601 calendar system with millisecond precision <code>ByteArray</code> <code>Array&lt;Byte&gt;</code> Byte array, often used for binary data <code>CharArray</code> <code>String</code> Character array, or commmonly called <code>String</code>"},{"location":"archive/type-system/#structured-types","title":"Structured types","text":"Type Java parallel Description <code>ListType&lt;T&gt;</code> <code>java.util.List&lt;T&gt;</code> A list of values, all of the same type <code>OptionType&lt;T&gt;</code> <code>java.util.Optional&lt;T&gt;</code> Matches against <code>T</code> or <code>null</code> <code>EnumType</code> <code>enum class</code> A set of predifined options (strings) <code>RecordType</code> <code>POJO class</code> A record with a specific set of fields <code>MapType&lt;T&gt;</code> <code>java.util.Map&lt;String, T&gt;</code> A record with arbitrary fields, all of the same type"},{"location":"archive/type-system/#values","title":"Values","text":"<p>Values are pure data without any direct associated type. These very closely match the JSON data format.</p> Value Description <code>NullValue</code> Analogues to <code>null</code>, <code>Optional.empty</code>, <code>None</code>, etc ... <code>PrimitiveValue</code> Wrapper for for: - A Java primitive (or boxed variant) - <code>java.lang.String</code> - <code>java.math.BigInteger</code> - <code>java.math.BigDecimal</code> - <code>scala.math.BigInt</code> - <code>Array&lt;Byte&gt;</code> <code>ListValue</code> A list of values <code>RecordValue</code> A set of <code>String -&gt; Value</code> pairs"},{"location":"archive/type-system/#interoptability-with-java-types","title":"Interoptability with java types","text":"<p>Because it is impractical to directly work with the baker types in java/scala code there is conversion system.</p>"},{"location":"archive/type-system/#default-supported-types","title":"Default supported types","text":""},{"location":"archive/type-system/#java","title":"java","text":"<ul> <li>primitives and their boxed variants</li> <li>Enum types</li> <li>java.util.List</li> <li>java.util.Set</li> <li>java.util.Map</li> <li>java.math.BigInt</li> <li>java.math.BigDecimal</li> <li>java.util.Optional</li> <li>POJO classes</li> </ul>"},{"location":"archive/type-system/#scala","title":"scala","text":"<ul> <li>primitives and their boxed variants</li> <li>case classes</li> <li>scala.collection.immutable.List</li> <li>scala.collection.immutable.Set</li> <li>scala.collection.immutable.Map</li> <li>BigInt</li> <li>BigDecimal</li> <li>scala.Option</li> </ul>"},{"location":"archive/type-system/#registering-a-custom-type-adapter","title":"Registering a custom type adapter","text":"<p>All default type adapters are registered in the reference.conf of the <code>baker-types</code> module.</p> <p>You can add your custom type adapter by registering it in a <code>reference.conf</code>.</p> <pre><code>baker.types {\n\n   \"com.example.MyCustomType\" = \"com.example.MyCustomTypeAdpater\"\n}\n</code></pre> <p>For an example how to implement an adapter see here</p>"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/","title":"Declare, verify and execute microservices-based process flows with Baker","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#scale-by-the-bay-2017-san-francisco","title":"Scale By the Bay 2017, San Francisco","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#nikola-kasev-ing-bank","title":"Nikola Kasev | ING Bank","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#global-financial-institution-in-over-40-countries","title":"Global Financial Institution in Over 40 Countries","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#software-company-with-a-banking-license","title":"Software Company with a Banking License","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#microservices-architecture","title":"Microservices Architecture","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#our-challenge","title":"Our Challenge","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#interact-with-12-different-systems","title":"Interact with 12 Different Systems","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#a-flow-of-27-steps","title":"A Flow of 27 Steps","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#from-2-minutes-to-6-hours","title":"From 2 minutes to 6 hours","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#afraid-to-change-the-application-code","title":"Afraid to Change the Application Code","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#functionality-breaks-unexpectedly","title":"Functionality Breaks Unexpectedly","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#slow-time-to-market","title":"Slow Time to Market","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#how-to-turn-this-around","title":"How to Turn This Around?","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#simplify","title":"Simplify","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#domain-specific-language-for-orchestration-flows","title":"Domain Specific Language for Orchestration Flows","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#declarative","title":"Declarative","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#easy-to-change","title":"Easy to Change","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#recipes","title":"Recipes","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#interactions","title":"Interactions","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#ingredients","title":"Ingredients","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#events","title":"Events","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#communicate","title":"Communicate","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#visualize-your-code","title":"Visualize your code","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#non-it-understand-as-well","title":"Non-IT understand as well","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#reason-about-comfortably","title":"Reason About Comfortably","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#lets-cook-some-crepes","title":"Let's Cook Some Cr\u00eapes!","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#good-to-know","title":"Good to Know","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#short-lived-vs-long-running-flows","title":"Short-lived vs. long-running flows","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#state-is-taken-care-of","title":"State is taken care of:","text":"<ul> <li>Cassandra for persistent storage</li> <li>Ingredients encrypted by default</li> <li>State recovered automatically</li> </ul>"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#when-failure-occurs","title":"When failure occurs:","text":"<ul> <li>Baker retries technical failures with exponential backoff</li> <li>Works well with idempotent services</li> <li>Deal with functional failure in your recipe</li> </ul> <p>Baker Capability Matrix:</p> <ul> <li>Investigate not one, not two, but all business processes in your company</li> <li>Where do you see re-use?</li> <li>Map using MoSCoW^4 to give importance (M = 10, S = 5, C = 2, W = 1)</li> </ul> Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account <code>n/a</code> Issue Debit Card <code>n/a</code> <code>n/a</code> Send Message Send Message Send Message Register Ownerhip Register Ownership <code>n/a</code> <p></p>"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#httpsgithubcoming-bankbaker","title":"https://github.com/ing-bank/baker","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#why-petri-net3","title":"Why Petri net?^3","text":""},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#design-time","title":"Design-time","text":"<pre><code>val registerIndividual = Interaction(\n  name = \"RegisterIndividual\",\n  inputIngredients = Seq(name, address),\n  output = Seq(registerIndividualSuccessful, registerIndividualFailed)\n)\n</code></pre> <pre><code>val recipe = Recipe(\"OpenAccountRecipe\")\n  .withInteractions(\n    assignAccount,\n    getAccount,\n    registerIndividual)\n</code></pre> <pre><code>val recipe = Recipe(\"OpenAccountRecipe\")\n  .withInteractions(\n    assignAccount,\n    getAccount.withRequiredEvent(termsAndConditionsAccepted),\n    registerIndividual)\n  .withSensoryEvents(\n    termsAndConditionsAccepted,\n    individualInformationSubmitted)\n</code></pre>"},{"location":"archive/presentations/ScaleByTheBay-18-Nov-2017/#run-time","title":"Run-time","text":"<pre><code>//for each process instance, bake the recipe\nbaker.bake(recipeInstanceId);\n//notify Baker when events occur\nbaker.processEvent(recipeInstanceId, individualInformationSubmitted.instance(name, address));\nbaker.processEvent(recipeInstanceId, termsAndConditionsAccepted.instance());\n\n//retrieve ingredients stored in the accumulated state\nassert(baker.getIngredients(recipeInstanceId).get(\"customerId\").equals(customerId));\nassert(baker.getIngredients(recipeInstanceId).get(\"iban\").equals(iban));\n\n//retrieve all events that have occurred\nbaker.events(recipeInstanceId)\n</code></pre> <p>val groceriesDone = new Event(\"GroceriesDone\", Seq(milk, eggs, flour, butter, creme), Some(1))</p> <p>val mixFirstThree = Interaction(   name = \"MixFirstThree\",   inputIngredients = Seq(milk, eggs, flour),   output = Seq(batterMixed) )</p> <p>val mixFirstThreeImpl = mixFirstThree implement {   (milk: String, eggs: String, flour: String) =&gt;     println(s\"mixing $milk, $eggs, and $flour\")     batterMixed.instance(\"batter\") }</p> <p>I love cooking food and for the rest of the talk I'll be using examples from there. It's very similar to our industry: long hours, hard work, and delivering experiences to our customers.</p> <p>Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners, it still makes me shiver.</p> <p>If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients. So no matter what, we cannot escape the architectural discussion. If we are not careful of how we architect our applications we end up serving a bad meal to our clients.</p>"},{"location":"archive/presentations/baker-pitch/","title":"[fit] Orchestration Logic is Hard to Change","text":""},{"location":"archive/presentations/baker-pitch/#baker-is-a-java-library","title":"Baker is a Java Library","text":""},{"location":"archive/presentations/baker-pitch/#declare-the-logic-like-a-recipe","title":"Declare the Logic Like a Recipe","text":""},{"location":"archive/presentations/baker-pitch/#visualize-the-logic","title":"Visualize the Logic","text":""},{"location":"archive/presentations/baker-pitch/#dont-worry-about-retries-and-state","title":"Don't Worry About Retries and State","text":""},{"location":"archive/presentations/baker-pitch/#added-value","title":"Added Value","text":""},{"location":"archive/presentations/baker-pitch/#reuse-of-code-rapid-time-to-market","title":"Reuse of Code -&gt; Rapid Time to Market","text":""},{"location":"archive/presentations/baker-pitch/#visualization-business-and-it-speak-the-same-language","title":"Visualization -&gt; Business and IT Speak the Same Language","text":""},{"location":"archive/presentations/baker-pitch/#data-driven-refactoring-robust-software","title":"Data-driven Refactoring -&gt; Robust Software","text":""},{"location":"archive/presentations/baker-pitch/#under-the-hood","title":"Under the Hood","text":""},{"location":"archive/presentations/baker-pitch/#dsl-for-recipes","title":"DSL for Recipes","text":""},{"location":"archive/presentations/baker-pitch/#actor-model-with-petri-nets","title":"Actor Model with Petri nets","text":""},{"location":"archive/presentations/baker-pitch/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>```java, [.highlight: 3,4,6] return new Recipe(\"DemoAtTwitterHQ\").         withInteractions(                 of(AssignAccount.class),                 of(GetAccount.class).                         withRequiredEvent(TermsAndConditionsAccepted.class),                 of(RegisterIndividual.class)).         withSensoryEvents(                 TermsAndConditionsAccepted.class,                 IndividualInformationSubmitted.class); } <pre><code>---\n\n```java\n//notify Baker when events occur\nbaker.processEvent(recipeInstanceId, new SensoryEvents.IndividualInformationSubmitted(name, address));\nbaker.processEvent(recipeInstanceId, new SensoryEvents.TermsAndConditionsAccepted());\n</code></pre></p> <p></p>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/","title":"Declare, verify and execute microservices-based process flows with Baker","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#httpgithubcomnikolakasev-ing","title":"http://github.com/nikolakasev | ING","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#symptoms-of-a-failing-restaurant","title":"Symptoms of a Failing Restaurant","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#symptoms-of-a-failing-microservices-architecture","title":"Symptoms of a Failing (Microservices) Architecture","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#afraid-to-change-the-application-code","title":"Afraid to change the application code","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#functionality-breaks-unexpectedly","title":"Functionality breaks unexpectedly","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#slow-time-to-market","title":"Slow time to market","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#how-to-turn-this-around","title":"How to turn this around?","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#simplify","title":"Simplify","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#domain-specific-language-for-orchestration-flows","title":"Domain Specific Language for orchestration flows","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#declarative","title":"Declarative","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#easy-to-change","title":"Easy to change","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#reuse","title":"Reuse","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#recipes","title":"Recipes","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#interactions","title":"Interactions","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#ingredients","title":"Ingredients","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#events","title":"Events","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#communicate","title":"Communicate","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#visualize-your-code","title":"Visualize your code","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#non-it-understand-as-well","title":"Non-IT understand as well","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#reason-about-comfortably","title":"Reason About Comfortably","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#design-time","title":"Design-time","text":"<p>```[.highlight: 1,6,7] public interface RegisterIndividual extends Interaction {     @FiresEvent(oneOf = {RegisterIndividualSuccessful.class,             RegisterIndividualFailed.class})     RegisterIndividualOutcome apply(             @recipeInstanceId String recipeInstanceId,             @RequiresIngredient(\"name\") String name,             @RequiresIngredient(\"address\") String address     ); }</p> <pre><code>---\n\n```[.highlight: 2,3]\npublic interface RegisterIndividual extends Interaction {\n    @FiresEvent(oneOf = {RegisterIndividualSuccessful.class,\n            RegisterIndividualFailed.class})\n    RegisterIndividualOutcome apply(\n            @recipeInstanceId String recipeInstanceId,\n            @RequiresIngredient(\"name\") String name,\n            @RequiresIngredient(\"address\") String address\n    );\n}\n</code></pre> <p></p> <p></p> <p></p> <p>```java, [.highlight: 3-6] public Recipe get(){     return new Recipe(\"MuConf2017Demo\").             withInteractions(                     of(AssignAccount.class),                     of(GetAccount.class),                     of(RegisterIndividual.class)); } <pre><code>---\n\n![fit](recipe-no-sensory.png)\n\n---\n\n```java, [.highlight: 5, 7-9]\nreturn new Recipe(\"MuConf2017Demo\").\n        withInteractions(\n                of(AssignAccount.class),\n                of(GetAccount.class).\n                        withRequiredEvent(TermsAndConditionsAccepted.class),\n                of(RegisterIndividual.class)).\n        withSensoryEvents(\n                TermsAndConditionsAccepted.class,\n                IndividualInformationSubmitted.class);\n}\n</code></pre></p> <p></p>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#run-time","title":"Run-time","text":"<p>```java, [.highlight: 2,4,5,8,9,13] //for each process instance, bake the recipe baker.bake(recipeInstanceId); //notify Baker when events occur baker.processEvent(recipeInstanceId, new SensoryEvents.IndividualInformationSubmitted(name, address)); baker.processEvent(recipeInstanceId, new SensoryEvents.TermsAndConditionsAccepted());</p> <p>//retrieve ingredients stored in the accumulated state assert(baker.getIngredients(recipeInstanceId).get(\"customerId\").equals(customerId)); assert(baker.getIngredients(recipeInstanceId).get(\"iban\").equals(iban));</p> <p>//retrieve all events that have occurred Set occurredEvents = new HashSet&lt;&gt;(         baker.getEvents(recipeInstanceId).getEventNameList() ); ``` <p></p>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#under-the-hood","title":"Under the Hood","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#why-scala","title":"Why Scala?","text":"<ul> <li>Best fit for developing DSLs^1 on the JVM</li> <li>Compile-time recipe validation</li> <li>Type safety</li> </ul>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#why-akka","title":"Why Akka?","text":"<ul> <li>Event Sourcing^2 (events can be replayed)</li> <li>Persistent actors (with Cassandra)</li> <li>Distributed actors across machines (with cluster sharding)</li> </ul>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#why-petri-net3","title":"Why Petri net?^3","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#best-practices","title":"Best Practices","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#short-lived-vs-long-running-flows","title":"Short-lived vs. long-running flows","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#state-is-taken-care-of","title":"State is taken care of:","text":"<ul> <li>Cassandra for persistent storage</li> <li>Ingredients encrypted by default</li> <li>State recovered automatically</li> </ul>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#run-baker-inside-of-your-api","title":"Run Baker inside of your API","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#smart-endpoints-and-dumb-pipes","title":"\"Smart endpoints and dumb pipes\"","text":""},{"location":"archive/presentations/muCon-London-7-Nov-2017/#when-failure-occurs","title":"When failure occurs:","text":"<ul> <li>Baker retries technical failures with exponential backoff</li> <li>Works well with idempotent services</li> <li>Deal with functional failure in your recipe</li> </ul> <p>Baker Capability Matrix:</p> <ul> <li>Investigate not one, not two, but all business processes in your company</li> <li>Where do you see re-use?</li> <li>Map using MoSCoW^4 to give importance (M = 10, S = 5, C = 2, W = 1)</li> </ul> Checking Account Savings Account Customer Onboarding Verify Identity Verify Identity Verify Identity Register Individual Register Individual Register Individual Open Checking Account Open Savings Account <code>n/a</code> Issue Debit Card <code>n/a</code> <code>n/a</code> Send Message Send Message Send Message Register Product Owner Register Product Owner <code>n/a</code> <p></p>"},{"location":"archive/presentations/muCon-London-7-Nov-2017/#httpsgithubcoming-bankbaker","title":"https://github.com/ing-bank/baker","text":"<p>Speed of change matters to anyone building software. Many engineering teams have identified Microservices as an important component of this architectural approach to designing more flexible systems that can meet the needs of their fast changing businesses. Applying this approach however, is hard. And ideas and practices are still very much evolving. To help with that, we've launched muCon - a conference to learn about emerging technologies and approaches, share challenges and evolve practices and ideas.</p> <p>Their applications are built on top of microservices. If there careful enough their application serve bad meals. </p> <p>If we are building microservices or a monolith or any type of service in general we are serving business logic to our clients. So no matter what we can not escape the architectural discussion. If we are not careful of how we architect our applications we end up serving bad meals.</p> <p>I love cooking food and for the rest of the talk I'll be using analogies from there. It's very similar to our industry: long hours, hard work, and delivering experiences to our customers.</p> <p>Have you been woken up at 3 o'clock in the morning on a Saturday morning after a night of partying, having to go to the war room and resolve an application incident. I've been there. When I remember the cold of the airconditioners, it still makes me shiver.</p> <p>If we are building microservices or a monolith or any type of application in general we are serving business logic to our clients. So no matter what, we cannot escape the architectural discussion. If we are not careful of how we architect our applications we end up serving a bad meal to our clients.</p>"},{"location":"sections/concepts/","title":"Concepts","text":"<p>In Baker, you declare orchestration logic as a <code>Recipe</code>. A recipe consists of three main building blocks: <code>Ingredients</code>, <code>Interactions</code>, and <code>Events</code>. </p>"},{"location":"sections/concepts/#ingredient","title":"Ingredient","text":"<p>An ingredient is a combination of a <code>name</code> and <code>type</code>. Similar to how a variable declaration in your codebase is a combination of a name and type. For example, you can have an ingredient with the name <code>iban</code> and type <code>string</code>. Types are expressed via the Baker type system.</p> <p>Ingredients are pure pieces of data. They are immutable, meaning they do not change once they enter the process or workflow. There is no support for hierarchy. Expressing a relationship like <code>Animal -&gt; Dog -&gt; Labrador</code> is not possible.</p> <p>Ingredients serve as input for interactions and are carried through the process via events.</p>"},{"location":"sections/concepts/#event","title":"Event","text":"<p>Events represent something that has happened in your process. Most of the time, events are outputs of interactions. We refer to outputs of interactions as <code>internal events</code>. Sometimes events come from outside the process. we refer to  events from outside the process as <code>sensory events</code>. Sensory events start/trigger the process. </p> <p>Note</p> <p>Under the hood <code>internal events</code> and <code>sensory events</code> are identical. The naming distinction exists for practical  reasons only.</p> <p>An event has a <code>name</code> and (optionally) provides ingredients. In the end, events and ingredients are just data structures that describe your process data. A good example would be an <code>OrderPlaced</code> event which carries two ingredients: the <code>orderId</code> and a <code>list of products</code>.</p>"},{"location":"sections/concepts/#interaction","title":"Interaction","text":"<p>Interactions resemble functions. They require input (ingredients) and provide output (events). An interaction can do many things. For example, fetch data from another service, do some complex calculation,  send a message to an event broker, etc.</p>"},{"location":"sections/concepts/#recipe","title":"Recipe","text":"<p>A recipe is the blueprint of your business process. You define this process by combining ingredients, events, and interactions. Baker provides a recipe DSL, allowing you to define your recipe in Java, Kotlin, or Scala. The example below displays a (naive) recipe implementation to ship orders from a web-shop. </p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.OrderPlaced;\nimport examples.java.interactions.ShipOrder;\n\npublic class SimpleRecipe {\n\n    public final static Recipe recipe = new Recipe(\"example recipe\")\n        .withSensoryEvent(OrderPlaced.class)\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.OrderPlaced\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject SimpleRecipe {\n    val recipe = recipe(\"example recipe\") {\n        sensoryEvents {\n            event&lt;OrderPlaced&gt;()\n        }\n        interaction&lt;ShipOrder&gt;() \n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.{Event, Recipe}\nimport examples.scala.events.OrderPlaced\nimport examples.scala.interactions.ShipOrder\n\nobject SimpleRecipe {\n  val recipe: Recipe = Recipe(\"example recipe\")\n    .withSensoryEvent(Event[OrderPlaced])\n    .withInteraction(ShipOrder.interaction)\n}\n</code></pre>"},{"location":"sections/feature-comparison/","title":"Feature comparison","text":"<p>This is a comparison of Baker with similar solutions. Feedback and contributions to solutions not listed are most welcome.</p> Feature Baker Camunda Pega Netflix Conductor Uber Cadence Apache Airflow Owned By ING Camunda PEGA Systems Netflix Uber Community Primary Purpose Orchestration of (micro-)services Process Automation Workflow or case management Orchestration of (micro-)services Orchestration of long-running business logic Workflow of big-data pipelines Typical Use Straight Through Processing (STP) Business Processes with Decision Making Business Processes with Decision Making STP STP Big data Skill-set required Java, Kotlin, or Scala Java, Business Process Modelling Notation (BPMN) Pega-specific JSON Java Python, Bash Execution Model Petri-net BPMN for workflows, Decision Model and Notation (DMN) for business rules Don\u2019t know Queueing Theory Queueing Theory Graph Theory In-memory processing Yes Yes No Yes No No Data Persistence Event sourcing with Cassandra Relational DB via JDBC Relational Dedicated Storage (Dynomite) Cassandra N/A Process Visualization Graphviz Based on BPMN Based on BPMN Dedicated UI No Dedicated UI License Model Open-source Community Platform is open-source Pay per Case Open-source Open-source Open-source Rich UI No Yes Yes Yes No Yes"},{"location":"sections/quickstart-guide/","title":"Quickstart guide","text":""},{"location":"sections/quickstart-guide/#enable-maven-central-repository","title":"Enable Maven Central repository","text":"<p>Baker is published in Maven Central. So you will need to enable Maven Central repository as a source of dependencies in your build.</p> MavenGradle (Kotlin)Gradle (Groovy)Sbt <pre><code>Maven includes the Maven Central repository by default.\n</code></pre> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> <pre><code>Most of the time Sbt includes the Maven Central repository by default.\n</code></pre>"},{"location":"sections/quickstart-guide/#include-dependencies","title":"Include dependencies","text":"<p>Baker is composed of different modules. For most projects you need to include the three dependencies listed below. If you don't require all functionality, simply select the ones you need for your project.</p> MavenGradle (Kotlin)Gradle (Groovy)Sbt <pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n   &lt;artifactId&gt;baker-recipe-dsl_2.13&lt;/artifactId&gt;\n   &lt;version&gt;${baker.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n   &lt;artifactId&gt;baker-compiler_2.13&lt;/artifactId&gt;\n   &lt;version&gt;${baker.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n   &lt;artifactId&gt;baker-runtime_2.13&lt;/artifactId&gt;\n   &lt;version&gt;${baker.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation(\"com.ing.baker:baker-recipe-dsl-kotlin_2.13:$bakerVersion\")\nimplementation(\"com.ing.baker:baker-compiler_2.13:$bakerVersion\")\nimplementation(\"com.ing.baker:baker-runtime_2.13:$bakerVersion\")\n</code></pre> <pre><code>implementation 'com.ing.baker:baker-recipe-dsl_2.13:$bakerVersion'\nimplementation 'com.ing.baker:baker-compiler_2.13:$bakerVersion'\nimplementation 'com.ing.baker:baker-runtime_2.13:$bakerVersion'\n</code></pre> <pre><code>dependencies += \"com.ing.baker\" %% \"baker-recipe-dsl\" % bakerVersion\ndependencies += \"com.ing.baker\" %% \"baker-compiler\" % bakerVersion\ndependencies += \"com.ing.baker\" %% \"baker-runtime\" % bakerVersion\n</code></pre> <p>Note</p> <p>Kotlin users should include <code>baker-recipe-dsl-kotlin_2.13</code> instead of <code>baker-recipe-dsl_2.13</code>.</p> <p>Note</p> <p>Replace the version placeholders with the actual version you want to use. The latest stable version can be  found on Maven Central.</p>"},{"location":"sections/quickstart-guide/#module-overview","title":"Module overview","text":"Module Description recipe-dsl A declarative DSL to describe your recipes. runtime The Baker runtime to manage and execute your recipes. compiler A compiler that compiles recipes into a model that the runtime can execute. intermediate-language Recipe and Petri Net model used by the compiler and runtime. You don't interact with this module directly."},{"location":"sections/quickstart-guide/#dependency-graph","title":"Dependency graph","text":""},{"location":"sections/tutorial/","title":"Tutorial","text":"<p>This guide walks you through the process of creating a Baker orchestration workflow one step at a time. Completing this tutorial takes around 20 minutes. </p> <p>Note</p> <p>To follow this tutorial you will need a Java, Kotlin, or Scala project that includes the dependencies mentioned in the quickstart guide.</p> <p>Note</p> <p>This tutorial assumes you have a basic understanding of <code>ingredients</code>, <code>events</code>, <code>interactions</code>, and <code>recipes</code>. If not, please read the concepts section before starting the tutorial.</p>"},{"location":"sections/tutorial/#setting-the-stage","title":"Setting the stage","text":"<p>Imagine you are working as a software engineer for a modern e-commerce company. They are building a web-shop made up of  different microservices. You are responsible for orchestrating the order-flow. The requirements read:</p> <p>Once a customer places an order, we need to verify if the products are in stock. Stock levels are available via the <code>StockService</code>. If there is enough stock, ship the order by calling the <code>ShippingService</code>. If there is insufficient stock, cancel the order by calling the  <code>CancellationService</code>.</p>"},{"location":"sections/tutorial/#define-the-sensory-event","title":"Define the sensory event","text":"<p>A recipe is always triggered by a <code>sensory event</code>. In this example, our sensory event is the customer placing an order.</p> JavaKotlinScala <pre><code>package examples.java.events;\n\nimport examples.java.ingredients.Address;\n\nimport java.util.List;\n\npublic record OrderPlaced(\n    String orderId,\n    String customerId,\n    Address address,\n    List&lt;String&gt; productIds\n) { }\n</code></pre> <pre><code>package examples.kotlin.events\n\nimport examples.kotlin.ingredients.Address\n\ndata class OrderPlaced(\n    val orderId: String,\n    val customerId: String,\n    val address: Address,\n    val productIds: List&lt;String&gt;\n)\n</code></pre> <pre><code>package examples.scala.events\n\nimport examples.scala.ingredients.Address\n\ncase class OrderPlaced(\n  orderId: String,\n  customerId: String,\n  address: Address,\n  productIds: List[String]\n)\n</code></pre> <p>The <code>OrderPlaced</code> event carries four ingredients. The <code>address</code> ingredient is of type <code>Address</code>, which is just a simple data class.</p> JavaKotlinScala <pre><code>package examples.java.ingredients;\n\npublic record Address(\n    String street,\n    String city,\n    String zipCode,\n    String country\n) { }\n</code></pre> <pre><code>package examples.kotlin.ingredients\n\ndata class Address(\n    val street: String,\n    val city: String,\n    val zipCode: String,\n    val country: String\n)\n</code></pre> <pre><code>package examples.scala.ingredients\n\ncase class Address(\n  street: String,\n  city: String,\n  zipCode: String,\n  country: String\n)\n</code></pre>"},{"location":"sections/tutorial/#define-the-interactions","title":"Define the interactions","text":"<p>Next, it's time to model our interactions. We need to create a total of three interactions. One to validate if the products are in stock, one to ship the order, and one to cancel the order. </p> <p>In this step we will just declare our interaction blueprints as interfaces. That's all we need to be able to declare  a recipe. The implementation for these interactions will follow at a later stage.</p>"},{"location":"sections/tutorial/#check-stock","title":"Check stock","text":"<p>Our stock validation interaction requires two ingredients as input. The <code>orderId</code> and a list of <code>productIds</code>. The interaction won't execute unless these ingredients are available in the process. The interaction will either emit a <code>SufficientStock</code> event, if all products are in stock. Or an <code>OrderHasUnavailableItems</code> event otherwise.  The <code>OrderHasUnavailableItems</code> event carries a list of <code>unavailableProductIds</code> as ingredient.</p> JavaKotlinScala <pre><code>package examples.java.interactions;\n\nimport com.ing.baker.recipe.annotations.FiresEvent;\nimport com.ing.baker.recipe.annotations.RequiresIngredient;\nimport com.ing.baker.recipe.javadsl.Interaction;\n\nimport java.util.List;\n\npublic interface CheckStock extends Interaction {\n\n    interface Outcome {\n    }\n\n    record OrderHasUnavailableItems(List&lt;String&gt; unavailableProductIds) implements Outcome {\n    }\n\n    record SufficientStock() implements Outcome {\n    }\n\n    @FiresEvent(oneOf = {SufficientStock.class, OrderHasUnavailableItems.class})\n    Outcome apply(@RequiresIngredient(\"orderId\") String orderId,\n                  @RequiresIngredient(\"productIds\") List&lt;String&gt; productIds\n    );\n}\n</code></pre> <p>Note</p> <p>The <code>@FiresEvent</code> annotation is used to define the possible outcome events.</p> <p>Note</p> <p>The <code>@RequiresIngredient</code> annotation is used to define the ingredient names that this interaction needs for its execution.</p> <p>Warning</p> <p>The Java implementation makes use of Bakers reflection API. For this to work, the method in the interaction must be named <code>apply</code>. Other names won't work.</p> <pre><code>package examples.kotlin.interactions\n\nimport com.ing.baker.recipe.javadsl.Interaction\n\ninterface CheckStock : Interaction {\n\n    sealed interface Outcome\n\n    data class OrderHasUnavailableItems(\n        val unavailableProductIds: List&lt;String&gt;\n    ) : Outcome\n\n    object SufficientStock : Outcome\n\n    fun apply(orderId: String, productIds: List&lt;String&gt;): Outcome\n}\n</code></pre> <p>Note</p> <p>Kotlin's reflection API is more powerful than Java's. There is no need for any annotations when you model the possible outcome events as a <code>sealed</code> hierarchy.</p> <p>Warning</p> <p>The Kotlin implementation makes use of Bakers reflection API. For this to work, the method in the interaction must be named <code>apply</code>. Other names won't work.</p> <pre><code>package examples.scala.interactions\n\nimport com.ing.baker.recipe.scaladsl.{Event, Ingredient, Interaction}\n\nobject CheckStock {\n\n  sealed trait Outcome\n\n  case class SufficientStock() extends Outcome\n  case class OrderHasUnavailableItems(unavailableProductIds: List[String]) extends Outcome\n\n  val interaction: Interaction = Interaction(\n    name = \"CheckStock\",\n    inputIngredients = Seq(\n      Ingredient[String](name = \"orderId\"),\n      Ingredient[List[String]](name = \"productIds\")\n    ),\n    output = Seq(\n      Event[SufficientStock],\n      Event[OrderHasUnavailableItems]\n    )\n  )\n}\n</code></pre>"},{"location":"sections/tutorial/#ship-order","title":"Ship Order","text":"<p>To ship an order we'll need the <code>orderId</code> and an <code>address</code>. For the sake of simplicity, this interaction will always  result in a <code>OrderShipped</code> event.</p> JavaKotlinScala <pre><code>package examples.java.interactions;\n\nimport com.ing.baker.recipe.annotations.FiresEvent;\nimport com.ing.baker.recipe.annotations.RequiresIngredient;\nimport com.ing.baker.recipe.javadsl.Interaction;\nimport examples.java.ingredients.Address;\n\npublic interface ShipOrder extends Interaction {\n\n    record OrderShipped() {\n    }\n\n    @FiresEvent(oneOf = {OrderShipped.class})\n    OrderShipped apply(@RequiresIngredient(\"orderId\") String orderId,\n                       @RequiresIngredient(\"address\") Address address\n    );\n}\n</code></pre> <pre><code>package examples.kotlin.interactions\n\nimport com.ing.baker.recipe.javadsl.Interaction\nimport examples.kotlin.ingredients.Address\n\ninterface ShipOrder : Interaction {\n    object OrderShipped\n\n    fun apply(orderId: String, address: Address): OrderShipped\n}\n</code></pre> <pre><code>package examples.scala.interactions\n\nimport com.ing.baker.recipe.scaladsl.{Event, Ingredient, Interaction}\nimport examples.scala.ingredients.Address\n\nobject ShipOrder {\n\n  case class OrderShipped()\n\n  val interaction: Interaction = Interaction(\n    name = \"ShipOrder\",\n    inputIngredients = Seq(\n      Ingredient[String](name = \"orderId\"),\n      Ingredient[Address](name = \"address\")\n    ),\n    output = Seq(\n      Event[OrderShipped]\n    )\n  )\n}\n</code></pre>"},{"location":"sections/tutorial/#cancel-order","title":"Cancel order","text":"<p>To cancel the order we'll need the <code>orderId</code> and a list of <code>unavailableProductIds</code>. Of course, <code>unavailableProductIds</code> will only be available if the stock validation failed.</p> JavaKotlinScala <pre><code>package examples.java.interactions;\n\nimport com.ing.baker.recipe.annotations.FiresEvent;\nimport com.ing.baker.recipe.annotations.RequiresIngredient;\nimport com.ing.baker.recipe.javadsl.Interaction;\n\nimport java.util.List;\n\npublic interface CancelOrder extends Interaction {\n\n    record OrderCancelled() {\n    }\n\n    @FiresEvent(oneOf = {OrderCancelled.class})\n    OrderCancelled apply(@RequiresIngredient(\"orderId\") String orderId,\n                         @RequiresIngredient(\"unavailableProductIds\") List&lt;String&gt; unavailableProductIds\n    );\n}\n</code></pre> <pre><code>package examples.kotlin.interactions\n\nimport com.ing.baker.recipe.javadsl.Interaction\n\ninterface CancelOrder : Interaction {\n    object OrderCancelled\n\n    fun apply(orderId: String, unavailableProductIds: List&lt;String&gt;): OrderCancelled\n}\n</code></pre> <pre><code>package examples.scala.interactions\n\nimport com.ing.baker.recipe.scaladsl.{Event, Ingredient, Interaction}\nimport examples.scala.ingredients.Address\n\nobject CancelOrder {\n\n  case class OrderCancelled()\n\n  val interaction: Interaction = Interaction(\n    name = \"CancelOrder\",\n    inputIngredients = Seq(\n      Ingredient[String](name = \"orderId\"),\n      Ingredient[List[String]](name = \"unavailableProductIds\")\n    ),\n    output = Seq(\n      Event[OrderCancelled]\n    )\n  )\n}\n</code></pre>"},{"location":"sections/tutorial/#define-the-recipe","title":"Define the recipe","text":"<p>At this point we can compose our sensory event and three interactions into a recipe. The <code>OrderPlaced</code> event is declared as a sensory event. <code>OrderPlaced</code> carries all the ingredients required by the <code>CheckStock</code> interaction, so once the sensory event fires the <code>CheckStock</code> interaction will execute.</p> <p><code>CheckStock</code> will output either a <code>SufficientStock</code> or <code>OrderHasUnavailableItems</code> event. <code>ShipOrder</code> will only execute if the process contains an event of <code>SufficientStock</code> and <code>CancelOrder</code> will only execute if the process contains an event of <code>OrderHasUnavailableItems</code>.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.OrderPlaced;\nimport examples.java.interactions.CancelOrder;\nimport examples.java.interactions.CheckStock;\nimport examples.java.interactions.ShipOrder;\n\npublic class WebShopRecipe {\n\n    public final static Recipe recipe = new Recipe(\"web-shop recipe\")\n        .withSensoryEvent(OrderPlaced.class)\n        .withInteractions(\n            InteractionDescriptor.of(CheckStock.class),\n            InteractionDescriptor.of(ShipOrder.class)\n                .withRequiredEvent(CheckStock.SufficientStock.class),\n            InteractionDescriptor.of(CancelOrder.class)\n                .withRequiredEvent(CheckStock.OrderHasUnavailableItems.class)\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.OrderPlaced\nimport examples.kotlin.interactions.CancelOrder\nimport examples.kotlin.interactions.CheckStock\nimport examples.kotlin.interactions.CheckStock.*\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject WebShopRecipe {\n    val recipe = recipe(\"web-shop recipe\") {\n        sensoryEvents {\n            event&lt;OrderPlaced&gt;()\n        }\n        interaction&lt;CheckStock&gt;()\n        interaction&lt;ShipOrder&gt; {\n            requiredEvents {\n                event&lt;SufficientStock&gt;()\n            }\n        }\n        interaction&lt;CancelOrder&gt; {\n            requiredEvents {\n                event&lt;OrderHasUnavailableItems&gt;()\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.{Event, Recipe}\nimport examples.scala.events.OrderPlaced\nimport examples.scala.interactions.{CancelOrder, CheckStock, ShipOrder}\n\nobject WebShopRecipe {\n  val recipe: Recipe = Recipe(\"web-shop recipe\")\n    .withSensoryEvent(\n      Event[OrderPlaced]\n    )\n    .withInteractions(\n      CheckStock.interaction,\n      ShipOrder.interaction\n        .withRequiredEvent(\n          Event[CheckStock.SufficientStock]\n        ),\n      CancelOrder.interaction\n        .withRequiredEvent(\n          Event[CheckStock.OrderHasUnavailableItems]\n        )\n    )\n}\n</code></pre>"},{"location":"sections/tutorial/#implement-the-interactions","title":"Implement the interactions","text":"<p>Before we can run our recipe, we need to create InteractionInstances that the Baker runtime will use to execute the  interactions. In other words, we need to provide implementations for the interactions.</p> <p>Since this is a tutorial, we'll just create some dummy implementations. In a real solution, this is the part where you would implement your actual logic.</p> <p>Tip</p> <p>In these examples we use a <code>Impl</code> suffix for the implementation classes. In your real solution you might want to  use a more meaningful name. </p>"},{"location":"sections/tutorial/#check-stock-implementation","title":"Check stock implementation","text":"JavaKotlinScala <pre><code>package examples.java.interactions;\n\nimport java.util.List;\n\npublic class CheckStockImpl implements CheckStock {\n\n    @Override\n    public Outcome apply(String orderId, List&lt;String&gt; productIds) {\n        System.out.printf(\"Checking stock for order: %s and products: %s%n\", orderId, productIds);\n\n        int random = (int) (Math.random() * (1000 - 1)) + 1;\n        if (random &lt; 500) {\n            return new SufficientStock();\n        } else {\n            return new OrderHasUnavailableItems(productIds);\n        }\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.interactions\n\nobject CheckStockImpl : CheckStock {\n    override fun apply(orderId: String, productIds: List&lt;String&gt;): CheckStock.Outcome {\n        println(\"Checking stock for order: $orderId and products: $productIds\")\n\n        return if ((1..1000).random() &lt; 500) {\n            CheckStock.SufficientStock\n        } else {\n            CheckStock.OrderHasUnavailableItems(productIds)\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.interactions\n\nimport scala.concurrent.Future\nimport scala.util.Random\n\ntrait CheckStockTrait {\n  def apply(orderId: String, productIds: List[String]): Future[CheckStock.Outcome]\n}\n\nclass CheckStockImpl extends CheckStockTrait {\n  override def apply(orderId: String, productIds: List[String]): Future[CheckStock.Outcome] = {\n    println(s\"Checking stock for order: $orderId and products: $productIds\")\n\n    val randomNumber = new Random().nextInt(1000) + 1\n    if (randomNumber &lt; 500) {\n      Future.successful(CheckStock.SufficientStock())\n    } else {\n      Future.successful(CheckStock.OrderHasUnavailableItems(productIds))\n    }\n  }\n}\n</code></pre>"},{"location":"sections/tutorial/#ship-order-implementation","title":"Ship order implementation","text":"JavaKotlinScala <pre><code>package examples.java.interactions;\n\nimport examples.java.ingredients.Address;\n\npublic class ShipOrderImpl implements ShipOrder {\n    @Override\n    public OrderShipped apply(String orderId, Address address) {\n        System.out.printf(\"Shipping order %s to %s\", orderId, address);\n        return new OrderShipped();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.interactions\n\nimport examples.kotlin.ingredients.Address\n\nobject ShipOrderImpl : ShipOrder {\n    override fun apply(orderId: String, address: Address): ShipOrder.OrderShipped {\n        println(\"Shipping order $orderId to $address\")\n        return ShipOrder.OrderShipped\n    }\n}\n</code></pre> <pre><code>package examples.scala.interactions\n\nimport examples.scala.ingredients.Address\n\nimport scala.concurrent.Future\n\ntrait ShipOrderTrait {\n  def apply(orderId: String, address: Address): Future[ShipOrder.OrderShipped]\n}\n\nclass ShipOrderImpl extends ShipOrderTrait {\n  override def apply(orderId: String, address: Address): Future[ShipOrder.OrderShipped] = {\n    println(s\"Shipping order $orderId to $address\")\n    Future.successful(ShipOrder.OrderShipped())\n  }\n}\n</code></pre>"},{"location":"sections/tutorial/#cancel-order-implementation","title":"Cancel order implementation","text":"JavaKotlinScala <pre><code>package examples.java.interactions;\n\nimport java.util.List;\n\npublic class CancelOrderImpl implements CancelOrder {\n    @Override\n    public OrderCancelled apply(String orderId, List&lt;String&gt; unavailableProductIds) {\n        System.out.printf(\"Canceling order %s. The following products are unavailable: %s\", orderId, unavailableProductIds);\n        return new OrderCancelled();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.interactions\n\nobject CancelOrderImpl : CancelOrder {\n    override fun apply(orderId: String, unavailableProductIds: List&lt;String&gt;): CancelOrder.OrderCancelled {\n        println(\"Canceling order $orderId. The following products are unavailable: $unavailableProductIds\")\n        return CancelOrder.OrderCancelled\n    }\n}\n</code></pre> <pre><code>package examples.scala.interactions\n\nimport scala.concurrent.Future\n\ntrait CancelOrderTrait {\n  def apply(orderId: String, unavailableProductIds: List[String]): Future[CancelOrder.OrderCancelled]\n}\n\nclass CancelOrderImpl extends CancelOrderTrait {\n  override def apply(orderId: String, unavailableProductIds: List[String]): Future[CancelOrder.OrderCancelled] = {\n    println(s\"Canceling order $orderId. The following products are unavailable: $unavailableProductIds\")\n    Future.successful(CancelOrder.OrderCancelled())\n  }\n}\n</code></pre>"},{"location":"sections/tutorial/#execute-the-recipe","title":"Execute the recipe","text":"<p>To execute the recipe we first need an instance of the <code>InMemoryBaker</code>. You can create one by providing the interaction implementations to the <code>InMemoryBaker</code> static factory.</p> <p>The next step is to add the recipe to Baker. You can do this via the <code>addRecipe</code> method. If the <code>validate</code> flag is set to <code>true</code>, Baker checks if all required interaction implementations are available. Adding the recipe is something you only need to do once for each unique recipe.</p> <p>Before we can fire the sensory event, we need to create a new process instance of the recipe. We do this via the <code>bake</code> method. You are required to specify a <code>recipeInstanceId</code>. Here we use <code>UUID</code>, but it can be anything as long as it's  unique within your processes.</p> <p>Finally, we can fire the sensory event via <code>fireEventAndResolveWhenCompleted</code>. The moment the event arrives our process will start.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.compiler.RecipeCompiler;\nimport com.ing.baker.runtime.inmemory.InMemoryBaker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport examples.java.events.OrderPlaced;\nimport examples.java.ingredients.Address;\nimport examples.java.interactions.CancelOrderImpl;\nimport examples.java.interactions.CheckStockImpl;\nimport examples.java.interactions.ShipOrderImpl;\nimport examples.java.recipes.WebShopRecipe;\n\nimport java.util.List;\nimport java.util.UUID;\n\npublic class WebShopApp {\n\n    public static void main(String[] args) {\n        var baker = InMemoryBaker.java(\n            List.of(new CheckStockImpl(), new CancelOrderImpl(), new ShipOrderImpl())\n        );\n\n        var recipeInstanceId = UUID.randomUUID().toString();\n        var sensoryEvent = EventInstance.from(createOrderPlaced());\n\n        baker.addRecipe(RecipeCompiler.compileRecipe(WebShopRecipe.recipe), true)\n            .thenCompose(recipeId -&gt; baker.bake(recipeId, recipeInstanceId))\n            .thenCompose(ignored -&gt; baker.fireEventAndResolveWhenCompleted(recipeInstanceId, sensoryEvent))\n            .join();\n    }\n\n    private static OrderPlaced createOrderPlaced() {\n        var address = new Address(\"Hoofdstraat\", \"Amsterdam\", \"1234AA\", \"The Netherlands\");\n        return new OrderPlaced(\"123\", \"456\", address, List.of(\"iPhone\", \"Playstation5\"));\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.compiler.RecipeCompiler\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.runtime.javadsl.EventInstance\nimport com.ing.baker.runtime.kotlindsl.InMemoryBaker\nimport examples.kotlin.events.OrderPlaced\nimport examples.kotlin.ingredients.Address\nimport examples.kotlin.interactions.CancelOrderImpl\nimport examples.kotlin.interactions.CheckStockImpl\nimport examples.kotlin.interactions.ShipOrderImpl\nimport examples.kotlin.recipes.WebShopRecipe\nimport kotlinx.coroutines.runBlocking\nimport java.util.*\n\n@ExperimentalDsl\nfun main(): Unit = runBlocking {\n    val baker = InMemoryBaker.kotlin(\n        implementations = listOf(CheckStockImpl, CancelOrderImpl, ShipOrderImpl)\n    )\n\n    val recipeId = baker.addRecipe(\n        compiledRecipe = RecipeCompiler.compileRecipe(WebShopRecipe.recipe),\n        validate = true\n    )\n\n    val recipeInstanceId = UUID.randomUUID().toString()\n    val sensoryEvent = EventInstance.from(orderPlaced)\n\n    baker.bake(recipeId, recipeInstanceId)\n    baker.fireEventAndResolveWhenCompleted(recipeInstanceId, sensoryEvent)\n}\n\nprivate val orderPlaced = OrderPlaced(\n    orderId = \"123\",\n    customerId = \"456\",\n    productIds = listOf(\"iPhone\", \"PlayStation5\"),\n    address = Address(\n        street = \"Hoofdstraat\",\n        city = \"Amsterdam\",\n        zipCode = \"1234AA\",\n        country = \"The Netherlands\"\n    )\n)\n</code></pre> <pre><code>package examples.scala.application\n\nimport cats.effect.{ContextShift, IO, Timer}\nimport com.ing.baker.compiler.RecipeCompiler\nimport examples.scala.events.OrderPlaced\nimport com.ing.baker.runtime.inmemory.InMemoryBaker\nimport com.ing.baker.runtime.model.InteractionInstance\nimport com.ing.baker.runtime.scaladsl.EventInstance\nimport examples.scala.ingredients.Address\nimport examples.scala.interactions.{CancelOrderImpl, CheckStockImpl, ShipOrderImpl}\nimport examples.scala.recipes.WebShopRecipe\n\nimport java.util.UUID\nimport scala.concurrent.ExecutionContext\n\nclass WebShopApp {\n  def main(args: Array[String]): Unit = {\n\n    implicit val timer: Timer[IO] = IO.timer(ExecutionContext.global)\n    implicit val contextShift: ContextShift[IO] = IO.contextShift(ExecutionContext.global)\n\n    val interactions = List(\n      new CancelOrderImpl(),\n      new ShipOrderImpl(),\n      new CheckStockImpl(),\n    )\n\n    val bakerF = InMemoryBaker.build(implementations = interactions.map(InteractionInstance.unsafeFrom[IO]))\n      .unsafeRunSync()\n\n    val recipeInstanceId = UUID.randomUUID().toString\n    val sensoryEvent = EventInstance.unsafeFrom(orderPlaced)\n\n    for {\n      recipeId &lt;- bakerF.addRecipe(RecipeCompiler.compileRecipe(recipe = WebShopRecipe.recipe), validate = true)\n      _ &lt;- bakerF.bake(recipeId, recipeInstanceId)\n      _ &lt;- bakerF.fireEventAndResolveWhenCompleted(recipeInstanceId, sensoryEvent)\n\n    } yield recipeId\n  }\n\n  private val orderPlaced = OrderPlaced(\n    orderId = \"123\",\n    customerId = \"456\",\n    productIds = List(\"iPhone\", \"PlayStation5\"),\n    address = Address(\n      street = \"Hoofdstraat\",\n      city = \"Amsterdam\",\n      zipCode = \"1234AA\",\n      country = \"The Netherlands\"\n    )\n  )\n}\n</code></pre> <p>Run the main function and observe the results. Depending on the outcome of the <code>CheckStock</code> interaction you will see one of these messages in the console:</p> <p>Checking stock for order: 123 and products: [iPhone, PlayStation5]</p> <p>Shipping order 123 to Address(street=Hoofdstraat, city=Amsterdam, zipCode=1234AA, country=The Netherlands)</p> <p>Checking stock for order: 123 and products: [iPhone, PlayStation5]</p> <p>Canceling order 123. The following products are unavailable: [iPhone, PlayStation5]</p>"},{"location":"sections/tutorial/#wrap-up","title":"Wrap-up","text":"<p>Congratulations! You just build your first Baker process. Of course, this is just a simplified example. To learn more about what you can do with Baker, please refer to the cookbook section. There you will find information on things like error handling, testing recipes, creating visualizations, and more.</p>"},{"location":"sections/cookbook/error-handling/","title":"Error handling","text":"<p>An interaction can fail to achieve its intended purpose. Baker categorizes failures in technical failures and functional failures.</p> <p>Technical failures are characterized by the possibility of being retried and eventually succeeding. Examples of technical failures include timeouts due to an unreliable network, temporary unavailability of an external system, and receiving an unexpected response from an external system. These failures are unexpected and are handled by throwing an exception from the interaction.</p> <p>Functional failures cannot be resolved by retrying the interaction. Examples of functional failures include cases where there is insufficient stock to ship the order, or there is insufficient credit to perform a transfer. These failures are anticipated and considered as potential outcomes of the interaction. They are handled by returning an event from the interaction.</p>"},{"location":"sections/cookbook/error-handling/#failure-strategies","title":"Failure strategies","text":"<p>Baker offers multiple mitigation strategies for technical failures.</p> <p>Tip</p> <p>The examples in this section all set the <code>defaultFailureStrategy</code> on <code>recipe</code> level. The same strategies are also available for the <code>failureStrategy</code> on <code>interaction</code> level.</p>"},{"location":"sections/cookbook/error-handling/#block-interaction","title":"Block interaction","text":"<p>This is the default failure strategy. When an exception occurs the interaction is blocked. This option is suitable for non-idempotent interactions that cannot be retried. A blocked interaction will not execute again for that recipe instance until it is unblocked. Blocked interactions can be unblocked by calling the baker.retryInteraction or baker.resolveInteraction methods.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\npublic class RecipeBlockInteraction {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            InteractionFailureStrategy.BlockInteraction()\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\n\n@ExperimentalDsl\nobject RecipeBlockInteraction {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = blockInteraction()\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nobject RecipeBlockInteraction {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      InteractionFailureStrategy.BlockInteraction()\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#fire-event-and-block","title":"Fire event and Block","text":"<p>This option is the equivalent of a <code>try-catch</code> in code. When an exception occurs an event is fired.  The interaction is still put in the blocked state. A blocked interaction will not execute again for that recipe instance until it is unblocked. Blocked interactions can be unblocked by calling the baker.retryInteraction or baker.resolveInteraction methods.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\npublic class RecipeFireEventAndBlock {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            InteractionFailureStrategy.FireEventAndBlock(\"MyEvent\")\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\n\n@ExperimentalDsl\nobject RecipeFireEventAndBlock {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = fireEventAndBlock(\"MyEvent\")\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nobject RecipeFireEventAndBlock {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      InteractionFailureStrategy.FireEventAndBlock(Some(\"MyEvent\"))\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#fire-event-and-resolve","title":"Fire event and Resolve","text":"<p>When an exception occurs an event is fired. This is seen as if the interaction returned this event. In this case the interaction is not put in the blocked state and can be executed again if the preconditions are met. Since the interaction is not put in the blocked state the baker.retryInteraction or baker.resolveInteraction methods cannot be called for the interaction.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\npublic class RecipeFireEventAndResolve {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            InteractionFailureStrategy.FireEventAndResolve(\"MyEvent\")\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\n\n@ExperimentalDsl\nobject RecipeFireEventAndResolve {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = fireEventAndResolve(\"MyEvent\")\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nobject RecipeFireEventAndResolve {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      InteractionFailureStrategy.FireEventAndResolve(Some(\"MyEvent\"))\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#retry-with-incremental-back-off","title":"Retry with incremental back-off","text":"<p>Incremental back-off allows you to configure a retry mechanism that exponentially increases the time between each retry. You retry quickly at first, but slower over time. Retry with incremental back-off keeps retrying until a set deadline or the maximum amount of retries is reached.</p>"},{"location":"sections/cookbook/error-handling/#until-deadline","title":"Until deadline","text":"JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\nimport java.time.Duration;\n\npublic class RecipeRetryWithBackOffUntilDeadline {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            new InteractionFailureStrategy.RetryWithIncrementalBackoffBuilder()\n                .withInitialDelay(Duration.ofMillis(100))\n                .withBackoffFactor(2.0)\n                .withMaxTimeBetweenRetries(Duration.ofSeconds(100))\n                .withDeadline(Duration.ofHours(24))\n                .build()\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\n@ExperimentalDsl\nobject RecipeRetryWithBackOffUntilDeadline {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = retryWithIncrementalBackoff {\n            initialDelay = 100.milliseconds\n            backoffFactor = 2.0\n            maxTimeBetweenRetries = 10.seconds\n            until = deadline(24.hours)\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff\nimport com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilDeadline\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nimport scala.concurrent.duration.DurationInt\n\nobject RecipeRetryWithBackOffUntilDeadline {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      RetryWithIncrementalBackoff\n        .builder()\n        .withInitialDelay(100.milliseconds)\n        .withBackoffFactor(2.0)\n        .withMaxTimeBetweenRetries(Some(10.minutes))\n        .withUntil(Some(UntilDeadline(24.hours)))\n        .build()\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#until-maximum-retries","title":"Until maximum retries","text":"JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\nimport java.time.Duration;\n\npublic class RecipeRetryWithBackOffUntilMaxRetries {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            new InteractionFailureStrategy.RetryWithIncrementalBackoffBuilder()\n                .withInitialDelay(Duration.ofMillis(100))\n                .withBackoffFactor(2.0)\n                .withMaxTimeBetweenRetries(Duration.ofSeconds(100))\n                .withMaximumRetries(200)\n                .build()\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\n@ExperimentalDsl\nobject RecipeRetryWithBackOffUntilMaxRetries {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = retryWithIncrementalBackoff {\n            initialDelay = 100.milliseconds\n            backoffFactor = 2.0\n            maxTimeBetweenRetries = 10.seconds\n            until = maximumRetries(200)\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff\nimport com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilMaximumRetries\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nimport scala.concurrent.duration.DurationInt\n\nobject RecipeRetryWithBackOffUntilMaxRetries {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      RetryWithIncrementalBackoff\n        .builder()\n        .withInitialDelay(100.milliseconds)\n        .withBackoffFactor(2.0)\n        .withMaxTimeBetweenRetries(Some(10.minutes))\n        .withUntil(Some(UntilMaximumRetries(200)))\n        .build()\n    )\n}\n</code></pre> name meaning <code>initialDelay</code> The delay before retrying for the first time. <code>backoffFactor</code> The backoff factor for the delay, defaults to 2 <code>maxTimeBetweenRetries</code> The maximum time between retries. <code>deadLine</code> The total amount of time spend retrying. <code>maximumRetries</code> The maximum amount of retries. <p>Our example results in a retry pattern off: </p> <p><code>100 millis -&gt; 200 millis -&gt; 400 millis -&gt; ... -&gt; 100 seconds -&gt; 100 seconds</code>.</p> <p>Which can be visualized like this:</p> <p></p> <p>Note</p> <p>Delays do not include the interaction execution time. If the first retry takes 5 seconds (and fails), the second retry will be triggered after:</p> <p><code>(100 millis + 5 seconds + 200 millis) = 5.3 seconds</code></p> <p>The deadline also does not consider interaction execution time. Keep this in mind when setting the deadline value.</p>"},{"location":"sections/cookbook/error-handling/#fireeventandblock-and-fireeventandresolve","title":"FireEventAndBlock and FireEventAndResolve","text":"<p>If an interaction keeps failing longer then the defined retry duration, the retry is exhausted and the interaction becomes blocked. If you want you can configure either the FireEventAndBlock or FireEventAndResolve as a followup retry strategy.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\nimport java.time.Duration;\n\npublic class RecipeRetryWithBackOfWithFireEventAndBlock {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            new InteractionFailureStrategy.RetryWithIncrementalBackoffBuilder()\n                .withInitialDelay(Duration.ofMillis(100))\n                .withBackoffFactor(2.0)\n                .withMaxTimeBetweenRetries(Duration.ofSeconds(100))\n                .withDeadline(Duration.ofHours(24))\n                .withFireEventAndBlock(\"RetriesExhausted\")\n                .build()\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport kotlin.time.Duration.Companion.hours\nimport kotlin.time.Duration.Companion.milliseconds\nimport kotlin.time.Duration.Companion.seconds\n\n@ExperimentalDsl\nobject RecipeRetryWithBackOfWithFireEventAndBlock {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = retryWithIncrementalBackoff {\n            initialDelay = 100.milliseconds\n            backoffFactor = 2.0\n            maxTimeBetweenRetries = 10.seconds\n            until = deadline(24.hours)\n            fireEventAndBlock = \"RetriesExhausted\"\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff\nimport com.ing.baker.recipe.common.InteractionFailureStrategy.RetryWithIncrementalBackoff.UntilDeadline\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nimport scala.concurrent.duration.DurationInt\n\nobject RecipeRetryWithBackOfWithFireEventAndBlock {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      RetryWithIncrementalBackoff\n        .builder()\n        .withInitialDelay(100.milliseconds)\n        .withBackoffFactor(2.0)\n        .withMaxTimeBetweenRetries(Some(10.minutes))\n        .withUntil(Some(UntilDeadline(24.hours)))\n        .withFireEventAndBlock(Some(\"RetriesExhausted\"))\n        .build()\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#manual-intervention","title":"Manual intervention","text":"<p>Baker allows you to resolve blocked interactions, and to stop retrying interactions via manual intervention.</p>"},{"location":"sections/cookbook/error-handling/#force-a-retry","title":"Force a retry","text":"<p>This method retries a given interaction a single time. If it succeeds, your process continues. If it fails, the interaction stays blocked.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\n\npublic class ManualRetryInteraction {\n\n    public void retryExample(Baker baker, String recipeInstanceId) {\n        baker.retryInteraction(recipeInstanceId, \"ShipOrder\");\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.kotlindsl.Baker\n\nsuspend fun retryExample(baker: Baker, recipeInstanceId: String) {\n    baker.retryInteraction(recipeInstanceId, \"ShipOrder\")\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.Baker\n\nclass ManualRetryInteraction {\n  def retryExample(baker: Baker, recipeInstanceId: String): Unit = {\n    baker.retryInteraction(recipeInstanceId, \"ShipOrder\")\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#resolve-interaction","title":"Resolve interaction","text":"<p>This method resolves a blocked interaction by firing an event.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\n\npublic class ManualResolveInteraction {\n\n    public void resolveExample(Baker baker, String recipeInstanceId) {\n        baker.resolveInteraction(\n            recipeInstanceId,\n            \"ShipOrder\",\n            EventInstance.from(\"ShippingFailed\")\n        );\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.javadsl.EventInstance\nimport com.ing.baker.runtime.kotlindsl.Baker\n\nsuspend fun resolveExample(baker: Baker, recipeInstanceId: String) {\n    baker.resolveInteraction(\n        recipeInstanceId,\n        \"ShipOrder\",\n        EventInstance.from(\"ShippingFailed\")\n    )\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.{Baker, EventInstance}\n\nclass ManualResolveInteraction {\n  def resolveExample(baker: Baker, recipeInstanceId: String): Unit = {\n    baker.resolveInteraction(\n      recipeInstanceId,\n      \"ShipOrder\",\n      EventInstance(\"ShippingFailed\")\n    )\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/error-handling/#stop-retrying","title":"Stop retrying","text":"<p>This method halts the retry process of a failing interaction by blocking the interaction.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\n\npublic class ManualStopInteraction {\n\n    public void stopExample(Baker baker, String recipeInstanceId) {\n        baker.stopRetryingInteraction(recipeInstanceId, \"ShipOrder\");\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.kotlindsl.Baker\n\nsuspend fun stopExample(baker: Baker, recipeInstanceId: String) {\n    baker.stopRetryingInteraction(recipeInstanceId, \"ShipOrder\")\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.Baker\n\nclass ManualStopInteraction {\n  def retryExample(baker: Baker, recipeInstanceId: String): Unit = {\n    baker.stopRetryingInteraction(recipeInstanceId, \"ShipOrder\")\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/fire-sensory-events/","title":"Fire events and inquiry","text":"<p>This section describes how to fire sensory events into a Baker process, and how to query information from a running Baker process.</p> <p>Note</p> <p>For the Java API most methods return a <code>CompletableFuture&lt;A&gt;</code>, in the Scala API they return <code>Future&lt;A&gt;</code>. The Kotlin API makes use of <code>suspending</code> functions, and thus does not wrap the return type. To keep things readable, the descriptions in this section reason from Java's perspective.</p>"},{"location":"sections/cookbook/fire-sensory-events/#fire-sensory-events","title":"Fire sensory events","text":"<p>To trigger a Baker process you'll need to fire a sensory event. After firing an event, you may want to continue your  asynchronous computation at one of four different moments:</p> <ol> <li>Right after the event was received, but before any interactions are executed.</li> <li>After all interactions have completed. At this point the process is either finished, or requires other sensory events to continue.</li> <li>You want to do something on both the previously mentioned moments.</li> <li>As soon one of the interactions fires a specific event.</li> </ol> <p>To this end, the Baker interface exposes four different methods to fire events. We'll discuss each of those in more detail.</p>"},{"location":"sections/cookbook/fire-sensory-events/#fire-event-and-resolve-when-received","title":"Fire event and resolve when received","text":"<p>This method returns a <code>CompletableFuture&lt;SensoryEventStatus&gt;</code>. It completes right after the event was received, but before any interactions are executed. The <code>SensoryEventStatus</code> is an enum containing information about the outcome of the event (<code>Received</code>, <code>Completed</code>, <code>FiringLimitMet</code>, etc). </p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport examples.java.events.OrderPlaced;\n\npublic class FireEventAndResolveWhenReceived {\n\n    private final Baker baker;\n\n    public FireEventAndResolveWhenReceived(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example(String recipeInstanceId, OrderPlaced orderPlaced) {\n        var eventInstance = EventInstance.from(orderPlaced);\n        var sensoryEventStatus = baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance).join();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.javadsl.EventInstance\nimport com.ing.baker.runtime.kotlindsl.Baker\nimport examples.kotlin.events.OrderPlaced\n\nclass FireEventAndResolveWhenReceived(private val baker: Baker) {\n\n    suspend fun example(recipeInstanceId: String, orderPlaced: OrderPlaced) {\n        val orderPlacedEvent = EventInstance.from(orderPlaced)\n        val sensoryEventStatus = baker.fireEventAndResolveWhenReceived(recipeInstanceId, orderPlacedEvent)\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.{Baker, EventInstance}\nimport examples.scala.events.OrderPlaced\n\nclass FireEventAndResolveWhenReceived(val baker: Baker) {\n\n  def example(recipeInstanceId: String, orderPlaced: OrderPlaced): Unit = {\n    val eventInstance = EventInstance.unsafeFrom(orderPlaced)\n    val sensoryEventStatus = baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance)\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/fire-sensory-events/#fire-event-and-resolve-when-completed","title":"Fire event and resolve when completed","text":"<p>Returns a <code>CompletableFuture&lt;SensoryEventResult&gt;</code>. It completes when additional sensory events are required to continue the process, or when the process has finished. The <code>SensoryEventResult</code> contains the <code>SensoryEventStatus</code> and a list of all events names triggered as a result of this sensory event.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport examples.java.events.OrderPlaced;\n\npublic class FireEventAndResolveWhenCompleted {\n\n    private final Baker baker;\n\n    public FireEventAndResolveWhenCompleted(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example(String recipeInstanceId, OrderPlaced orderPlaced) {\n        var eventInstance = EventInstance.from(orderPlaced);\n        var sensoryEventResult = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance).join();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.javadsl.EventInstance\nimport com.ing.baker.runtime.kotlindsl.Baker\nimport examples.kotlin.events.OrderPlaced\n\nclass FireEventAndResolveWhenCompleted(private val baker: Baker) {\n\n    suspend fun example(recipeInstanceId: String, orderPlaced: OrderPlaced) {\n        val orderPlacedEvent = EventInstance.from(orderPlaced)\n        val sensoryEventResult = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, orderPlacedEvent)\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.{Baker, EventInstance}\nimport examples.scala.events.OrderPlaced\n\nclass FireEventAndResolveWhenCompleted(val baker: Baker) {\n\n  def example(recipeInstanceId: String, orderPlaced: OrderPlaced): Unit = {\n    val eventInstance = EventInstance.unsafeFrom(orderPlaced)\n    val sensoryEventResult = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance)\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/fire-sensory-events/#fire-event","title":"Fire event","text":"<p>This method is useful if you want to do something after the event was received and after all interactions have completed. The method returns an <code>EventResolutions</code> object consisting of a <code>CompletableFuture&lt;SensoryEventStatus&gt;</code> and  <code>CompletableFuture&lt;SensoryEventResult&gt;</code>. The former completes on receiving the event, the latter on completion of the interactions.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport examples.java.events.OrderPlaced;\n\npublic class FireEvent {\n\n    private final Baker baker;\n\n    public FireEvent(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example(String recipeInstanceId, OrderPlaced orderPlaced) {\n        var eventInstance = EventInstance.from(orderPlaced);\n\n        var eventResolutions = baker.fireEvent(recipeInstanceId, eventInstance);\n        var sensoryEventStatus = eventResolutions.getResolveWhenReceived().join();\n        var sensoryEventResult = eventResolutions.getResolveWhenCompleted().join();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.javadsl.EventInstance\nimport com.ing.baker.runtime.kotlindsl.Baker\nimport examples.kotlin.events.OrderPlaced\n\nclass FireEvent(private val baker: Baker) {\n\n    suspend fun example(recipeInstanceId: String, orderPlaced: OrderPlaced) {\n        val orderPlacedEvent = EventInstance.from(orderPlaced)\n\n        val eventResolutions = baker.fireEvent(recipeInstanceId, orderPlacedEvent)\n        val sensoryEventStatus = eventResolutions.resolveWhenReceived.await()\n        val sensoryEventResult = eventResolutions.resolveWhenCompleted.await()\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.{Baker, EventInstance}\nimport examples.scala.events.OrderPlaced\n\nclass FireEvent(val baker: Baker) {\n\n  def example(recipeInstanceId: String, orderPlaced: OrderPlaced): Unit = {\n    val eventInstance = EventInstance.unsafeFrom(orderPlaced)\n\n    val eventResolutions = baker.fireEvent(recipeInstanceId, eventInstance)\n    val sensoryEventStatus = eventResolutions.resolveWhenReceived\n    val sensoryEventResult = eventResolutions.resolveWhenCompleted\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/fire-sensory-events/#fire-event-and-resolve-on-event","title":"Fire event and resolve on event","text":"<p>This method returns a <code>CompletableFuture&lt;SensoryEventResult&gt;</code>. It completes when one of the interactions fires an event with a specified name. </p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport examples.java.events.OrderPlaced;\n\npublic class FireEventAndResolveOnEvent {\n\n    private final Baker baker;\n\n    public FireEventAndResolveOnEvent(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example(String recipeInstanceId, OrderPlaced orderPlaced) {\n        var eventInstance = EventInstance.from(orderPlaced);\n        var sensoryEventResult = baker.fireEventAndResolveOnEvent(recipeInstanceId, eventInstance, \"ExpectedEvent\").join();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.javadsl.EventInstance\nimport com.ing.baker.runtime.kotlindsl.Baker\nimport examples.kotlin.events.OrderPlaced\n\nclass FireEventAndResolveOnEvent(private val baker: Baker) {\n\n    suspend fun example(recipeInstanceId: String, orderPlaced: OrderPlaced) {\n        val orderPlacedEvent = EventInstance.from(orderPlaced)\n        val sensoryEventResult = baker.fireEventAndResolveOnEvent(recipeInstanceId, orderPlacedEvent, \"ExpectedEvent\")\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.{Baker, EventInstance}\nimport examples.scala.events.OrderPlaced\n\nclass FireEventAndResolveOnEvent(val baker: Baker) {\n\n  def example(recipeInstanceId: String, orderPlaced: OrderPlaced): Unit = {\n    val eventInstance = EventInstance.unsafeFrom(orderPlaced)\n    val sensoryEventResult = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance)\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/fire-sensory-events/#inquiry","title":"Inquiry","text":"<p>Baker allows you to query the state of a recipe instance at any given moment. To this end, Baker exposes a couple of different methods that allow you to fetch information about events, ingredients, and interactions from a running process.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\n\npublic class InquiryExample {\n\n    private final Baker baker;\n\n    public InquiryExample(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example(String recipeInstanceId) {\n        var ingredient = baker.getIngredient(recipeInstanceId, \"orderId\").join();\n\n        var ingredients = baker.getIngredients(recipeInstanceId).join();\n\n        var events = baker.getEvents(recipeInstanceId).join();\n\n        var eventNames = baker.getEventNames(recipeInstanceId).join();\n\n        var recipeInstanceState = baker.getRecipeInstanceState(recipeInstanceId).join();\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.kotlindsl.Baker\n\nclass InquiryExample(private val baker: Baker) {\n\n    suspend fun example(recipeInstanceId: String) {\n        val ingredient = baker.getIngredient(recipeInstanceId, \"orderId\")\n\n        val ingredients = baker.getIngredients(recipeInstanceId)\n\n        val events = baker.getEvents(recipeInstanceId)\n\n        val eventNames = baker.getEventNames(recipeInstanceId)\n\n        val recipeInstanceState = baker.getRecipeInstanceState(recipeInstanceId)\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.Baker\n\nclass InquiryExample(val baker: Baker) {\n\n  def example(recipeInstanceId: String): Unit = {\n    val ingredient = baker.getIngredient(recipeInstanceId, \"orderId\")\n\n    val ingredients = baker.getIngredients(recipeInstanceId)\n\n    val events = baker.getEvents(recipeInstanceId)\n\n    val eventNames = baker.getEventNames(recipeInstanceId)\n\n    val recipeInstanceState = baker.getRecipeInstanceState(recipeInstanceId)\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/interaction-execution/","title":"Interaction execution","text":"<p>This section will give a basic explanation when baker will execute interactions in your Recipe. For a more in depth information please see the execution-semantics page.</p>"},{"location":"sections/cookbook/interaction-execution/#when-does-baker-execute-an-interaction","title":"When does Baker execute an interaction","text":"<p>Baker will execute an interaction when: </p> <ol> <li>All incoming ingredients are available </li> <li>All event preconditions are met.</li> </ol> <p>After an interaction is executed it will 'consume' the ingredients and events.  Interactions get their own copies of events/ingredients to consume.  You do not have to worry about one interaction taking the ingredients away from another.</p> <p>To execute an interaction again all incoming ingredients need to be provided again and the event preconditions need to be met again.</p>"},{"location":"sections/cookbook/interaction-execution/#reprovider-interactions","title":"Reprovider interactions","text":"<p>Interactions can be configured to be reprovider interactions.  This means that after execution they will provide their own ingredients again.  Reprovider interactions will only need to have their ingredients to be provided once.  They will execute everytime their event preconditions are met.</p> <p>Reprovider interactions do not update the ingredient data and will always use the latest ingredient data that is available.</p> <p>If there are no event preconditions on a reprovider interaction, it will automatically loop its execution. Therefore this is made mandatory in the RecipeCompiler.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.OrderPlaced;\nimport examples.java.interactions.ShipOrder;\n\npublic class RecipeWithReproviderInteraction {\n\n    public final static Recipe recipe = new Recipe(\"Reprovider recipe\")\n        .withSensoryEvent(OrderPlaced.class)\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                    .isReprovider(true)\n                    .withRequiredEvent(OrderPlaced.class)\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.OrderPlaced\nimport examples.kotlin.events.PaymentReceived\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithReproviderInteraction {\n    val recipe = recipe(\"Reprovider recipe\") {\n        sensoryEvents {\n            event&lt;OrderPlaced&gt;()\n        }\n        interaction&lt;ShipOrder&gt; {\n            isReprovider = true\n            requiredEvents { event&lt;OrderPlaced&gt;() }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.{Event, Recipe}\nimport examples.scala.events.OrderPlaced\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithReproviderInteraction {\n  val recipe: Recipe = Recipe(\"Reprovider recipe\")\n    .withSensoryEvent(Event[OrderPlaced])\n    .withInteraction(\n      ShipOrder.interaction\n        .isReprovider(true)\n        .withRequiredEvent(Event[OrderPlaced])\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/monitoring/","title":"Monitoring","text":"<p>Baker allows you to register a couple of different event listeners. These are especially useful for monitoring and logging purposes.</p> <p>Warning</p> <p>Each event is guaranteed to be delivered <code>AT MOST ONCE</code>. You should not use an event listener for critical functionality.</p> <p>Note</p> <p>The delivery is local (JVM) only. You will not receive events from other nodes when running in cluster mode.</p>"},{"location":"sections/cookbook/monitoring/#recipe-instance-events","title":"Recipe instance events","text":"<p>The <code>registerEventListener</code> method allows you to declare an event listener which listens to all events of a specific recipe instance.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\n\npublic class RegisterEventListener {\n\n    private final Baker baker;\n\n    public RegisterEventListener(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example() {\n        baker.registerEventListener((String recipeInstanceId, String event) -&gt;\n            System.out.println(\"Recipe Instance \" + recipeInstanceId + \" processed event \" + event)\n        );\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.kotlindsl.Baker\n\nclass RegisterEventListener(private val baker: Baker) {\n\n    suspend fun example() {\n        baker.registerEventListener { recipeInstanceId, eventInstance -&gt;\n            println(\"Recipe Instance: $recipeInstanceId, processed event: $eventInstance \")\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.Baker\n\nclass RegisterEventListener(val baker: Baker) {\n\n  def example(): Unit = {\n    baker.registerEventListener((recipeInstanceId, event) =&gt;\n      println(s\"Recipe instance: $recipeInstanceId, processed event: $event\")\n    )\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/monitoring/#all-baker-events","title":"All Baker events","text":"<p>The <code>registerBakerEventListener</code> method allows you to declare an event listener which listens to all Baker events. These are events that notify what Baker is doing.</p> JavaKotlinScala <pre><code>package examples.java.application;\n\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.ing.baker.runtime.javadsl.BakerEvent;\n\npublic class RegisterBakerEventListener {\n\n    private final Baker baker;\n\n    public RegisterBakerEventListener(Baker baker) {\n        this.baker = baker;\n    }\n\n    public void example() {\n        baker.registerBakerEventListener((BakerEvent event) -&gt;\n            System.out.println(\"Received event: \" + event)\n        );\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.application\n\nimport com.ing.baker.runtime.kotlindsl.Baker\n\nclass RegisterBakerEventListener(private val baker: Baker) {\n\n    suspend fun example() {\n        baker.registerBakerEventListener { bakerEvent -&gt;\n            println(\"Received event: $bakerEvent\")\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.application\n\nimport com.ing.baker.runtime.scaladsl.Baker\n\nclass RegisterBakerEventListener(val baker: Baker) {\n\n  def example(): Unit = {\n    baker.registerBakerEventListener((bakerEvent) =&gt;\n      println(s\"Received event: $bakerEvent\")\n    )\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/","title":"Recipe DSL","text":"<p>Warning</p> <p>The examples in this section are set up to demonstrate specific features of the recipe DSL. The snippets are not complete recipes. For example, some snippets only specify sensory events without any interactions, and vice versa.</p>"},{"location":"sections/cookbook/recipe-dsl/#sensory-events","title":"Sensory events","text":""},{"location":"sections/cookbook/recipe-dsl/#firing-limit","title":"Firing limit","text":"<p>Sensory events can be declared with or without firing limit. The firing limit determines how many times the event is allowed to be fired into the process. If you don't want to impose any limits, you have to explicitly declare the event as such. If left unspecified, the firing limit defaults to 1.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.FraudCheckCompleted;\nimport examples.java.events.OrderPlaced;\nimport examples.java.events.PaymentReceived;\n\npublic class RecipeWithSensoryEvents {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withSensoryEventNoFiringLimit(OrderPlaced.class)\n        .withSensoryEvent(PaymentReceived.class)\n        .withSensoryEvent(FraudCheckCompleted.class, 5);\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.FraudCheckCompleted\nimport examples.kotlin.events.OrderPlaced\nimport examples.kotlin.events.PaymentReceived\n\n@ExperimentalDsl\nobject RecipeWithSensoryEvents {\n    val recipe = recipe(name = \"example\") {\n        sensoryEvents {\n            eventWithoutFiringLimit&lt;OrderPlaced&gt;()\n            event&lt;PaymentReceived&gt;()\n            event&lt;FraudCheckCompleted&gt;(maxFiringLimit = 5)\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.{Event, Recipe}\nimport examples.scala.events.{FraudCheckCompleted, OrderPlaced, PaymentReceived}\n\nobject RecipeWithSensoryEvents {\n  val recipe: Recipe = Recipe(name = \"example\")\n    .withSensoryEvents(\n      Event[OrderPlaced],\n      PaymentReceived.event,\n      FraudCheckCompleted.event\n    )\n}\n</code></pre> <p>Note</p> <p>For Scala events the <code>maxFiringLimit</code> is set in the <code>Event</code> definition. An example event definition can be found in this section of the tutorial.</p>"},{"location":"sections/cookbook/recipe-dsl/#event-receive-period","title":"Event receive period","text":"<p>The period during which the process accepts sensory events. This is an optional parameter, defaults to accepting  sensory events forever.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.Recipe;\n\nimport java.time.Duration;\n\npublic class RecipeWithEventReceivePeriod {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withEventReceivePeriod(Duration.ofHours(5));\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport kotlin.time.Duration.Companion.hours\n\n@ExperimentalDsl\nobject RecipeWithEventReceivePeriod {\n    val recipe = recipe(name = \"example\") {\n        eventReceivePeriod = 5.hours\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nimport scala.concurrent.duration.{FiniteDuration, HOURS}\n\nobject RecipeWithEventReceivePeriod {\n  val recipe: Recipe = Recipe(name = \"example\")\n    .withEventReceivePeriod(FiniteDuration.apply(5, HOURS))\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#interactions","title":"Interactions","text":""},{"location":"sections/cookbook/recipe-dsl/#custom-name","title":"Custom name","text":"<p>By default, the name of the interaction matches the name of the interaction class. Optionally, you can specify your own name.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.interactions.ShipOrder;\n\npublic class InteractionWithCustomName {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class, \"ship-order\")\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject InteractionWithCustomName {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n            name = \"ship-order\"\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.interactions.ShipOrder\n\nobject InteractionWithCustomName {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withName(\"ship-order\")\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#maximum-interaction-count","title":"Maximum interaction count","text":"<p>By default, an interaction can be invoked an unlimited amount of times. Optionally, you can specify a limit.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.interactions.ShipOrder;\n\npublic class RecipeWithMaxInteractionCount {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                .withMaximumInteractionCount(1)\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithMaxInteractionCount {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n            maximumInteractionCount = 1\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithMaxInteractionCount {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withMaximumInteractionCount(1)\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#predefined-ingredients","title":"Predefined ingredients","text":"<p>It's possible to register static ingredients to the interaction via predefined ingredients.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.interactions.ShipOrder;\n\nimport java.math.BigDecimal;\nimport java.util.Map;\n\npublic class RecipeWithPredefinedIngredients {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                .withPredefinedIngredients(\n                    Map.of(\n                        \"shippingCostAmount\", new BigDecimal(\"5.75\"),\n                        \"shippingCostCurrency\", \"EUR\"\n                    )\n                )\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithPredefinedIngredients {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n           preDefinedIngredients {\n               \"shippingCostAmount\" to \"5.75\".toBigDecimal()\n               \"shippingCostCurrency\" to \"EUR\"\n           }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithPredefinedIngredients {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withPredefinedIngredients(\n          (\"shippingCostAmount\", BigDecimal(\"5.75\")),\n          (\"shippingCostCurrency\", \"EUR\")\n        )\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#required-events","title":"Required events","text":"<p>Sometimes an interaction should only execute after a certain event has happened. To achieve this you can specify <code>requiredEvents</code> or <code>requiredOneOfEvents</code>. </p> <p>All required events have to be available for the interaction to be executed. It works as a logical AND. In contrast,  required one of events works as a logical OR. At least one of those events should be available before the interaction is executed. </p> <p>In this example, the <code>ShipOrder</code> interaction will only execute if the <code>FraudCheckCompleted</code> and one of (or both) the  <code>PaymentReceived</code> or <code>UsedCouponCode</code> events are available.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.FraudCheckCompleted;\nimport examples.java.interactions.ShipOrder;\n\npublic class RecipeWithRequiredEvents {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                .withRequiredEvent(FraudCheckCompleted.class)\n                .withRequiredOneOfEventsFromName(\"PaymentReceived\", \"UsedCouponCode\")\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.FraudCheckCompleted\nimport examples.kotlin.events.PaymentReceived\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithRequiredEvents {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n            requiredEvents {\n                event&lt;FraudCheckCompleted&gt;()\n            }\n            requiredOneOfEvents {\n                event&lt;PaymentReceived&gt;()\n                event(name = \"UsedCouponCode\")\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.{Event, Recipe}\nimport examples.scala.events.{FraudCheckCompleted, PaymentReceived}\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithRequiredEvents {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withRequiredEvent(\n          FraudCheckCompleted.event\n        )\n        .withRequiredOneOfEvents(\n          PaymentReceived.event,\n          Event(\"UsedCouponCode\")\n        )\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#transform-output-events","title":"Transform output events","text":"<p>It's possible to change the name of an output event. Optionally, you can also change names of  ingredients.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.OrderPlaced;\nimport examples.java.interactions.ShipOrder;\n\nimport java.util.Map;\n\npublic class RecipeWithEventTransformation {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                .withEventTransformation(OrderPlaced.class, \"OrderCreated\",\n                        Map.of(\"customerId\", \"userId\",\n                               \"productIds\", \"skus\")\n                )\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.OrderPlaced\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithEventTransformation {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n           transformEvent&lt;OrderPlaced&gt;(newName = \"OrderCreated\") {\n               \"customerId\" to \"userId\"\n               \"productIds\" to \"skus\"\n           }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.events.PaymentReceived\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithEventTransformation {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withEventOutputTransformer(\n          event = PaymentReceived.event,\n          newEventName = \"OrderCreated\",\n          ingredientRenames = Map.apply(\n            (\"customerId\", \"userId\"),\n            (\"productIds\", \"skus\")\n          )\n        )\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#override-input-ingredients","title":"Override input ingredients","text":"<p>It's possible to change the names the input ingredients.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.interactions.ShipOrder;\n\npublic class RecipeWithIngredientNameOverrides {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                .renameRequiredIngredient(\"orderId\", \"orderNumber\")\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithIngredientNameOverrides {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n            ingredientNameOverrides {\n                \"orderId\" to \"orderNumber\"\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithIngredientNameOverrides {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withOverriddenIngredientName(\"orderId\", \"orderNumber\")\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#failure-strategy","title":"Failure strategy","text":"<p>It's possible to define a failure strategy on interaction level. This failure strategy will only be used for this specific interaction. Interaction specific failure strategies take precedence over the default failure strategy.  For all available failure strategies, see the error handling section.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionDescriptor;\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.interactions.ShipOrder;\n\npublic class RecipeWithFailureStrategy {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withInteractions(\n            InteractionDescriptor.of(ShipOrder.class)\n                .withFailureStrategy(\n                        InteractionFailureStrategy.FireEvent(\"shippingFailed\")\n                )\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithFailureStrategy {\n    val recipe = recipe(\"example\") {\n        interaction&lt;ShipOrder&gt; {\n            failureStrategy = fireEventAndBlock(\"shippingFailed\")\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.interactions.ShipOrder\n\nobject RecipeWithFailureStrategy {\n  val recipe: Recipe = Recipe(\"example\")\n    .withInteraction(\n      ShipOrder.interaction\n        .withFailureStrategy(\n          InteractionFailureStrategy.FireEventAndBlock(Some(\"shippingFailed\"))\n        )\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#recipe","title":"Recipe","text":""},{"location":"sections/cookbook/recipe-dsl/#retention-period","title":"Retention period","text":"<p>The period during which the process keeps running, the recipe will be deleted AFTER the retention period has passed (measured from the creation time of the Recipe instance. This is an optional parameter, defaults to keep the process forever.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.Recipe;\n\nimport java.time.Duration;\n\npublic class RecipeWithRetentionPeriod {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withRetentionPeriod(Duration.ofDays(3));\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport kotlin.time.Duration.Companion.days\nimport kotlin.time.Duration.Companion.hours\n\n@ExperimentalDsl\nobject RecipeWithRetentionPeriod {\n    val recipe = recipe(name = \"example\") {\n        retentionPeriod = 3.days\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nimport scala.concurrent.duration.{DAYS, FiniteDuration, HOURS}\n\nobject RecipeWithRetentionPeriod {\n  val recipe: Recipe = Recipe(name = \"example\")\n    .withRetentionPeriod(FiniteDuration.apply(3, DAYS))\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#checkpoint-events","title":"Checkpoint events","text":"<p>Checkpoints are used to fire an event with a given name whenever certain preconditions are met. The preconditions  are specified via <code>requiredEvents</code> or <code>requiredOneOfEvents</code>.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.CheckPointEvent;\nimport com.ing.baker.recipe.javadsl.Recipe;\nimport examples.java.events.FraudCheckCompleted;\nimport examples.java.events.PaymentReceived;\n\npublic class RecipeWithCheckpointEvent {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withCheckpointEvent(\n            new CheckPointEvent(\"CheckpointReached\")\n                .withRequiredEvents(\n                        PaymentReceived.class,\n                        FraudCheckCompleted.class\n                )\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.events.FraudCheckCompleted\nimport examples.kotlin.events.PaymentReceived\n\n@ExperimentalDsl\nobject RecipeWithCheckpointEvent {\n    val recipe = recipe(\"example\") {\n        checkpointEvent(eventName = \"CheckpointReached\") {\n            requiredEvents {\n                event&lt;PaymentReceived&gt;()\n                event&lt;FraudCheckCompleted&gt;()\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.scaladsl\nimport com.ing.baker.recipe.scaladsl.Recipe\nimport examples.scala.events.{FraudCheckCompleted, PaymentReceived}\n\nobject RecipeWithCheckpointEvent {\n  val recipe: Recipe = Recipe(\"example\")\n    .withCheckpointEvent(\n      scaladsl.CheckPointEvent(\n        name = \"CheckpointReached\",\n        requiredEvents = Set.apply(\n          PaymentReceived.event.name,\n          FraudCheckCompleted.event.name\n        )\n      )\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/recipe-dsl/#default-failure-strategy","title":"Default failure strategy","text":"<p>The default failure strategy allows you to set a failure strategy for interactions that don't specify  one explicitly. For all available failure strategies, see the error handling section.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.recipe.javadsl.InteractionFailureStrategy;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\npublic class RecipeWithDefaultFailureStrategy {\n\n    public final static Recipe recipe = new Recipe(\"example\")\n        .withDefaultFailureStrategy(\n            InteractionFailureStrategy.FireEvent(\"recipeFailed\")\n        );\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport com.ing.baker.recipe.kotlindsl.recipe\nimport examples.kotlin.interactions.ShipOrder\n\n@ExperimentalDsl\nobject RecipeWithDefaultFailureStrategy {\n    val recipe = recipe(\"example\") {\n        defaultFailureStrategy = fireEventAndBlock(\"recipeFailed\")\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.recipe.common.InteractionFailureStrategy\nimport com.ing.baker.recipe.scaladsl.Recipe\n\nobject RecipeWithDefaultFailureStrategy {\n  val recipe: Recipe = Recipe(\"example\")\n    .withDefaultFailureStrategy(\n      InteractionFailureStrategy.FireEventAndBlock(Some(\"recipeFailed\"))\n    )\n}\n</code></pre>"},{"location":"sections/cookbook/testing/","title":"Testing","text":"<p>In general, Baker applications are easy to test because the Baker model enforces separation and decoupling between parts of your system. It provides a clear distinction between business logic (the recipe) and implementation details (interaction implementations). Furthermore, interactions are independent of each other, since every interaction only depends on its inputs.</p> <p>This section describes testing strategies for the different layers of a Baker application. And demonstrates how to simplify testing by using the <code>baker-test</code> library.</p>"},{"location":"sections/cookbook/testing/#recipe-validation-tests","title":"Recipe validation tests","text":"<p>A recipe is validated when it's compiled by the <code>RecipeCompiler</code>. Any validation errors that might occur during this compilation are available through the resulting <code>CompiledRecipe</code> instance. A simple unit test that checks for validation errors in your recipe is essential.</p> JavaKotlinScala <pre><code>package examples.java.recipes;\n\nimport com.ing.baker.compiler.RecipeCompiler;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertTrue;\n\npublic class WebShopRecipeTest {\n\n    @Test\n    public void recipeShouldCompileWithoutValidationErrors() {\n        var validationErrors = RecipeCompiler.compileRecipe(WebShopRecipe.recipe).getValidationErrors();\n        assertTrue(\n            String.format(\"Recipe compilation resulted in validation errors: \\n%s\", validationErrors),\n            validationErrors.isEmpty()\n        );\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.recipes\n\nimport com.ing.baker.compiler.RecipeCompiler\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport org.junit.Test\n\n@ExperimentalDsl\nclass WebShopRecipeTest {\n    @Test\n    fun `recipe should compile without validation errors`() {\n        val validationErrors = RecipeCompiler.compileRecipe(WebShopRecipe.recipe).validationErrors\n        assert(validationErrors.isEmpty()) {\n            \"Recipe compilation resulted in validation errors: \\n${validationErrors.joinToString(separator = \"\\n\")}\"\n        }\n    }\n}\n</code></pre> <pre><code>package examples.scala.recipes\n\nimport com.ing.baker.compiler.RecipeCompiler\nimport org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.should.Matchers\n\nclass WebShopRecipeTest extends AnyFlatSpec with Matchers {\n  \"Recipe\" should \"compile without validation errors\" in {\n    val validationErrors = RecipeCompiler.compileRecipe(WebShopRecipe.recipe).validationErrors\n    assert(validationErrors.isEmpty)\n  }\n}\n</code></pre>"},{"location":"sections/cookbook/testing/#business-logic-tests","title":"Business logic tests","text":"<p>The next layer is to test that the recipe actually does what you expect it to do at the business logic level. You can achieve this providing dummy or mock interactions that behave in an expected manner. The objective here is to test that the Recipe ends on the expected state given a certain order of firing sensory events.</p> <p>The full test flow looks like this:</p> <ol> <li>Setup dummy or mock interactions that behave according to the test scenario.</li> <li>Create a new in memory Baker with the interactions from step 1.</li> <li>Add and bake the recipe</li> <li>Fire sensory events</li> <li>Assert expectations by querying the state of the recipe.</li> </ol>"},{"location":"sections/cookbook/testing/#implementation-tests","title":"Implementation tests","text":"<p>The final layer is to individually test your implementations, which will resemble your normal e2e tests, interconnectivity tests, or unit tests. What these tests look like will strongly depend on your teams testing and coding conventions.</p>"},{"location":"sections/cookbook/testing/#baker-test-library","title":"Baker test library","text":"<p>The <code>baker-test</code> library simplifies the testing of baker-based logic. Using this library makes the test code  concise and readable in both Java and Scala. It also simplifies the testing of the cases when asynchronous recipe  execution is involved.</p> <p>Warning</p> <p>At the moment <code>baker-test</code> is not compatible with the suspending Kotlin Baker APIs.</p>"},{"location":"sections/cookbook/testing/#adding-the-dependency","title":"Adding the dependency","text":"MavenSbt <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.ing.baker&lt;/groupId&gt;\n  &lt;artifactId&gt;baker-test_2.13&lt;/artifactId&gt;\n  &lt;version&gt;${baker.version}&lt;/version&gt;\n  &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>libraryDependencies += \"com.ing.baker\" %% \"baker-test_2.13\" % bakerVersion\n</code></pre>"},{"location":"sections/cookbook/testing/#eventsflow","title":"EventsFlow","text":"<p><code>EventsFlow</code> is made to simplify the work with the baker events while testing. <code>EventsFlow</code> is immutable.</p> <p>You create a new events flow from events classes:</p> ScalaJava <pre><code>val flow: EventsFlow = \n      classOf[SomeSensoryEvent] :: classOf[InteractionSucceeded] :: EmptyFlow\n</code></pre> <pre><code>EventsFlow flow = EventsFlow.of(\n    SomeSensoryEvent.class,\n    InteractionSucceeded.class\n);\n</code></pre> <p>There is also an option to create a new event flow from the existing one:</p> ScalaJava <pre><code>val anotherFlow: EventsFlow = \n    flow -- classOf[SomeSensoryEvent] ++ classOf[AnotherSensoryEvent]\n</code></pre> <pre><code>EventsFlow anotherFlow = flow\n    .remove(SomeSensoryEvent.class)\n    .add(AnotherSensoryEvent.class);\n</code></pre> <p>It is also possible to combine classes, strings and other events flows:</p> ScalaJava <pre><code>    val unhappyFlow: EventsFlow = \n        happyFlow -- classOf[InteractionSucceeded] ++ \"InteractionExhausted\" +++ someErrorFlow\n</code></pre> <pre><code>    EventsFlow unhappyFlow = happyFlow\n        .remove(InteractionSucceeded.class)\n        .add(\"InteractionExhausted\")\n        .add(someErrorFlow);\n</code></pre> <p>Events flows are compared ignoring the order of the events:</p> ScalaJava <pre><code>   \"EventOne\" :: \"EventTwo\" :: EmptyFlow == \"EventTwo\" :: \"EventOne\" :: EmptyFlow // true   \n</code></pre> <pre><code>   EventsFlow.of(\"EventOne\",\"EventTwo\").equals(EventsFlow.of(\"EventTwo\",\"EventOne\")); // true   \n</code></pre> <p>While comparing events flows it does not matter if an event is provided as a class or as a string:</p> ScalaJava <pre><code>   classOf[EventOne] :: EmptyFlow == \"EventOne\" :: EmptyFlow // true   \n</code></pre> <pre><code>   EventsFlow.of(EventOne.class).equals(EventsFlow.of(\"EventOne\")); // true   \n</code></pre>"},{"location":"sections/cookbook/testing/#recipeassert","title":"RecipeAssert","text":"<p><code>RecipeAssert</code> is the starting point of all your assertions for the recipe instance.</p> <p>To create a <code>RecipeAssert</code> instance a baker instance and a recipe instance id are required:</p> ScalaJava <pre><code>  val recipeAssert: RecipeAssert = RecipeAssert(baker, recipeInstanceId)\n</code></pre> <pre><code>    RecipeAssert recipeAssert = RecipeAssert.of(baker, recipeInstanceId);\n</code></pre> <p>There is a simple way to assert if the events flow for this recipe instance is exactly the same as expected:</p> ScalaJava <pre><code>  val happyFlow: EventsFlow =\n    classOf[SomeSensoryEvent] :: classOf[InteractionSucceeded] :: EmptyFlow\n  RecipeAssert(baker, recipeInstanceId).assertEventsFlow(happyFlow)\n</code></pre> <pre><code>    EventsFlow happyFlow = EventsFlow.of(\n        SomeSensoryEvent.class,\n        InteractionSucceeded.class\n    );\n    RecipeAssert.of(baker, recipeInstanceId).assertEventsFlow(happyFlow);\n</code></pre> <p>If the assertion fails a clear error message with the difference is provided:</p> <pre><code>Events are not equal:\n    actual: OrderPlaced, ItemsReserved\n  expected: OrderPlaced, ItemsNotReserved\ndifference: ++ ItemsNotReserved\n            -- ItemsReserved\n</code></pre> <p>There are multiple methods to assert ingredient values.</p> ScalaJava <pre><code>RecipeAssert(baker, recipeInstanceId)\n  .assertIngredient(\"ingredientName\").isEqual(expectedValue) // is equal to the expected value\n  .assertIngredient(\"nullishIngredient\").isNull // exists and has `null` value\n  .assertIngredient(\"not-existing\").isAbsent // ingredient is not a part of the recipe\n  .assertIngredient(\"someListOfStrings\").is(value =&gt; Assertions.assert(value.asList(classOf[String]).size == 2)) // custom\n</code></pre> <pre><code>RecipeAssert.of(baker, recipeInstanceId)\n  .assertIngredient(\"ingredientName\").isEqual(expectedValue) // is equal to the expected value\n  .assertIngredient(\"nullishIngredient\").isNull() // exists and has `null` value\n  .assertIngredient(\"not-existing\").isAbsent() // ingredient is not a part of the recipe\n  .assertIngredient(\"someListOfStrings\").is(val =&gt; Assert.assertEquals(2, val.asList(String.class).size())); // custom\n</code></pre> <p>You can log some information from the baker recipe instance.</p> <p>Note: But in most cases you probably should not have to do it because the current state is logged when any of the assertions fail.</p> ScalaJava <pre><code>RecipeAssert(baker, recipeInstanceId)\n    .logIngredients() // logs ingredients\n    .logEventNames() // logs event names\n    .logVisualState() // logs visual state in dot language\n    .logCurrentState() // logs all the information available\n</code></pre> <pre><code>RecipeAssert.of(baker, recipeInstanceId)\n    .logIngredients() // logs ingredients\n    .logEventNames() // logs event names\n    .logVisualState() // logs visual state in dot language\n    .logCurrentState(); // logs all the information available\n</code></pre> <p>Quite a common task is to wait for a baker process to finish or specific event to fire. Therefore, the blocking method was implemented:</p> ScalaJava <pre><code>RecipeAssert(baker, recipeInstanceId).waitFor(happyFlow)\n// on this line all the events within happyFlow have happened\n// otherwise timeout occurs and an assertion error is thrown\n</code></pre> <pre><code>RecipeAssert.of(baker, recipeInstanceId).waitFor(happyFlow);\n// on this line all the events within happyFlow have happened\n// otherwise timeout occurs and an assertion error is thrown\n</code></pre> <p>As you have probably already noticed <code>RecipeAssert</code> is chainable so the typical usage would probably be something like the following:</p> ScalaJava <pre><code>RecipeAssert(baker, recipeInstanceId)\n    .waitFor(happyFlow)\n    .assertEventsFlow(happyFlow)\n    .assertIngredient(\"ingredientA\").isEqual(ingredientValueA)\n    .assertIngredient(\"ingredientB\").isEqual(ingredientValueB)\n</code></pre> <pre><code>RecipeAssert.of(baker, recipeInstanceId)\n    .waitFor(happyFlow)\n    .assertEventsFlow(happyFlow)\n    .assertIngredient(\"ingredientA\").isEqual(ingredientValueA)\n    .assertIngredient(\"ingredientB\").isEqual(ingredientValueB);\n</code></pre>"},{"location":"sections/cookbook/visualizations/","title":"Visualizations","text":"<p>Bakers ability to visualize recipes provides a powerful communication tool that helps product owners, architects,  and engineers to have a common understanding of the business process. This feature allows you to easily share your  recipe with others, enabling collaboration and feedback.</p>"},{"location":"sections/cookbook/visualizations/#visualize-a-recipe","title":"Visualize a recipe","text":"<p>Baker uses Graphviz to visualize recipes. You can generate a Graphviz String from the  compiled recipe. </p> JavaKotlinScala <pre><code>package examples.java.visualization;\n\nimport com.ing.baker.compiler.RecipeCompiler;\nimport com.ing.baker.il.CompiledRecipe;\nimport examples.java.recipes.WebShopRecipe;\n\npublic class WebShopVisualization {\n    public void printVisualizationString() {\n        CompiledRecipe compiledRecipe = RecipeCompiler.compileRecipe(WebShopRecipe.recipe);\n        String graphvizString = compiledRecipe.getRecipeVisualization();\n        System.out.println(graphvizString);\n    }\n}\n</code></pre> <pre><code>package examples.kotlin.visualization\n\nimport com.ing.baker.compiler.RecipeCompiler\nimport com.ing.baker.recipe.kotlindsl.ExperimentalDsl\nimport examples.kotlin.recipes.WebShopRecipe\n\n@ExperimentalDsl\nfun printVisualizationString() {\n    val compileRecipe = RecipeCompiler.compileRecipe(WebShopRecipe.recipe)\n    val graphvizString = compileRecipe.recipeVisualization\n    println(graphvizString)\n}\n</code></pre> <pre><code>package examples.scala.visualization\n\nimport com.ing.baker.compiler.RecipeCompiler\nimport examples.scala.recipes.WebShopRecipe\n\nclass WebShopVisualization {\n  def printVisualizationString(): Unit = {\n    val compiledRecipe = RecipeCompiler.compileRecipe(WebShopRecipe.recipe)\n    val visualization = compiledRecipe.getRecipeVisualization\n    println(visualization)\n  }\n}\n</code></pre> <p>Running the method above, with the <code>WebShopRecipe</code> from the tutorial results in the following Graphviz String:</p> Graphviz String <pre><code>digraph {\n    node [fontname = \"ING Me\", fontsize = 22, fontcolor = white]\n    pad = 0.2\n    orderId -&gt; CancelOrder\n    CancelOrder [shape = rect, style = \"rounded, filled\", color = \"#525199\", penwidth = 2, margin = 0.5]\n    OrderHasUnavailableItems -&gt; CancelOrder\n    address -&gt; ShipOrder\n    CheckStock [shape = rect, style = \"rounded, filled\", color = \"#525199\", penwidth = 2, margin = 0.5]\n    OrderPlaced -&gt; address\n    CancelOrder -&gt; OrderCancelled\n    CheckStock -&gt; SufficientStock\n    orderId [shape = circle, style = filled, color = \"#FF6200\"]\n    orderId -&gt; ShipOrder\n    OrderPlaced [shape = diamond, style = \"rounded, filled\", color = \"#767676\", fillcolor = \"#D5D5D5\", fontcolor = black, penwidth = 2, margin = 0.3]\n    OrderCancelled [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3]\n    OrderHasUnavailableItems [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3]\n    unavailableProductIds -&gt; CancelOrder\n    ShipOrder [shape = rect, style = \"rounded, filled\", color = \"#525199\", penwidth = 2, margin = 0.5]\n    productIds -&gt; CheckStock\n    customerId [shape = circle, style = filled, color = \"#FF6200\"]\n    SufficientStock -&gt; ShipOrder\n    OrderPlaced -&gt; orderId\n    OrderShipped [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3]\n    orderId -&gt; CheckStock\n    OrderPlaced -&gt; customerId\n    CheckStock -&gt; OrderHasUnavailableItems\n    unavailableProductIds [shape = circle, style = filled, color = \"#FF6200\"]\n    OrderPlaced -&gt; productIds\n    ShipOrder -&gt; OrderShipped\n    SufficientStock [shape = diamond, style = \"rounded, filled\", color = \"#767676\", margin = 0.3]\n    productIds [shape = circle, style = filled, color = \"#FF6200\"]\n    address [shape = circle, style = filled, color = \"#FF6200\"]\n    OrderHasUnavailableItems -&gt; unavailableProductIds\n}\n</code></pre> <p>The easiest way to convert the Graphviz string into an image is by using an online converter.</p> Web-shop Recipe Visualization <p></p> <p>The diamonds are events. Light gray for sensory events, dark gray for output events. Ingredients are shown as orange circles, and the purple rectangles are interactions. </p> <p>Tip</p> <p>Don't like the default style? It's possible to override the default style by passing an optional <code>RecipeVisualStyle</code>  argument to <code>recipe.getRecipeVisualization</code>. </p>"},{"location":"sections/cookbook/visualizations/#visualize-recipe-state","title":"Visualize recipe state","text":"<p>Visualizing the state of a running recipe can also be useful. You can fetch the state visualization of a running (or finished) recipe via <code>baker.getVisualState(recipeInstanceId)</code>. </p> Web-shop recipe instance state visualization <p></p>"},{"location":"sections/reference/baker-types-and-values/","title":"Baker Types and Values","text":"<p>Because of the distributed nature of Baker and how the runtime works, we need to have serializable types and values to  transfer recipes and data between nodes and to match over such data, that is why we implemented a type system on top of Scala. They help not just to model your domain but also for Baker to identify when to execute interactions. </p> <p>If you are using all of our reflection APIs then you will not use them directly, but it is good to know of their  existence.</p> ScalaJava <pre><code>import com.ing.baker.types._\n\nval data: (Type, Value) = (Int32, PrimitiveValue(42))\n</code></pre> <pre><code>import com.ing.baker.types.*;\n\nType dataType = Int32$.MODULE$;\nValue dataValue = PrimitiveValue.apply(42);\n</code></pre> <p><code>Types</code> are specifically used to describe <code>Ingredients</code>, specifically <code>Ingredients</code> are just a relation between a name and a type. </p> <p>In a similar way that a programming language variable is just a relation between a name and a type at compile time, the  baker <code>Ingredient</code> is a relation between a name and a Baker <code>Type</code> at \"recipe time\"; the same happens with values, in a  programming language values must respect types otherwise runtime exceptions are thrown, similarly in Baker, at runtime  the name of an ingredient will hold a value that respects the ingredient's type.</p> <p>Here is a complete list of <code>Types</code> and <code>Values</code> of Baker.</p>"},{"location":"sections/reference/baker-types-and-values/#primitives","title":"Primitives","text":"Type Java parallel Description <code>Bool</code> <code>boolean</code> single bit, <code>true</code> or <code>false</code>, <code>1</code> or <code>0</code> <code>Char</code> <code>char</code> Unsigned <code>16</code> bit integer <code>Byte</code> <code>byte</code> Signed <code>8</code> bit integer <code>Int16</code> <code>short</code> Signed <code>16</code> bit integer <code>Int32</code> <code>int</code> Signed <code>32</code> bit integer <code>Int64</code> <code>long</code> Signed <code>64</code> bit integer <code>IntBig</code> <code>BigInteger</code> Integer of arbitrary size <code>Float32</code> <code>float</code> Signed <code>32</code> bit floating point <code>Float64</code> <code>double</code> Signed <code>64</code> bit floating point <code>FloatBig</code> <code>BigDecimal</code> Floating point of arbitrary size <code>Date</code> <code>long</code> A UTC date in the ISO-8601 calendar system with millisecond precision <code>ByteArray</code> <code>Array&lt;Byte&gt;</code> Byte array, often used for binary data <code>CharArray</code> <code>String</code> Character array, or commmonly called <code>String</code>"},{"location":"sections/reference/baker-types-and-values/#structured-types","title":"Structured types","text":"Type Java parallel Description <code>ListType&lt;T&gt;</code> <code>java.util.List&lt;T&gt;</code> A list of values, all of the same type <code>OptionType&lt;T&gt;</code> <code>java.util.Optional&lt;T&gt;</code> Matches against <code>T</code> or <code>null</code> <code>EnumType</code> <code>enum class</code> A set of predifined options (strings) <code>RecordType</code> <code>POJO class</code> A record with a specific set of fields <code>MapType&lt;T&gt;</code> <code>java.util.Map&lt;String, T&gt;</code> A record with arbitrary fields, all of the same type"},{"location":"sections/reference/baker-types-and-values/#values","title":"Values","text":"<p>Values are pure data without any direct associated type. These very closely match the JSON data format.</p> Value Description <code>NullValue</code> Analogues to <code>null</code>, <code>Optional.empty</code>, <code>None</code>, etc ... <code>PrimitiveValue</code> Wrapper for for: - A Java primitive (or boxed variant) - <code>java.lang.String</code> - <code>java.math.BigInteger</code> - <code>java.math.BigDecimal</code> - <code>scala.math.BigInt</code> - <code>Array&lt;Byte&gt;</code> <code>ListValue</code> A list of values <code>RecordValue</code> A set of <code>String -&gt; Value</code> pairs"},{"location":"sections/reference/baker-types-and-values/#interoptability-with-java-types","title":"Interoptability with java types","text":"<p>Because it is impractical to directly work with the baker types in java/scala code there is conversion system.</p>"},{"location":"sections/reference/baker-types-and-values/#default-supported-types","title":"Default supported types","text":""},{"location":"sections/reference/baker-types-and-values/#java","title":"java","text":"<ul> <li>primitives and their boxed variants</li> <li>Enum types</li> <li>java.util.List</li> <li>java.util.Set</li> <li>java.util.Map</li> <li>java.math.BigInt</li> <li>java.math.BigDecimal</li> <li>java.util.Optional</li> <li>POJO classes</li> </ul>"},{"location":"sections/reference/baker-types-and-values/#scala","title":"scala","text":"<ul> <li>primitives and their boxed variants</li> <li>case classes</li> <li>scala.collection.immutable.List</li> <li>scala.collection.immutable.Set</li> <li>scala.collection.immutable.Map</li> <li>BigInt</li> <li>BigDecimal</li> <li>scala.Option</li> </ul>"},{"location":"sections/reference/baker-types-and-values/#registering-a-custom-type-adapter","title":"Registering a custom type adapter","text":"<p>All default type adapters are registered in the reference.conf of the <code>baker-types</code> module.</p> <p>You can add your custom type adapter by registering it in a <code>reference.conf</code>.</p> <pre><code>baker.types {\n\n   \"com.example.MyCustomType\" = \"com.example.MyCustomTypeAdpater\"\n}\n</code></pre> <p>For an example how to implement an adapter see here</p>"},{"location":"sections/reference/execution-semantics/","title":"Execution Semantics","text":""},{"location":"sections/reference/execution-semantics/#execution-loop","title":"Execution loop","text":"<p>This is a short description of the execution loop of a <code>RecipeInstance</code></p> <ol> <li>An <code>EventInstance</code> is fired and provides ingredients, either given to baker as a sensory event or as an output     of an <code>InteractionInstance</code>.</li> <li>Baker tries to match the currently available provided <code>IngredientInstances</code> with the input of awaiting <code>InteractionInstances</code>.</li> <li><code>InteractionInstances</code> that can be called, execute and when complete they fire more <code>EventInstances</code>, repeating the    loop from step 1.</li> <li>This continues until there are no more <code>InteractionInstances</code> to execute, and the process is considered complete.</li> </ol>"},{"location":"sections/reference/execution-semantics/#notes","title":"Notes","text":"<ul> <li>A sensory event may be provided 1 or more times depending on its <code>firing limit</code>.</li> <li>When <code>IngredientInstances</code> are provided multiple times, the latest value overrides the previous.</li> <li>An <code>InteractionInstance</code> fires when all it's <code>IngredientInstances</code> and required <code>Events</code> are provided.     This may happen 1 or more times depending on the <code>maximum interaction count</code>.</li> </ul>"},{"location":"sections/reference/execution-semantics/#in-depth","title":"In depth","text":"<p>This section explains deeply how <code>ProcessInstances</code> work, and how they execute your recipes. You don't have to understand this part to develop with Baker. It is just extra documentation for the curious and the contributors.</p> <p>A recipe can be represented (and visualized) as a graph, which is actually a higher level representation of a Petri net (which is also a graph). When the process is represented as such it enables the <code>RecipeInstance</code> to execute the previously described execution loop, because Baker has your process state as a data structure that can be preserved as the state of the <code>RecipeInstance</code>. That is why you need to first use the <code>RecipeCompiler</code> and compile the recipe into a <code>CompiledRecipe</code> (petri net representation) before  running a <code>RecipeInstance</code> from it.</p>"},{"location":"sections/reference/execution-semantics/#translation-rules","title":"Translation rules","text":"<p>The compiler has some rules about translating recipe parts to <code>transitions</code> and <code>places</code> in the petri net.</p>"},{"location":"sections/reference/execution-semantics/#ingredient-used-by-multiple-interactions","title":"Ingredient used by multiple interactions","text":"<p>Often an ingredient will be used by multiple interactions in a recipe.</p> <p>Because tokens can only be consumed by one transition we have to add a layer to duplicate the token for all transitions.</p> <p></p>"},{"location":"sections/reference/execution-semantics/#interaction-with-precondition-and","title":"Interaction with precondition (AND)","text":"<p>By default event preconditions use an AND combinator. In the petri net this means that each event transition has to produce a token in a place for that interaction.</p> <p></p>"},{"location":"sections/reference/execution-semantics/#interaction-with-precondition-or","title":"Interaction with precondition (OR)","text":"<p>Events that are grouped in an OR combinator for an interaction output a token to the same place.</p> <p>Therefor when one of them fires the condition for the transition to fire is met.</p> <p></p>"},{"location":"sections/reference/execution-semantics/#sensory-event-with-firing-limit","title":"Sensory event with firing limit","text":"<p>When specifying a sensory event with a firing limit of <code>n</code> we generate an in-adjacent place with <code>n</code> tokens in the initial marking.</p> <p></p>"},{"location":"sections/reference/main-abstractions/","title":"Main Abstractions","text":"<p>Baker makes a strong division between the specification of your business process and the runtime implementations.</p> Specification Runtime <code>Type</code> <code>Value</code> <code>Ingredient</code> <code>IngredientInstance</code> <code>Event</code> <code>EventInstance</code> <code>Interaction</code> <code>InteractionInstance</code> <code>Recipe</code> <code>RecipeInstance</code> <p>The first four are used to create <code>Recipe</code>s which serve as \"blueprints\" of your process. In the Baker runtime they are used within <code>RecipeInstance</code>s, which are created from a <code>Recipe</code> specification to execute the flow of  your process.</p>"},{"location":"sections/reference/main-abstractions/#type-and-value","title":"Type and Value","text":"<p>Because of the distributed nature of Baker and how the runtime works, we need to have serializable types and values to  transfer recipes and data between nodes and to match over such data, that is why we implemented a type system on top of Scala. They help not just to model your domain, but also for Baker to identify when to execute interactions. </p> <p>If you are using all of our reflection APIs then you will not use them directly, but it is good to know of their  existence.</p> <p>Full documentation about the type system can be found here.</p> ScalaJava <pre><code>import com.ing.baker.types._\n\nval data: (Type, Value) = (Int32, PrimitiveValue(42))\n</code></pre> <pre><code>import com.ing.baker.types.*;\n\nType dataType = Int32$.MODULE$;\nValue dataValue = PrimitiveValue.apply(42);\n</code></pre>"},{"location":"sections/reference/main-abstractions/#ingredient-and-ingredientinstance","title":"Ingredient and IngredientInstance","text":"<p><code>Ingredients</code> are containers for the data in your process. This data is immutable, which means that it can only be created and never  changes in the process. There is no subtyping, nor hierarchy. <code>Ingredients</code> are carried through your process  with <code>Events</code>, and are inputs for <code>Interactions</code>.</p> <p>For a <code>Recipe</code> there exist <code>Ingredients</code> which are a name and a <code>Type</code>, they are used to model the data of your process.</p> <p>For a <code>RecipeInstance</code> there exist <code>IngredientInstance</code>s, which are a name and a <code>Value</code>, they are used to move data  through your process. </p> ScalaJava <pre><code>import com.ing.baker.recipe.scaladsl.Ingredient\n\nval OrderId: Ingredient[String] =\n    Ingredient[String](\"orderId\")\n\n\nimport com.ing.baker.runtime.scaladsl.IngredientInstance\n\nval orderIdInstance: IngredientInstance = \n    IngredientInstance(\"orderId\", PrimitiveValue(\"uuid-123456789\"))\n</code></pre> <pre><code>// In Java, Ingredients are extracted from a class \n// representing an Event by using java reflection.\n// See the full example at the \"Recipe and RecipeInstance\" section\n</code></pre>"},{"location":"sections/reference/main-abstractions/#event-and-eventinstance","title":"Event and EventInstance","text":"<p><code>Events</code> represent happenings in your process that might carry <code>Ingredients</code>, they represent an \"asynchronous boundary\", they are always either output from <code>Interactions</code> or a special case called <code>SensoryEvent</code>s; we call sensory events to the  events that come from \"outside\" of your recipe and are normally used to start your process.</p> <p>For a <code>Recipe</code> there exist <code>Events</code> which are a name, a set of <code>Ingredients</code> and a maximum amount of firings; the  <code>maxFiringLimit</code> is a property which describes the number of times an event is allowed to fire, this is later on enforced by the Baker runtime. To know more about firing limits and all the other configurable properties, please  refer to the DSLs documentation.</p> <p>For a <code>RecipeInstance</code> there exist <code>EventInstance</code>s which are data structures that must match their interface equivalent declared as <code>Events</code> on the <code>Recipe</code>. They notify a baker <code>RecipeInstance</code> of an actual happening and may carry <code>Ingredient</code> values; the baker <code>RecipeInstance</code> will then use available <code>Ingredients</code> to execute <code>InteractionInstance</code>s.</p> <p>Note: Names of sensory <code>Event</code> and <code>EventInstance</code> must match, so that Baker can correctly execute your process flow.</p> ScalaJava <pre><code>/** Event */\nimport com.ing.baker.recipe.scaladsl.Event\nimport com.ing.baker.recipe.scaladsl.Ingredient\n\nval OrderPlaced: Event = Event(\n  name = \"OrderPlaced\",\n  providedIngredients = Seq(\n    Ingredient[String](\"orderId\"),\n    Ingredient[List[String]](\"items\")\n  ),\n  maxFiringLimit = Some(1)\n)\n\n/** EventInstance */\nimport com.ing.baker.runtime.scaladsl.EventInstance\nimport com.ing.baker.types.{PrimitiveValue, ListValue}\n\nval firstOrderPlaced: EventInstance = EventInstance(\n  name = \"OrderPlaced\",\n  providedIngredients = Map(\n    \"orderId\" -&gt; PrimitiveValue(\"uuid-0123456789\"),\n    \"items\" -&gt; ListValue(List(PrimitiveValue(\"item1-id\"), PrimitiveValue(\"item2-id\")))\n  )\n)\n</code></pre> <pre><code>// In Java, Events and EventInstances are extracted from a \n// class by using java reflection.\n// Please check the full recipe example below on the \n// Recipe and RecipeInstance subsection\n\nimport com.ing.baker.runtime.javadsl.EventInstance;\n\npublic static class OrderPlaced {\n\n    public final String orderId;\n    public final List&lt;String&gt; items;\n\n    public OrderPlaced(String orderId, List&lt;String&gt; items) {\n        this.orderId = orderId;\n        this.items = items;\n    }\n}\n\nList&lt;String&gt; items = new ArrayList&lt;&gt;(2);\nitems.add(\"item1\");\nitems.add(\"item2\");\nOrderPlaced order1 = new OrderPlaced(\"uuid-0123456789\", items);\nEventInstance order1Event = EventInstance.from(order1);\n</code></pre> <p>To fire a <code>SensoryEvent</code> use the <code>bakerRuntime.fireEvent(recipeInstanceId, event)</code> API variations,  after creating the baker runtime, adding your recipe to the runtime and <code>baking</code> a <code>RecipeInstance</code>. For full  documentation on this please refer to the runtime documentation.</p> ScalaJava <pre><code>import akka.actor.ActorSystem\nimport com.ing.baker.runtime.common.EventResult\nimport com.ing.baker.runtime.scaladsl.{Baker, EventInstance}\n\nimport scala.concurrent.Future\n\nimplicit val actorSystem: ActorSystem =\n    ActorSystem(\"WebshopSystem\")\nval baker: Baker = AkkaBaker.localDefault(actorSystem)\n\n// This example is using the reflection API `EventInstance.unsafeFrom`\nval FirstOrderPlaced: EventInstance = EventInstance\n    .unsafeFrom(OrderPlaced(\"order-uuid\", List(\"item1\", \"item2\")))\nval recipeInstanceId: String = \"recipe id from previously baked recipe instance\"\n\nval result: Future[EventResult] = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, FirstOrderPlaced)\n</code></pre> <pre><code>import akka.actor.ActorSystem;\nimport com.ing.baker.runtime.akka.AkkaBaker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport com.ing.baker.runtime.javadsl.EventResult;\n\nimport java.util.concurrent.CompletableFuture;\n\nActorSystem actorSystem = ActorSystem.create(\"WebshopSystem\");\nBaker baker = AkkaBaker.javaLocalDefault(actorSystem);\n\nString recipeInstanceId = \"recipe id from previously baked recipe instance\";\nList&lt;String&gt; items = new ArrayList&lt;&gt;(2);\nitems.add(\"item1\");\nitems.add(\"item2\");\nEventInstance firstOrderPlaced = \n        EventInstance.from(new JWebshopRecipe.OrderPlaced(\"order-uuid\", items));\n\nCompletableFuture&lt;EventResult&gt; result = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, firstOrderPlaced);\n</code></pre>"},{"location":"sections/reference/main-abstractions/#interaction-and-interactioninstance","title":"Interaction and InteractionInstance","text":"<p>An interaction resemblance a function, it requires input (<code>Ingredients</code>) and provides output (<code>Events</code>). Within this contract it may do anything. For example:</p> <ul> <li>Query a microservice</li> <li>Send messages to an event broker like Kafka</li> <li>Await for a message from an event broker</li> <li>Generate a file</li> <li>Do transformations on the ingredients (we like to call these interactions <code>Sieves</code>)</li> </ul> <p>For a <code>Recipe</code> there exist <code>Interactions</code> which are a name, a sequence of <code>Ingredients</code> describing all the input (all of), and a sequence of <code>Events</code> describing the possible event outputs (one of). At the recipe level there are several more  specifics that can be configured, like requiring events without ingredients, adding predefined ingredients, overriding ingredient names, or handling unexpected failure, for these please refer to the DSLs documentation.</p> <p>For a <code>RecipeInstance</code> there exist <code>InteractionInstance</code>s which are a name, an input type description, and an implementation of a method/function that will be called when the interaction is executed. The input name and the input type description  is used by the Baker runtime to find the correct <code>InteractionImplementation</code> to execute when the <code>Ingredients</code> are available.</p> <p>Note: Names of sensory <code>Event</code> and <code>EventInstance</code> must match, so that Baker can correctly execute your process flow.</p> <p>Note: For asynchronous programming, the Scala DSL <code>InteractionInstance</code> can return a <code>Future[A]</code> and the Java DSL can return a <code>CompletableFuture&lt;A&gt;</code>, and the Baker runtime will handle the async results of the instances.</p> ScalaJavaScala (Reflection API) <pre><code>/** Interaction */\nimport com.ing.baker.recipe.scaladsl.{Event, Ingredient, Interaction}\n\nval ReserveItems: Interaction = Interaction(\n    name = \"ReserveItems\",\n    inputIngredients = Seq(\n        Ingredient[String](\"orderId\"),\n        Ingredient[List[String]](\"items\")\n    ),\n    output = Seq(\n        Events.OrderHadUnavailableItems,\n        Events.ItemsReserved\n    )\n)\n\n/** InteractionInstance */\nimport com.ing.baker.runtime.scaladsl.{EventInstance, IngredientInstance, InteractionInstance}\nimport com.ing.baker.types.{CharArray, ListType, ListValue, PrimitiveValue}\n\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval ReserveItemsInstance = InteractionInstance(\n    name = ReserveItems.name,\n    input = Seq(CharArray, ListType(CharArray))\n    run = handleReserveItems\n)\n\ndef handleReserveItems(input: Seq[IngredientInstance]): Future[Option[EventInstance]] = ???\n    // ListValue and PrimitiveValue are used in the body\n</code></pre> <pre><code>/** Interaction */\nimport com.ing.baker.recipe.annotations.FiresEvent;\nimport com.ing.baker.recipe.annotations.RequiresIngredient;\nimport com.ing.baker.recipe.javadsl.Interaction;\n\npublic interface ReserveItems extends Interaction {\n\n    interface ReserveItemsOutcome {\n    }\n\n    class OrderHadUnavailableItems implements ReserveItemsOutcome {\n\n        public final List&lt;String&gt; unavailableItems;\n\n        public OrderHadUnavailableItems(List&lt;String&gt; unavailableItems) {\n            this.unavailableItems = unavailableItems;\n        }\n    }\n\n    class ItemsReserved implements ReserveItemsOutcome {\n\n        public final List&lt;String&gt; reservedItems;\n\n        public ItemsReserved(List&lt;String&gt; reservedItems) {\n            this.reservedItems = reservedItems;\n        }\n    }\n\n    // Annotations are needed for wiring ingredients and validating events.\n    @FiresEvent(oneOf = {OrderHadUnavailableItems.class, ItemsReserved.class})\n    // The name of the method must be \"apply\" for the reflection API to work.\n    // This method can also return a `CompletableFuture&lt;ReserveItemsOutcome&gt;` for asynchronous programming.\n    ReserveItemsOutcome apply(@RequiresIngredient(\"orderId\") String id, @RequiresIngredient(\"items\") List&lt;String&gt; items);\n}\n\n/** InteractionInstance */\nimport com.ing.baker.runtime.javadsl.InteractionInstance;\n\npublic class ReserveItems implements JWebshopRecipe.ReserveItems {\n\n    @Override\n    public ReserveItemsOutcome apply(String id, List&lt;String&gt; items) {\n        return new JWebshopRecipe.ReserveItems.ItemsReserved(items);\n    }\n}\n</code></pre> <pre><code>// See the DSLs documentation for more on the reflection API\ntrait ReserveItems {\n\n    def apply(orderId: String, items: List[String]): Future[WebshopRecipeReflection.ReserveItemsOutput]\n}\n\nclass ReserveItemsInstance extends ReserveItems {\n\n  override def apply(orderId: String, items: List[String]): Future[WebshopRecipeReflection.ReserveItemsOutput] = {\n\n    // Http call to the Warehouse service\n    val response: Future[Either[List[String], List[String]]] =\n    // This is mocked for the sake of the example\n      Future.successful(Right(items))\n\n    // Build an event instance that Baker understands\n    response.map {\n      case Left(unavailableItems) =&gt;\n        WebshopRecipeReflection.OrderHadUnavailableItems(unavailableItems)\n      case Right(reservedItems) =&gt;\n        WebshopRecipeReflection.ItemsReserved(reservedItems)\n    }\n  }\n}\n\nval reserveItemsInstance: InteractionInstance =\n  InteractionInstance.unsafeFrom(new ReserveItemsInstance)\n</code></pre> <p>After creating your <code>InteractionInstance</code>s, you need to add them to the baker runtime so that Baker can match them to the <code>Interactions</code> of your <code>Recipe</code> and call them when needed.</p> ScalaJava <pre><code>import akka.actor.ActorSystem\nimport com.ing.baker.runtime.scaladsl.Baker\n\nimport scala.concurrent.Future\n\nval done: Future[Unit] = baker.addInteractionInstance(reserveItemsInstance)\n</code></pre> <pre><code>import akka.actor.ActorSystem;\nimport com.ing.baker.runtime.akka.AkkaBaker;\n\nimport scala.runtime.BoxedUnit;\nimport java.util.concurrent.CompletableFuture;\n\nActorSystem actorSystem = ActorSystem.create(\"WebshopSystem\");\nBaker baker = AkkaBaker.javaLocalDefault(actorSystem);\n\nCompletableFuture&lt;BoxedUnit&gt; done = baker.addInteractionInstance(reserveItemsInstance);\n</code></pre>"},{"location":"sections/reference/main-abstractions/#recipe-and-recipeinstance","title":"Recipe and RecipeInstance","text":"<p>All you <code>Ingredients</code>, <code>Events</code> and <code>Interactions</code> must be added to a single unit called the <code>Recipe</code>, which works as the \"blueprint\" of your precess.</p> ScalaScala Full ExampleJavaJava Full Example <pre><code>import com.ing.baker.recipe.scaladsl.Recipe\n\nval recipe: Recipe = Recipe(\"Webshop\")\n    .withSensoryEvents(\n        Events.OrderPlaced\n    )\n    .withInteractions(\n        Interactions.ReserveItems,\n    )\n</code></pre> <pre><code>package webshop\n\nimport com.ing.baker.recipe.scaladsl.{Event, Ingredient, Interaction, Recipe}\n\nobject WebshopRecipeReflection {\n\n  case class OrderPlaced(orderId: String, items: List[String])\n\n  sealed trait ReserveItemsOutput\n\n  case class OrderHadUnavailableItems(unavailableItems: List[String]) extends ReserveItemsOutput\n\n  case class ItemsReserved(reservedItems: List[String]) extends ReserveItemsOutput\n\n  val ReserveItems = Interaction(\n    name = \"ReserveItems\",\n    inputIngredients = Seq(\n      Ingredient[String](\"orderId\"),\n      Ingredient[List[String]](\"items\")\n    ),\n    output = Seq(\n      Event[OrderHadUnavailableItems],\n      Event[ItemsReserved]\n    )\n  )\n\n  val recipe: Recipe = Recipe(\"Webshop\")\n    .withSensoryEvents(\n      Event[OrderPlaced],\n      Event[OrderHadUnavailableItems],\n      Event[ItemsReserved]\n    )\n    .withInteractions(\n      ReserveItems\n    )\n}\n</code></pre> <pre><code>import com.ing.baker.recipe.javadsl.Recipe;\nimport static com.ing.baker.recipe.javadsl.InteractionDescriptor.of;\n\npublic final static Recipe recipe = new Recipe(\"WebshopRecipe\")\n        .withSensoryEvents(OrderPlaced.class)\n        .withInteractions(of(ReserveItems.class));\n</code></pre> <pre><code>package webshop;\n\nimport com.ing.baker.recipe.annotations.FiresEvent;\nimport com.ing.baker.recipe.annotations.RequiresIngredient;\nimport com.ing.baker.recipe.javadsl.Interaction;\nimport com.ing.baker.recipe.javadsl.Recipe;\n\nimport java.util.List;\n\nimport static com.ing.baker.recipe.javadsl.InteractionDescriptor.of;\n\npublic class JWebshopRecipe {\n\n    public static class OrderPlaced {\n\n        public final String orderId;\n        public final List&lt;String&gt; items;\n\n        public OrderPlaced(String orderId, List&lt;String&gt; items) {\n            this.orderId = orderId;\n            this.items = items;\n        }\n    }\n\n    public interface ReserveItems extends Interaction {\n\n        interface ReserveItemsOutcome {\n        }\n\n        class OrderHadUnavailableItems implements ReserveItemsOutcome {\n\n            public final List&lt;String&gt; unavailableItems;\n\n            public OrderHadUnavailableItems(List&lt;String&gt; unavailableItems) {\n                this.unavailableItems = unavailableItems;\n            }\n        }\n\n        class ItemsReserved implements ReserveItemsOutcome {\n\n            public final List&lt;String&gt; reservedItems;\n\n            public ItemsReserved(List&lt;String&gt; reservedItems) {\n                this.reservedItems = reservedItems;\n            }\n        }\n\n        @FiresEvent(oneOf = {OrderHadUnavailableItems.class, ItemsReserved.class})\n        ReserveItemsOutcome apply(@RequiresIngredient(\"orderId\") String id, @RequiresIngredient(\"items\") List&lt;String&gt; items);\n    }\n\n    public final static Recipe recipe = new Recipe(\"WebshopRecipe\")\n        .withSensoryEvents(OrderPlaced.class)\n        .withInteractions(of(ReserveItems.class));\n}\n</code></pre> <p>A recipe must be added to a baker runtime so that you can create \"bake\" a <code>RecipeInstance</code> from it. For that it must be first \"compiled\" by using the provided compiler.</p> <p>Here is a full example of creating a baker runtime, adding the <code>InteractionInstances</code> and the compiled <code>Recipe</code> (order matters becase baker validates that all recipes have valid implementations when added), and firing an <code>Event</code> that will execute  the <code>Interaction</code></p> ScalaJava <pre><code>import akka.actor.ActorSystem\nimport com.ing.baker.compiler.RecipeCompiler\nimport com.ing.baker.il.CompiledRecipe\nimport com.ing.baker.runtime.scaladsl.EventInstance\nimport com.ing.baker.runtime.akka.AkkaBaker\n\nimplicit val actorSystem: ActorSystem =\n    ActorSystem(\"WebshopSystem\")\nval baker: Baker = AkkaBaker.localDefault(actorSystem)\n\nval compiledRecipe: CompiledRecipe = RecipeCompiler.compileRecipe(WebshopRecipe.recipe)\n\nval program: Future[Unit] = for {\n    _ &lt;- baker.addInteractionInstance(WebshopInstances.ReserveItemsInstance)\n    recipeId &lt;- baker.addRecipe(RecipeRecord.of(compiledRecipe))\n    _ &lt;- baker.bake(recipeId, \"first-instance-id\")\n    firstOrderPlaced: EventInstance =\n        EventInstance.unsafeFrom(WebshopRecipeReflection.OrderPlaced(\"order-uuid\", List(\"item1\", \"item2\")))\n    result &lt;- baker.fireEventAndResolveWhenCompleted(\"first-instance-id\", firstOrderPlaced)\n} yield assert(result.events == Seq(\n    WebshopRecipe.Events.OrderPlaced.name,\n    WebshopRecipe.Events.ItemsReserved.name\n))\n</code></pre> <pre><code>import akka.actor.ActorSystem;\nimport com.ing.baker.compiler.RecipeCompiler;\nimport com.ing.baker.il.CompiledRecipe;\nimport com.ing.baker.runtime.akka.AkkaBaker;\nimport com.ing.baker.runtime.javadsl.EventInstance;\nimport com.ing.baker.runtime.javadsl.EventResult;\nimport com.ing.baker.runtime.javadsl.InteractionInstance;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\n\nActorSystem actorSystem = ActorSystem.create(\"WebshopSystem\");\nBaker baker = AkkaBaker.javaLocalDefault(actorSystem);\n\nList&lt;String&gt; items = new ArrayList&lt;&gt;(2);\nitems.add(\"item1\");\nitems.add(\"item2\");\nEventInstance firstOrderPlaced =\n        EventInstance.from(new JWebshopRecipe.OrderPlaced(\"order-uuid\", items));\n\nInteractionInstance reserveItemsInstance = InteractionInstance.from(new ReserveItems());\nCompiledRecipe compiledRecipe = RecipeCompiler.compileRecipe(JWebshopRecipe.recipe);\n\nString recipeInstanceId = \"first-instance-id\";\nCompletableFuture&lt;List&lt;String&gt;&gt; result = baker.addInteractionInstance(reserveItemsInstance)\n    .thenCompose(ignore -&gt; baker.addRecipe(RecipeRecord.of(compiledRecipe)))\n    .thenCompose(recipeId -&gt; baker.bake(recipeId, recipeInstanceId))\n    .thenCompose(ignore -&gt; baker.fireEventAndResolveWhenCompleted(recipeInstanceId, firstOrderPlaced))\n    .thenApply(EventResult::events);\n\nList&lt;String&gt; blockedResult = result.join();\nassert(blockedResult.contains(\"OrderPlaced\") &amp;&amp; blockedResult.contains(\"ReservedItems\"));\n</code></pre>"},{"location":"sections/reference/runtime/","title":"The Baker Runtime","text":"<p>Baker provider several constructors to build a runtime to run your Recipes on. The current implementations are an in memory implementation and an Akka based implementation. </p>"},{"location":"sections/reference/runtime/#akka-runtime","title":"Akka Runtime","text":"<p>The Akka based implementation can be configured to run in local mode or in cluster mode. We advised to use the in memory Baker instead of the Akka Baker in local mode if you do not require state.</p>"},{"location":"sections/reference/runtime/#bakerakkaconfig-actorsystem","title":"Baker.akka(config, actorSystem)","text":"<p>Note: We recommend reviewing also Akka configuration.</p> ScalaJava <pre><code>import akka.actor.ActorSystem\nimport com.ing.baker.runtime.scaladsl.Baker\nimport com.typesafe.config.{Config, ConfigFactory}\n\n\nval actorSystem: ActorSystem = ActorSystem(\"WebshopSystem\")\nval config: Config = ConfigFactory.load()\n\nval baker: Baker = Baker.akka(config, actorSystem)\n</code></pre> <pre><code>import akka.actor.ActorSystem;\nimport com.ing.baker.runtime.javadsl.Baker;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigFactory;\n\n\nActorSystem actorSystem = ActorSystem.create(\"WebshopSystem\");\nConfig config = ConfigFactory.load();\n\nBaker baker = Baker.akka(config, actorSystem);\n</code></pre> <p>This last code snippet will build a Baker runtime and load all configuration from your default <code>application.conf</code> located  in the resources directory. You can see more about configuration on this section.</p> <p>Alternatively there is a constructor that will provide the default configuration for a local mode Baker, this  is recommended for tests.</p> ScalaJava <pre><code>val baker: Baker = AkkaBaker.localDefault(actorSystem)\n</code></pre> <pre><code>Baker baker = AkkaBaker.javaLocalDefault(actorSystem);\n</code></pre>"},{"location":"sections/reference/runtime/#advantages-of-the-cluster-mode","title":"Advantages of the Cluster Mode","text":"<p>The capabilities gained when in cluster mode are:</p> <ul> <li>Elasticity: by adding/removing nodes to the cluster.</li> <li>Resilience: <code>RecipeInstances</code> are automatically restored in a new node when the hosting node fails. (For this you need to configure  a distributed data store like Cassandra)</li> <li>Routing: You can fire <code>EventInstances</code> from anywhere on the cluster, and Baker will ensure that the corresponding <code>RecipeInstance</code> receives the firing event.</li> </ul> <p>Note: To run on cluster mode you need to configure a distributed data store, we highly recommend using Cassandra.</p>"},{"location":"sections/reference/runtime/#interactioninstancefromobject-reflection-api","title":"InteractionInstance.from(object) (Reflection API)","text":"<p>As part of our efforts to ease the creation of <code>InteractionInstances</code> we created this function that uses the Scala and the Java reflection capabilities to create an <code>InteractionInstance</code> from an instance of a class.</p> <p>The name of the <code>InteractionInstance</code> will be taken from the name of the implementing <code>interface</code> (Java) or <code>trait</code> (Scala)  (it must match the name of the <code>Interaction</code> at the <code>Recipe</code>).</p> <p>The interface MUST declare a public method called <code>apply</code>, and the types must match those of the expected provided ingredients.</p> <p>Notice that his function might throw an exception if the instance is not correctly done (this is why in Scala the API is named \"unsafe\").</p> ScalaJava <pre><code>import com.ing.baker.runtime.scaladsl.InteractionInstance\n\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nsealed trait ReserveItemsOutput\ncase class OrderHadUnavailableItems(unavailableItems: List[String]) extends ReserveItemsOutput\ncase class ItemsReserved(reservedItems: List[String]) extends ReserveItemsOutput\n\ntrait ReserveItems {\n\n  def apply(orderId: String, items: List[String]): Future[ReserveItemsOutput]\n}\n\nclass ReserveItemsInstance extends ReserveItems {\n\n  override def apply(orderId: String, items: List[String]): Future[ReserveItemsOutput] = {\n\n    // Http call to the Warehouse service\n    val response: Future[Either[List[String], List[String]]] =\n    // This is mocked for the sake of the example\n      Future.successful(Right(items))\n\n    // Build an event instance that Baker understands\n    response.map {\n      case Left(unavailableItems) =&gt;\n        OrderHadUnavailableItems(unavailableItems)\n      case Right(reservedItems) =&gt;\n        ItemsReserved(reservedItems)\n    }\n  }\n}\n\nval reserveItemsInstance: InteractionInstance =\n  InteractionInstance.unsafeFrom(new ReserveItemsInstance)\n</code></pre> <pre><code>import com.ing.baker.runtime.javadsl.InteractionInstance;\nimport com.ing.baker.runtime.javadsl.Interaction;\n\n/** Java interface used for the Recipe */\npublic interface ReserveItems extends Interaction {\n\n    interface ReserveItemsOutcome {}\n\n    class OrderHadUnavailableItems implements ReserveItemsOutcome {\n\n        public final List&lt;String&gt; unavailableItems;\n\n        public OrderHadUnavailableItems(List&lt;String&gt; unavailableItems) {\n            this.unavailableItems = unavailableItems;\n        }\n    }\n\n    class ItemsReserved implements ReserveItemsOutcome {\n\n        public final List&lt;String&gt; reservedItems;\n\n        public ItemsReserved(List&lt;String&gt; reservedItems) {\n            this.reservedItems = reservedItems;\n        }\n    }\n\n    @FiresEvent(oneOf = {OrderHadUnavailableItems.class, ItemsReserved.class})\n    ReserveItemsOutcome apply(@RequiresIngredient(\"orderId\") String id, @RequiresIngredient(\"items\") List&lt;String&gt; items);\n}\n\n/** Implementation of the interface used for creating an InteractionInstance */\npublic class ReserveItems implements JWebshopRecipe.ReserveItems {\n\n    // The body of this method is going to be executed by the Baker runtime when the ingredients are available.\n    @Override\n    public ReserveItemsOutcome apply(String id, List&lt;String&gt; items) {\n        return new ReserveItems.ItemsReserved(items);\n    }\n}\n\n/** Create an InteractionInstance from an instance of the ReserveItems implementation */        \nInteractionInstance reserveItemsInstance = InteractionInstance.from(new ReserveItems());\n</code></pre>"},{"location":"sections/reference/runtime/#bakeraddinteractioninstanceinteractioninstance","title":"baker.addInteractionInstance(interactionInstance)","text":"<p>The Baker runtime requires you to add all <code>InteractionInstances</code> before adding any related <code>CompiledRecipes</code>. This can be done using the <code>baker.addInteractionInstance(interactionInstance)</code> or the <code>baker.addInteractionInstances(intance1, instance2, ...)</code> APIs.</p> <p>Note: in Java the api returns a <code>CompletableFuture&lt;BoxedUnit&gt;</code>, this is because the API is implemented in Scala, so  Scala's <code>Unit</code> get translated to <code>BoxedUnit</code>, but you should you ignore it and consider it as good as Java's <code>void</code>, except it comes in a <code>CompletableFuture</code> that will help you handle async programming.</p> ScalaJava <pre><code>val baker: Baker = AkkaBaker.localDefault(actorSystem)\n\nval reserveItemsInstance: InteractionInstance = InteractionInstance.unsafeFrom(new ReserveItems())\n\nval result: Future[Unit] = baker.addInteractionInstance(reserveItemsInstance)\n</code></pre> <pre><code>Baker baker = AkkaBaker.javaLocalDefault(actorSystem);\n\nInteractionInstance reserveItemsInstance = InteractionInstance.from(new ReserveItems());\n\nCompletableFuture&lt;BoxedUnit&gt; = baker.addInteractionInstance(reserveItemsInstance);\n</code></pre>"},{"location":"sections/reference/runtime/#recipecompilercompilerecipe","title":"RecipeCompiler.compile(recipe)","text":"<p><code>Recipes</code> once built must be converted into a data structure called <code>CompiledRecipe</code> that lets <code>RecipeInstances</code>  to understand, store and run your process. These can be used to create a new <code>RecipeInstance</code> from a <code>baker</code>  runtime that contains both a <code>CompiledRecipe</code> and the required <code>InteractionInstances</code>, or they can as well be converted into a visualization.</p> ScalaJava <pre><code>import com.ing.baker.compiler.RecipeCompiler\nimport com.ing.baker.il.CompiledRecipe\n\nval compiledRecipe: CompiledRecipe = RecipeCompiler.compileRecipe(recipe)\n</code></pre> <pre><code>import com.ing.baker.compiler.RecipeCompiler;\nimport com.ing.baker.il.CompiledRecipe;\n\nCompiledRecipe compiledRecipe = RecipeCompiler.compileRecipe(recipe);\n</code></pre>"},{"location":"sections/reference/runtime/#bakeraddrecipereciperecordofcompiledrecipe","title":"baker.addRecipe(RecipeRecord.of(compiledRecipe))","text":"<p>Once <code>Recipes</code> have been transformed into <code>CompiledRecipes</code> they must be added to a baker runtime. The <code>baker.addRecipe(RecipeRecord.of(compiledRecipe))</code> API will do so and return an id that you can use to reference the added recipe later on.</p> <p>Note: Before doing this, baker requires you to add all related <code>InteractionInstances</code> to the runtime, this is because baker  does validation to ensure that every recipe is runnable from the previously added <code>InteractionInstances</code>.</p> JavaJava <pre><code>val recipeId Future[String] = baker.addRecipe(RecipeRecord.of(compiledRecipe))\n</code></pre> <pre><code>CompletableFuture&lt;String&gt; recipeId = baker.addRecipe(RecipeRecord.of(compiledRecipe));\n</code></pre>"},{"location":"sections/reference/runtime/#bakergetallrecipes","title":"baker.getAllRecipes()","text":"<p>The baker at runtime can give you a map of all the currently available recipes that has been previously added to Baker.</p> ScalaJava <pre><code>import com.ing.baker.runtime.scaladsl.RecipeInformation\nimport scala.concurrent.Future\n\nval allRecipes: Future[Map[String, RecipeInformation]] = baker.getAllRecipes\n</code></pre> <pre><code>import com.ing.baker.runtime.javadsl.RecipeInformation;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.Map;\n\nCompletableFuture&lt;Map&lt;String, RecipeInformation&gt;&gt; allRecipe = baker.getAllRecipes();\n</code></pre>"},{"location":"sections/reference/runtime/#bakerbakerecipeid-recipeinstanceid","title":"baker.bake(recipeId, recipeInstanceId)","text":"<p>Once the Baker runtime contains a <code>CompiledRecipe</code> and all the associated <code>InteractionInstances</code> then you can use the  <code>baker.bake(recipeId, recipeInstanceId)</code> API to create a <code>RecipeInstance</code> that will contain the state of your process and execute any <code>InteractionInstance</code> as soon as all its required <code>InteractionIngredients</code> are available.</p> <p>Note: This API requires you to choose a <code>recipeInstanceId</code>, the API does not provide one for you, this is so that  you can manage this reference as required.</p> <p>Note: in Java the api returns a <code>CompletableFuture&lt;BoxedUnit&gt;</code>, this is because the API is implemented in Scala, so  Scala's <code>Unit</code> get translated to <code>BoxedUnit</code>, but you should you ignore it and consider it as good as Java's <code>void</code>, except it comes in a <code>CompletableFuture</code> that will help you handle async programming.</p> ScalaJava <pre><code>val program: Future[Unit] = for {\n  _ &lt;- baker.addInteractionInstance(interactionInstances)\n  recipeId &lt;- baker.addRecipe(RecipeRecord.of(compiledRecipe))\n  recipeInstanceId = \"my-id\"\n  _ &lt;- baker.bake(recipeId, recipeInstanceId)\n} yield ()\n</code></pre> <pre><code>String recipeInstanceId = \"my-id\";\nCompletableFuture&lt;BoxedUnit&gt; result = baker.addInteractionInstace(reserveItemsInstance)\n    .thenCompose(ignore -&gt; baker.addRecipe(RecipeRecord.of(compiledRecipe)))\n    .thenCompose(recipeId -&gt; baker.bake(recipeId, recipeInstanceId));\n</code></pre>"},{"location":"sections/reference/runtime/#eventinstancefromobject","title":"EventInstance.from(object)","text":"<p>As part of our efforts to ease the creation of <code>EventInstances</code>, we added a function that uses Java and Scala reflection  to create <code>EventInstances</code> from class objects.</p> <p>The name of the <code>EventInstance</code> will be taken from the name of the <code>class</code> (Java) or <code>case class</code> (Scala)  (it must match the name of the <code>Event</code> at the <code>Recipe</code>). And the argument names and types of the constructors will be  translated to <code>IngredientInstances</code> with corresponding names and baker types.</p> <p>Notice that this function might throw an exception if the event is not correctly done (this is why in Scala the API is named \"unsafe\").</p> ScalaJava <pre><code>import com.ing.baker.runtime.scaladsl.EventInstance\n\ncase class OrderPlaced(orderId: String, items: List[String])\n\nval firstOrderPlaced: EventInstance = \n    EventInstance.unsafeFrom(OrderPlaced(\"order-id\", List(\"item1\", \"item2\")))\n</code></pre> <pre><code>import com.ing.baker.runtime.javadsl.EventInstance;\n\nclass OrderPlaced {\n\n    String orderId;\n    List&lt;String&gt; items;\n\n    public OrderPlaced(String orderId, List&lt;String&gt; items) {\n        this.orderId = orderId;\n        this.items = items;\n    }\n}\n\nEventInstance firstOrderPlaced =\n    EventInstance.from(new JWebshopRecipe.OrderPlaced(\"order-uuid\", items));\n</code></pre>"},{"location":"sections/reference/runtime/#bakerfireeventrecipeinstanceid-eventinstance","title":"baker.fireEvent(recipeInstanceId, eventInstance)","text":"<p>After creation of a <code>RecipeInstance</code>, you use one of the variations of <code>baker.fireEvent(recipeInstanceId, eventInstance)</code> to fire your <code>EventInstances</code> and start/continue the process flow. There are several supported semantics for firing an  event which depend on the moment you want to get notified and continue your asynchronous computation, these are the 4  different moments:</p> <ol> <li> <p>When the event got accepted by the <code>RecipeInstance</code> but has not started cascading the execution of <code>InteractionInstances</code>.  For this use the <code>Baker.fireEventAndResolveWhenReceived(recipeInstanceId, eventInstance)</code> API. This will return a  <code>Future[SensoryEventStatus]</code> enum notifying of the outcome (the event might get rejected).</p> </li> <li> <p>When the event got accepted by the <code>RecipeInstance</code> and has finished cascading the execution of <code>InteractionInstances</code> up to the point that it requires more <code>EventInstances</code> (<code>SensoryEvents</code>) to continue, or the process has finished. For this use the <code>Baker.fireEventAndResolveWhenCompleted(recipeInstanceId, eventInstance)</code> API. This will return a  <code>Future[EventResult]</code> object containing a <code>SensoryEventStatus</code>, the <code>Event</code> names that got fired in consequence of this  <code>SensoryEvent</code>, and the current available <code>Ingredients</code> output of the <code>InteractionInstances</code> that got executed as consequence  of the <code>SensoryEvent</code>.</p> </li> <li> <p>You want to do something on both of the previously mentioned moments, then use the  <code>Baker.fireEvent(recipeInstanceId, eventInstance)</code> API, which will return an <code>EventResolutions</code> object which contains both <code>Future[SensoryEventStatus]</code> and <code>Future[EventResult]</code> (or its <code>CompletableFuture&lt;A&gt;</code> equivalents in Java).</p> </li> <li> <p>As soon as an intermediate <code>Event</code> fires from one of the <code>InteractionInstances</code> that execute as consequence of the fired <code>SensoryEvent</code>. For this use the <code>Baker.fireEventAndResolveOnEvent(recipeInstanceId, eventInstance, onEventName)</code> API. This will return  a similar <code>Future[EventResult</code> to the one returned by <code>Baker.fireEventAndResolveWhenCompleted</code> except the data will be up to the moment the <code>onEventName</code> was fired.</p> </li> </ol>"},{"location":"sections/reference/runtime/#correlationid","title":"correlationId","text":"<p>Optionally you may provide a <code>correlation id</code> when firing a <code>EventInstance</code>. The purpose of this identifier is idempotent  event delivery: when sending the same event correlation id multiple times, only the first will be processed.</p> <p>This can be applied to the <code>OrderPlaced</code> event for example.</p> ScalaJava <pre><code>val correlationOrderId = \"a unique order id\"\n\nfor {\n    statusA &lt;- baker.processEventAndResolveWhenReceived(recipeInstanceId, orderPlacedEvent, correlationOrderId)\n    _ = assert(statusA == Received)\n    statusB &lt;- baker.processEventAndResolveWhenReceived(recipeInstanceId, orderPlacedEvent, correlationOrderId)\n    _ = assert(statusB == AlreadyReceived)\n} yield ()\n</code></pre> <pre><code>String correlationOrderId = \"a unique order id\";\n\nSensoryEventStatus statusA = baker\n    .processEventAndResolveWhenReceived(recipeInstanceId, orderPlacedEvent, correlationOrderId);\n    .join();\nassert(statusA == Received);\n\nSensoryEventStatus statusB = baker\n    .processEventAndResolveWhenReceived(recipeInstanceId, orderPlacedEvent, correlationOrderId);\n    .join();\nassert(statusB == AlreadyReceived);\n</code></pre>"},{"location":"sections/reference/runtime/#sensoryeventstatus","title":"SensoryEventStatus","text":"Status Description <code>Received</code> The event was received normally <code>AlreadyReceived</code> An event with the same correlation id was already received <code>ProcessDeleted</code> The process instance was deleted <code>ReceivePeriodExpired</code> The receive period for the process instance has passed <code>FiringLimitMet</code> The <code>firing limit</code> for the event was met"},{"location":"sections/reference/runtime/#bakergetrecipeinstancestaterecipeinstanceid","title":"baker.getRecipeInstanceState(recipeInstanceId)","text":"<p><code>baker.getInteractionInstanceState(recipeInstanceId)</code> will return an <code>InteractionInstanceState</code> object which  contains all the event names with timestamps that have executed, and the current available provided ingredient data.</p> ScalaJava <pre><code>import com.ing.baker.runtime.scaladsl.RecipeInstanceState\n\nval state: Future[RecipeInstanceState] = baker.getRecipeInstanceState(recipeInstanceId)\n</code></pre> <pre><code>import com.ing.baker.runtime.javadsl.RecipeInstanceState;\n\nCompletableFuture&lt;RecipeInstanceState&gt; state = baker.getRecipeInstanceState(recipeInstanceId);\n</code></pre>"},{"location":"sections/reference/runtime/#bakergetallinteractioninstancesmetadata","title":"baker.getAllInteractionInstancesMetadata()","text":"<p>Returns the recipeId, recipeInstanceId and creation timestamp of all running <code>RecipeInstances</code>.</p> <p>Note: Can potentially return a partial result when baker runs in cluster mode because not all shards might be reached within  the given timeout.</p> <p>Note: Does not include deleted <code>RecipeInstances</code>.</p>"},{"location":"sections/reference/runtime/#bakergetvisualstaterecipeinstanceid-style","title":"baker.getVisualState(recipeInstanceId, style)","text":"<p>Another method of fetching state is the visual representation of it. You can do that with the <code>Baker.getVisualState(recipeInstanceId)</code> API. This will return a GraphViz string like the visualization api that you can convert into an image.</p> <p>Here is a visualization of the state of another webshop example, one can clearly see that the process is flowing correctly without failures and that it is still waiting for the payment sensory event to be fired.</p> ScalaJava <pre><code>val state: Future[String] = baker.getVisualState(recipeInstanceId)\n</code></pre> <pre><code>CompletableFuture&lt;String&gt; state = baker.getVisualState(recipeInstanceId);\n</code></pre> <p></p>"},{"location":"sections/reference/runtime/#bakerregistereventlistenerrecipename-listenerfunction","title":"baker.registerEventListener(recipeName, listenerFunction)","text":"<p>Registers a listener to all runtime events for this baker instance.</p> <p>Note that: - The delivery guarantee is AT MOST ONCE. Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode.</p> <p>Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests</p> ScalaJava <pre><code>baker.registerEventListener((recipeInstanceId: String, event: EventInstance) =&gt; {\n  println(s\"Recipe instance : $recipeInstanceId processed event ${event.name}\")\n})\n</code></pre> <pre><code>BiConsumer&lt;String, EventInstance&gt; handler = (String recipeInstanceId, EventInstance event) -&gt;\n    System.out.println(\"Recipe Instance \" + recipeInstanceId + \" processed event \" + event.name());\n\nbaker.registerEventListener(handler);\n</code></pre>"},{"location":"sections/reference/runtime/#bakerregisterbakereventlistenerlistenerfunction","title":"baker.registerBakerEventListener(listenerFunction)","text":"<p>Registers a listener to all runtime BAKER events, these are events that notify what Baker is doing, like <code>RecipeInstances</code> received <code>EventInstances</code> or <code>CompiledRecipes</code> being added to baker.</p> <p>Note that: - The delivery guarantee is AT MOST ONCE. Practically this means you can miss events when the application terminates (unexpected or not). - The delivery is local (JVM) only, you will NOT receive events from other nodes when running in cluster mode.</p> <p>Because of these constraints you should not use an event listener for critical functionality. Valid use cases might be: - logging - metrics - unit tests</p> ScalaJava <pre><code>import com.ing.baker.runtime.scaladsl._\n\nbaker.registerBakerEventListener((event: BakerEvent) =&gt; {\n  event match {\n    case e: EventReceived =&gt; println(e)\n    case e: EventRejected =&gt; println(e)\n    case e: InteractionFailed =&gt; println(e)\n    case e: InteractionStarted =&gt; println(e)\n    case e: InteractionCompleted =&gt; println(e)\n    case e: ProcessCreated =&gt; println(e)\n    case e: RecipeAdded =&gt; println(e)\n  }\n})\n</code></pre> <pre><code>import com.ing.baker.runtime.javadsl.BakerEvent;\n\nbaker.registerBakerEventListener((BakerEvent event) -&gt; System.out.println(event));\n</code></pre>"},{"location":"sections/reference/runtime/#bakerretryinteractionrecipeinstanceid-interactionname","title":"baker.retryInteraction(recipeInstanceId, interactionName)","text":"<p>It is possible that during the execution of a <code>RecipeInstance</code> it becomes blocked, this can happen either because it  is <code>directly blocked</code> by an exception (and the <code>FailureStrategy</code> of the <code>Interaction</code> of the <code>Recipe</code> was set to block)  or that the retry strategy was exhausted. At this point it is possible to resolve the blocked interaction in 2 ways.  This one involves forcing another try, resulting either on a successful continued process, or again on a failed state,  to check this you will need to request the state of the <code>RecipeInstance</code> again.</p> <p>Note: this behaviour can be automatically preconfigured by using the <code>RetryWithIncrementalBackoff</code> <code>FailureStrategy</code> on the <code>Interaction</code> of the <code>Recipe</code></p> ScalaJava <pre><code>val program: Future[Unit] = \n    baker.retryInteraction(recipeInstanceId, \"ReserveItems\")\n</code></pre> <pre><code>CompletableFuture&lt;BoxedUnit&gt; program = \n    baker.retryInteraction(recipeInstanceId, \"ReserveItems\");\n</code></pre>"},{"location":"sections/reference/runtime/#bakerresolveinteractionrecipeinstanceid-interactionname-event","title":"baker.resolveInteraction(recipeInstanceId, interactionName, event)","text":"<p>It is possible that during the execution of a <code>RecipeInstance</code> it becomes blocked, this can happen either because it  is <code>directly blocked</code> by an exception or that the retry strategy was exhausted. At this point it is possible to resolve  the blocked interaction in two ways. This one involves resolving the interaction with a chosen <code>EventInstance</code> to replace the one that would have had been computed by the <code>InteractionInstance</code>.</p> <p>Note: this behaviour can be automatically preconfigured by using the <code>FireEventAfterFailure(eventName)</code> <code>FailureStrategy</code> on the <code>Interaction</code> of the <code>Recipe</code></p> ScalaJava <pre><code>val program: Future[Unit] = \n    baker.resolveInteraction(recipeInstanceId, \"ReserveItems\", ItemsReserved(List(\"item1\")))\n</code></pre> <pre><code>CompletableFuture&lt;BoxedUnit&gt; program = \n    baker.resolveInteraction(recipeInstanceId, \"ReserveItems\", new ItemsReserved(List(\"item1\")));\n</code></pre>"},{"location":"sections/reference/runtime/#bakerstopretryinginteractionrecipeinstanceid-interactionname","title":"baker.stopRetryingInteraction(recipeInstanceId, interactionName)","text":"<p>If an <code>Interaction</code> is configured with a <code>RetryWithIncrementalBackoff</code> <code>FailureStrategy</code> then it will not stop retrying  until you call this API or a successful outcome happens from the <code>InteractionInstance</code>.</p> ScalaJava <pre><code>val program: Future[Unit] = \n    baker.stopRetryingInteraction(recipeInstanceId, \"ReserveItems\")\n</code></pre> <pre><code>CompletableFuture&lt;BoxedUnit&gt; program = \n    baker.stopRetryingInteraction(recipeInstanceId, \"ReserveItems\");\n</code></pre>"},{"location":"sections/reference/stores/","title":"Event Stores and Cluster Configuration","text":"<p>Baker keeps the state of your <code>RecipeInstances</code> using a technique called event sourcing, such technique still requires you to save data into a data store if you want to restore state or move it around. Baker's event sourcing uses  Akka's Persistence, and even though you don't need to know how it works, we recommend understanding the implications of it, specially when it comes to configuring and choosing the underlying  data store. </p> <p>The two main categories you have is local vs distributed, the former being used mainly for testing which require no extra  configuration, and the latter for production grade clusters, more specifically if you are going to use Baker on cluster  mode, you NEED a distributed data store for Baker to work as expected. We recommend the usage of Cassandra, since it is  the store the team has tested and used on production, for such you need to use a  plugin like this one.</p>"},{"location":"sections/reference/stores/#configuration-examples","title":"Configuration examples","text":"<p><code>application.conf</code></p> Local non-clusterCluster with distributed store <pre><code>include \"baker.conf\"\n\nakka.cluster.sharding.state-store-mode = persistence\nakka.actor.allow-java-serialization = off\n</code></pre> <pre><code>include \"baker.conf\"\n\nservice {\n\n  actorSystemName = \"CheckoutService\"\n  actorSystemName = ${?ACTOR_SYSTEM_NAME}\n\n  clusterHost = \"127.0.0.1\"\n  clusterHost = ${?CLUSTER_HOST}\n\n  clusterPort = 2551\n  clusterPort = ${?CLUSTER_PORT}\n\n  seedHost = \"127.0.0.1\"\n  seedHost = ${?CLUSTER_SEED_HOST}\n\n  seedPort = 2551\n  seedPort = ${?CLUSTER_SEED_PORT}\n\n}\n\nbaker {\n  actor {\n    provider = \"cluster-sharded\"\n  }\n\n  cluster {\n    nr-of-shards = 52\n    seed-nodes = [\n      \"akka.tcp://\"${service.actorSystemName}\"@\"${service.seedHost}\":\"${service.seedPort}]\n  }\n}\n\nakka {\n\n  actor {\n    provider = \"cluster\"\n  }\n\n  persistence {\n    # See https://doc.akka.io/docs/akka-persistence-cassandra/current/journal.html#configuration\n    journal.plugin = \"cassandra-journal\"\n    # See https://doc.akka.io/docs/akka-persistence-cassandra/current/snapshots.html#configuration\n    snapshot-store.plugin = \"cassandra-snapshot-store\"\n  }\n\n  remote {\n    log-remote-lifecycle-events = off\n    netty.tcp {\n      hostname = ${service.clusterHost}\n      port = ${service.clusterPort}\n    }\n  }\n\n  cluster {\n\n    seed-nodes = [\n      \"akka.tcp://\"${service.actorSystemName}\"@\"${service.seedHost}\":\"${service.seedPort}]\n\n    # auto downing is NOT safe for production deployments.\n    # you may want to use it during development, read more about it in the akka docs.\n    auto-down-unreachable-after = 10s\n  }\n}\n</code></pre>"},{"location":"sections/versions/baker-2/","title":"Migration Guide v2","text":""},{"location":"sections/versions/baker-2/#from-13x-to-200","title":"From 1.3.x to 2.0.0","text":"<p>This guide only describes how to migrate your existing application.</p> <p>Summary:</p> <ul> <li>ALL persisted data from baker <code>1.3.x</code> IS COMPATIBLE and can be used with <code>2.0.x</code></li> <li>When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol.</li> <li>Some small code refactors are necessary (see below).</li> </ul> <p>For a full list new features see the changelog.</p>"},{"location":"sections/versions/baker-2/#downtime-required-for-clusters-with-state","title":"Downtime required for clusters with state","text":"<p>In <code>2.0.0</code> some binary incompatible changes where made in the message protocol.</p> <p>This requires you to bring down the entire cluster (<code>1.3.x</code>) and bring it up again (<code>2.0.0</code>).</p> <p>A rolling deploy IS NOT tested and NOT recommended.</p>"},{"location":"sections/versions/baker-2/#removed-ingredient-interface","title":"Removed Ingredient interface","text":"<p><code>com.ing.baker.recipe.javadsl.Ingredient</code> was removed.</p> <p>This was a tagging interface that was not used in the project.</p> <p>You can remove all references to this interface in your project.</p> <p>One thing to note is that <code>Ingredient</code> extended from <code>scala.Serializable</code>.</p> <p>If you depended on this behaviour just replace <code>Ingredient</code> by <code>scala.Serializable</code>.</p>"},{"location":"sections/versions/baker-2/#providesingredient-removed","title":"@ProvidesIngredient removed","text":"<p>In <code>1.3.x</code> you could directly provide an ingredient from an interaction. For example:</p> <pre><code>import com.ing.baker.recipe.annotations.ProvidesIngredient;\n\ninterface GetEmail {\n\n  @ProvidesIngredient(\"email\")\n  String apply(@RequiresIngredient(\"customer\") Customer customer);\n}\n</code></pre> <p>This feature has been removed. Internally this was already translated to an implicitly generated event: <code>$interactionName + Successful</code>.</p> <p>Now it is required that you do this expclitly to avoid confusion.</p> <p>The refactor is very straight forwfard:</p> <pre><code>import com.ing.baker.recipe.annotations.FiresEvent;\n\ninterface GetEmail {\n\n  public class GetEmailSuccessful {\n    public final String email;\n    public ExampleInteractionSuccessful(String email) {\n      this.email = email;\n    }\n  }\n\n  @FiresEvent(oneOf = { GetEmailSuccessful.class } )\n  GetEmailSuccessful apply(@RequiresIngredient(\"customer\") Customer customer);\n}\n</code></pre> <p>If you use lombok annotations you can get rid of a lot of the boiler plate by using <code>@Value</code> on the event class.</p> <p>In <code>scala</code> it is recommended to use case classes.</p>"},{"location":"sections/versions/baker-3-release-notes/","title":"Release Notes v3","text":"<p>The theme of release 3 is the Baker runtime. We have two goals with this release.</p> <p>The first goal is to be clearer in what the Baker runtime does. We try to achieve this by having better naming and more truthful interface.</p> <p>The second goal is to simplify the internal logic of the runtime. This help when developing baker and has increased the performance of Baker.</p>"},{"location":"sections/versions/baker-3-release-notes/#clearer-and-more-truthful-runtime-interface","title":"Clearer and more truthful runtime interface","text":"<p>The interface of Baker has had a complete overhaul. Most changes are described below. Our documentation also has been improved considerably so please have a look into this if something is unclear.</p>"},{"location":"sections/versions/baker-3-release-notes/#new-approach-to-java-and-scala-dsl-for-the-runtime","title":"New approach to Java and Scala DSL for the runtime","text":"<p>In the past the Baker runtime was created for Scala developers and returned Scala objects. For Java developers we create the JBaker which wrapped around the Baker and translated the objects. The problem with this approach was that the interfaces for Java and Scala developers was going out of sync.</p> <p>In this release we have created two separate packages for Java and Scala interfaces. The javadsl and scaladsl packages contain the same objects but created for those users in mind. These objects share a common parent to ensure the Java and Scala runtime DSLs are in sync. As user you just chooses the correct objects by having either the javadsl or scaladsl imported.</p>"},{"location":"sections/versions/baker-3-release-notes/#no-more-blocking-future-and-completablefuture","title":"No more blocking! Future and CompletableFuture","text":"<p>One of the things that Baker was hiding from the user is that is did a lot of blocking operations. It was also unneeded to block since internally everything already supported using async operations.</p> <p>In this release we have adjusted almost all interfaces of Baker to return a Future (or CompletableFuture for Java). This way Baker does not block anymore and the user is in control. The user can now program with Baker in a more functional way by using these futures. If you as user do not want to you can wait for the result and its clear that the thread is blocked.</p>"},{"location":"sections/versions/baker-3-release-notes/#renames-to-runtime-objects","title":"Renames to runtime objects","text":"<p>One of the things that was unclear is how the runtime objects map to the objects in the Recipe. To make this clearer we have renamed some of the runtime objects.</p> <p>They now map in the following fashion</p> Specification Runtime <code>Type</code> <code>Value</code> <code>Ingredient</code> <code>IngredientInstance</code> <code>Event</code> <code>EventInstance</code> <code>Interaction</code> <code>InteractionInstance</code> <code>Recipe</code> <code>RecipeInstance</code> <p>This means the following renames have been done</p> <ul> <li>Process -&gt; RecipeInstance</li> <li>ProcessId -&gt; RecipeInstanceId</li> <li>RuntimeEvent -&gt; EventInstance</li> <li>InteractionImplementation/Implementation -&gt; InteractionInstance</li> </ul> <p>This also translates to all methods on Baker. For example:</p> <ul> <li>addImplementation -&gt; addInteractionInstance</li> <li>getProcessState -&gt; getRecipeInstanceState</li> </ul>"},{"location":"sections/versions/baker-3-release-notes/#firing-events-into-baker","title":"Firing events into Baker","text":"<p>The processEvent logic has been completely rewritten, it is now been renamed to fireEvent. See the fire event section for more details.</p>"},{"location":"sections/versions/baker-3-release-notes/#eventinstance","title":"EventInstance","text":"<p>In the old versions you could give any object to the processEvent method and Baker would transform this to an Event. This made it sometimes unclear what Baker really accepts as a input for this method. In the new version of Baker you give a EventInstance to Baker. This is the internal object we where creating from the Object in the past. The EventInstance in turn can be created form an Object. The difference now is that its clear that Baker uses EventInstances internally. Another advantage is that you are now also free to create EventInstances any other way.</p> ScalaJava <pre><code>//From any Object\nval orderPlaced = EventInstance\n      .unsafeFrom(SimpleWebshopRecipeReflection.OrderPlaced(orderId, items))\n//Using constructor\nval orderPlace2 =\n        EventInstance.apply(\"OrderPlaced\", Map(\"orderId\"-&gt; Converters.toValue(orderId), \"items\" -&gt; Converters.toValue(items)))\n</code></pre> <pre><code>//From any Object\nEventInstance firstOrderPlaced =\n                EventInstance.from(new JWebshopRecipe.OrderPlaced(orderId, items));\n//Using constructor\nEventInstance firstOrderPlaced2 =\n                EventInstance.apply(\"OrderPlaced\", ImmutableMap.of(\"orderId\", Converters.toValue(orderId), \"items\", Converters.toValue(items)));\n</code></pre>"},{"location":"sections/versions/baker-3-release-notes/#decide-on-what-to-be-notified-on-when-firing-the-event","title":"Decide on what to be notified on when firing the event","text":"<p>Like in the old versions you can ask Baker to notify on specific moments. This can be when the event is received or when the processing is completed. New in this release is that you can now specify this when firing the event itself. The advantage is that Baker can optimize the resources it uses in those cases. This is done using the fireEventAndResolveWhenReceived and fireEventAndResolveWhenCompleted methods.</p> ScalaJava <pre><code>val result: Future[SensoryEventStatus] = baker.fireEventAndResolveWhenReceived(recipeInstanceId, orderPlaced)\nval result: Future[SensoryEventResult] = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, paymentMade)\n</code></pre> <pre><code>CompletableFuture&lt;SensoryEventStatus&gt; result = baker.fireEventAndResolveWhenReceived(recipeInstanceId, paymentMade);\nCompletableFuture&lt;SensoryEventResult&gt; result = baker.fireEventAndResolveWhenCompleted(recipeInstanceId, firstOrderPlaced);\n</code></pre> <p>The old way of firing a event where you get both the co</p>"},{"location":"sections/versions/baker-3-release-notes/#wait-for-a-specific-event","title":"Wait for a specific Event","text":"<p>In this new release we have added a highly requested feature. YOu can now ask baker to notify you on a a specific event. You can use the fireEventAndResolveOnEvent method for this.</p> <p>The returned future will complete when a event with the given name is fired.</p> ScalaJava <pre><code>val result: Future[SensoryEventResult] = baker.fireEventAndResolveOnEvent(recipeInstanceId, orderPlaced, \"eventName\")\n</code></pre> <pre><code>CompletableFuture&lt;SensoryEventResult&gt; result =\n                baker.fireEventAndResolveOnEvent(recipeInstanceId, firstOrderPlaced, \"eventName\");\n</code></pre>"},{"location":"sections/versions/baker-3-release-notes/#eventresult","title":"EventResult","text":"<p>The fireEventAndResolveOnEvent and fireEventAndResolveWhenCompleted return an EventResult. This EventResult object contains the SensoryEventStatus, event names and created ingredients. The addition of the event names and ingredients can be very useful if you need to make a decision depending on the state. In these cases there is no need to inquire on Baker itself anymore.</p> ScalaJava <pre><code>case class SensoryEventResult(\n                               sensoryEventStatus: SensoryEventStatus,\n                               eventNames: Seq[String],\n                               ingredients: Map[String, Value]\n) extends com.ing.baker.runtime.common.SensoryEventResult with ScalaApi\n</code></pre> <pre><code>case class SensoryEventResult(\n                               sensoryEventStatus: SensoryEventStatus,\n                               eventNames: java.util.List[String],\n                               ingredients: java.util.Map[String, Value]\n) extends com.ing.baker.runtime.common.SensoryEventResult with JavaApi {\n\n  def getSensoryEventStatus: SensoryEventStatus = sensoryEventStatus\n\n  def getEventName: java.util.List[String] = eventNames\n\n  def getIngredients: java.util.Map[String, Value] = ingredients\n}\n</code></pre>"},{"location":"sections/versions/baker-3-release-notes/#new-eventlistener-functions","title":"New EventListener functions","text":"<p>For the EventListener we have moved away from the annotation based approach. In this version you can add an EventListener function instead. See the event listener section for more details.</p>"},{"location":"sections/versions/baker-3-release-notes/#improved-and-simplified-runtime","title":"Improved and simplified Runtime","text":""},{"location":"sections/versions/baker-3-release-notes/#better-performance","title":"Better performance","text":"<p>Due to simplifying and refactoring the runtime we see a big increase in the load a Baker instance can handle. For our created example project we saw the project could handle over 5 times the load when switching from version 2 to 3 of Baker.</p>"},{"location":"sections/versions/baker-3-release-notes/#new-journal-for-stateless-processes","title":"New journal for stateless processes","text":"<p>For stateless processes we used to advise to use the in-memory-journal plugin. This journal kept all processes in-memory until the actors where cleaned. For a true stateless process this is unnecessary so we created a new journal. This one just dumps the event sourcing messages. This should lower the memory footprint of stateless users.</p> <p>How to configure: <pre><code>CONFIG\n# Custom journal plugin\nservice.sink-journal {\n  # Class name of the plugin.\n  class = \"com.ing.baker.runtime.akka.journal.SinkJournalWriter\"\n  # Dispatcher for the plugin actor.\n  plugin-dispatcher = \"akka.actor.default-dispatcher\"\n}\n\nservice.sink-snapshot-store {\n  # Class name of the plugin.\n  class = \"com.ing.baker.runtime.akka.journal.SinkSnapshotStore\"\n  # Dispatcher for the plugin actor.\n  plugin-dispatcher = \"akka.persistence.dispatchers.default-plugin-dispatcher\"\n}\nakka.persistence {\n  journal.plugin = \"service.sink-journal\"\n  snapshot-store.plugin = \"service.sink-snapshot-store\"\n}\n</code></pre></p>"},{"location":"sections/versions/baker-3-release-notes/#support-for-async-interactions","title":"Support for async interactions","text":"<p>It is now possible to create interactions that return their events in a Future or CompletableFuture. When using this Baker can close threads instead of blocking a thread. Which in turn again improves performance. The downside of using async interaction is that some validations cannot be done anymore due to type erasure.</p> <p>To use this in Scala you just return a Future of the result of your interaction. In Java you need to return a CompletableFuture of your result and add an AsyncInteraction annotation on top of your InteractionInstance.</p>"},{"location":"sections/versions/baker-3-release-notes/#deprecatedremoved","title":"Deprecated/Removed","text":""},{"location":"sections/versions/baker-3-release-notes/#eventlistener","title":"EventListener","text":"<p>The EventListener object used in the Java runtime has been deprecated. We advice users to move over the logic to the registerBakerEventListener that accepts functions instead.</p>"},{"location":"sections/versions/baker-3-release-notes/#sieves","title":"Sieves","text":"<p>The Sieve concept has slowly been deprecated in the last releases. In version 2 there was already no difference between a sieve and an interaction. In this release we have removed sieves completely.</p>"},{"location":"sections/versions/baker-3-release-notes/#uuid-support","title":"UUID support","text":"<p>In JBaker we supported using a UUID as a processId. In this release this has been removed completely and we accept Strings. This is again in line with being clearer what Baker does. Internally we were just transforming this to a String.</p>"},{"location":"sections/versions/baker-3-release-notes/#accesss-to-runtimeevents","title":"Accesss to RuntimeEvents","text":"<p>Version 2 would provided undocumented public interfaces returning RuntimeEvent instances. In version 3, the possibility to get Ingredients provided by a specific Event is gone. Users should not care where ingredients are provided from. This could be from an SensoryEvent or as output of a Event from an Interaction. This should not matter, only if the ingredient is available should matter. This allow users to flexibly recipes without impacting client code.</p>"},{"location":"sections/versions/baker-3/","title":"Migration Guide v3","text":""},{"location":"sections/versions/baker-3/#from-2xx-to-300","title":"From 2.X.X to 3.0.0","text":"<p>This guide only describes how to migrate your existing application. For a full list new features see the release notes.</p> <p>Summary:</p> <ul> <li>ALL persisted data from older baker versions IS COMPATIBLE and can be used with <code>3.0.0</code></li> <li>When running a cluster DOWNTIME IS REQUIRED because of binary incompatible changes in the message protocol.</li> <li>Code changes are needed to comply to the new Baker interface</li> <li>No code changes needed to the Recipe (except the removal of the sieve concept)</li> </ul>"},{"location":"sections/versions/baker-3/#downtime-required-for-clusters-with-state","title":"Downtime required for clusters with state","text":"<p>In <code>3.0.0</code> some binary incompatible changes where made in the message protocol.</p> <p>This requires you to bring down the entire cluster (<code>2.x.x</code>) and bring it up again (<code>3.0.0</code>).</p> <p>A rolling deploy is tested but is NOT recommended. During the rolling deploy messages regarding handling events will fail. It is safer to bring the complete cluster down.</p>"},{"location":"sections/versions/baker-3/#renamespackage-changes","title":"Renames/package changes","text":"<ul> <li>com.ing.baker.runtime.core -&gt; com.ing.baker.runtime.javadsl/scaladsl/common (depends per object)</li> <li>com.ing.baker.runtime.java_api -&gt; com.ing.baker.runtime.javadsl</li> <li>processId -&gt; recipeInstanceId</li> <li>getProcessId -&gt; GetRecipeInstanceId</li> <li>RuntimeEvent -&gt; EventInstance</li> <li>ProcessState -&gt; RecipeInstanceState</li> </ul>"},{"location":"sections/versions/baker-3/#future-and-completablefuture","title":"Future and CompletableFuture","text":"<p>The new Java and Scala interfaces now almost always return a Future or CompletableFuture. It is now up to the user to handle waiting for the completion of this future. This can either be by blocking directly or by 'correctly' programming with these Futures. We REALLY advise to invest in programming in a non blocking fashion!</p> ScalaJava <pre><code>//Blocking\nval futureStatus: Future[SensoryEventStatus] = baker.fireEventAndResolveWhenReceived(orderId, event)\nval status: SensoryEventStatus = Await.result(futureStatus, 10 seconds)\n\n//Non Blocking\nval futureStatus: Future[SensoryEventStatus] = baker.fireEventAndResolveWhenReceived(orderId, event)\nfutureStatus.map(sensoryEventStatus =&gt; {\n     //Code to handle status\n})\n</code></pre> <pre><code>//Blocking\nCompletableFuture&lt;SensoryEventStatus&gt; futureStatus =\n                baker.fireEventAndResolveWhenReceived(uuid.toString(), EventInstance.from(new ExampleEvent()));\nSensoryEventStatus sensoryEventStatus = futureStatus.get();\n\n\n//Non blocking\nCompletableFuture&lt;SensoryEventStatus&gt; futureStatus =\n                baker.fireEventAndResolveWhenReceived(uuid.toString(), eventInstance));\n\nfutureStatus.thenApply(sensoryEventStatus -&gt; {\n      //Code to handle status\n});\n</code></pre> <p>Any Exceptions that used to be thrown by Baker are now encapsulated in the Future/CompletableFuture. For the CompletableFuture the original exception is wrapped in the ExecutionException. This is how CompletableFuture work and there is no way around it.</p> Java <pre><code>//Blocking\ntry {\n    baker.fireEventAndResolveWhenCompleted(processId, EventInstance.from(new ExampleEventClass())).get();\n} catch (ExecutionException e) {\n    if(e.getCause() instanceof BakerException.NoSuchProcessException) {\n        //Code to handle NoSuchProcessException\n    }\n    //Code to handle other Exceptions\n}\n\n\n//Non blocking\nbaker.fireEventAndResolveWhenCompleted(processId, EventInstance.from(new ExampleEventClass()))\n        .exceptionally(exception -&gt; {\n            if(exception.getCause() instanceof BakerException.NoSuchProcessException) {\n                //Decide on what to return on NoSuchProcessException\n            }\n            //Decide on what to return on other Exceptions\n        });\n</code></pre>"},{"location":"sections/versions/baker-3/#creating-a-baker-instance","title":"Creating a Baker instance","text":"<p>A Baker instance is now created not with a constructor but via a static method.</p> <p>For Java the JBaker is gone and you now create a Baker under the javadsl package.</p> ScalaJava <pre><code>import com.ing.baker.runtime.scaladsl.*;\n......\nval actorSystem: ActorSystem = ActorSystem(\"WebshopSystem\")\nval config: Config = ConfigFactory.load()\nval baker = Baker.akka(config, actorSystem);\n</code></pre> <pre><code>import com.ing.baker.runtime.javadsl.*;\n......\nActorSystem actorSystem = ActorSystem.create(\"WebshopSystem\");\nConfig config = ConfigFactory.load();\nBaker baker = Baker.akka(config, actorSystem);\n</code></pre> <p>See the runtime reference for more details</p>"},{"location":"sections/versions/baker-3/#adding-interactions-into-baker","title":"Adding Interactions into Baker","text":"<p>When adding InteractionInstances formerly known as InteractionImplementations to Baker you now need to give a real InteractionInstance object.</p> ScalaJava <pre><code>val reserveItemsInstance: InteractionInstance =\n    InteractionInstance.unsafeFrom(new ReserveItemsInstance)\nbaker.addInteractionInstance(reserveItemsInstance)\n</code></pre> <pre><code>InteractionInstance reserveItemsInstance =\n    InteractionInstance.from(new ReserveItemsInstance());\nbaker.addInteractionInstance(reserveItemsInstance)\n</code></pre>"},{"location":"sections/versions/baker-3/#firing-events","title":"Firing events","text":"<p>The processEvent has been completely rewritten and is now named FireEvent. See the release note or fire event section for more details</p>"},{"location":"sections/versions/baker-3/#small-changes","title":"Small changes","text":"<ul> <li>dropped .withSieves on the recipe, add these with .withInteractionInstances</li> <li>removed support in the interface for UUID, for interaction interfaces a UUID is still supported for backwards compatability reasons.</li> </ul>"},{"location":"sections/versions/baker-3/#about-artery-for-akka-remoting","title":"About Artery for Akka remoting","text":"<p>Akka has released a new remoting protocol called Artery This is very interesting for Baker users that have Akka cluster. We have successfully migrated to this from the old remoting and see stability and performance gains.</p>"},{"location":"sections/versions/baker-3/#dependency","title":"Dependency","text":"<p>We have noticed that when using Baker in a maven project the dependencies are not always take over correctly. If you have the following dependencies in your project please upgrade them: * org.typelevel.cats-core_2.12 1.5.0 * org.typelevel.cats-effect_2.12 1.2.0 * All Akka dependencies to 2.5.22 (should work with other 2.5.X versions but 2.5.22 is the one we tested).</p>"}]}